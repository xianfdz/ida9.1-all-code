"""Defines the interface between the kernel and the UI.

It contains:
* the UI dispatcher notification codes (ui_notification_t)
* convenience functions for UI services
* structures which hold information about the lines (disassembly, structures, enums) generated by the kernel
* functions to interact with the user (dialog boxes)
* some string and conversion functions. 


    """
from sys import version_info as _swig_python_version_info
if __package__ or '.' in __name__:
    from . import _ida_kernwin
else:
    import _ida_kernwin
try:
    import builtins as __builtin__
except ImportError:
    import __builtin__


def _swig_repr(self):
    try:
        strthis = 'proxy of ' + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ''
    return '<%s.%s; %s >' % (self.__class__.__module__, self.__class__.
        __name__, strthis)


def _swig_setattr_nondynamic_instance_variable(set):

    def set_instance_attr(self, name, value):
        if name == 'this':
            set(self, name, value)
        elif name == 'thisown':
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name),
            property):
            set(self, name, value)
        else:
            raise AttributeError('You cannot add instance attributes to %s' %
                self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):

    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError('You cannot add class attributes to %s' % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""

    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref
SWIG_PYTHON_LEGACY_BOOL = _ida_kernwin.SWIG_PYTHON_LEGACY_BOOL
from typing import Tuple, List, Union
import ida_idaapi


def _kludge_force_declare_dirspec_t(arg1: 'dirspec_t const *') ->None:
    return _ida_kernwin._kludge_force_declare_dirspec_t(arg1)


def _kludge_force_declare_dirtree_t(arg1: 'dirtree_t const *') ->None:
    return _ida_kernwin._kludge_force_declare_dirtree_t(arg1)


class chooser_row_info_vec_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.chooser_row_info_vec_t_swiginit(self, _ida_kernwin.
            new_chooser_row_info_vec_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_chooser_row_info_vec_t

    def push_back(self, *args) ->'chooser_row_info_t &':
        return _ida_kernwin.chooser_row_info_vec_t_push_back(self, *args)

    def pop_back(self) ->None:
        return _ida_kernwin.chooser_row_info_vec_t_pop_back(self)

    def size(self) ->'size_t':
        return _ida_kernwin.chooser_row_info_vec_t_size(self)

    def empty(self) ->bool:
        return _ida_kernwin.chooser_row_info_vec_t_empty(self)

    def at(self, _idx: 'size_t') ->'chooser_row_info_t const &':
        return _ida_kernwin.chooser_row_info_vec_t_at(self, _idx)

    def qclear(self) ->None:
        return _ida_kernwin.chooser_row_info_vec_t_qclear(self)

    def clear(self) ->None:
        return _ida_kernwin.chooser_row_info_vec_t_clear(self)

    def resize(self, *args) ->None:
        return _ida_kernwin.chooser_row_info_vec_t_resize(self, *args)

    def grow(self, *args) ->None:
        return _ida_kernwin.chooser_row_info_vec_t_grow(self, *args)

    def capacity(self) ->'size_t':
        return _ida_kernwin.chooser_row_info_vec_t_capacity(self)

    def reserve(self, cnt: 'size_t') ->None:
        return _ida_kernwin.chooser_row_info_vec_t_reserve(self, cnt)

    def truncate(self) ->None:
        return _ida_kernwin.chooser_row_info_vec_t_truncate(self)

    def swap(self, r: 'chooser_row_info_vec_t') ->None:
        return _ida_kernwin.chooser_row_info_vec_t_swap(self, r)

    def extract(self) ->'chooser_row_info_t *':
        return _ida_kernwin.chooser_row_info_vec_t_extract(self)

    def inject(self, s: 'chooser_row_info_t', len: 'size_t') ->None:
        return _ida_kernwin.chooser_row_info_vec_t_inject(self, s, len)

    def __eq__(self, r: 'chooser_row_info_vec_t') ->bool:
        return _ida_kernwin.chooser_row_info_vec_t___eq__(self, r)

    def __ne__(self, r: 'chooser_row_info_vec_t') ->bool:
        return _ida_kernwin.chooser_row_info_vec_t___ne__(self, r)

    def begin(self, *args) ->'qvector< chooser_row_info_t >::const_iterator':
        return _ida_kernwin.chooser_row_info_vec_t_begin(self, *args)

    def end(self, *args) ->'qvector< chooser_row_info_t >::const_iterator':
        return _ida_kernwin.chooser_row_info_vec_t_end(self, *args)

    def insert(self, it: 'chooser_row_info_t', x: 'chooser_row_info_t'
        ) ->'qvector< chooser_row_info_t >::iterator':
        return _ida_kernwin.chooser_row_info_vec_t_insert(self, it, x)

    def erase(self, *args) ->'qvector< chooser_row_info_t >::iterator':
        return _ida_kernwin.chooser_row_info_vec_t_erase(self, *args)

    def find(self, *args) ->'qvector< chooser_row_info_t >::const_iterator':
        return _ida_kernwin.chooser_row_info_vec_t_find(self, *args)

    def has(self, x: 'chooser_row_info_t') ->bool:
        return _ida_kernwin.chooser_row_info_vec_t_has(self, x)

    def add_unique(self, x: 'chooser_row_info_t') ->bool:
        return _ida_kernwin.chooser_row_info_vec_t_add_unique(self, x)

    def _del(self, x: 'chooser_row_info_t') ->bool:
        return _ida_kernwin.chooser_row_info_vec_t__del(self, x)

    def __len__(self) ->'size_t':
        return _ida_kernwin.chooser_row_info_vec_t___len__(self)

    def __getitem__(self, i: 'size_t') ->'chooser_row_info_t const &':
        return _ida_kernwin.chooser_row_info_vec_t___getitem__(self, i)

    def __setitem__(self, i: 'size_t', v: 'chooser_row_info_t') ->None:
        return _ida_kernwin.chooser_row_info_vec_t___setitem__(self, i, v)

    def append(self, x: 'chooser_row_info_t') ->None:
        return _ida_kernwin.chooser_row_info_vec_t_append(self, x)

    def extend(self, x: 'chooser_row_info_vec_t') ->None:
        return _ida_kernwin.chooser_row_info_vec_t_extend(self, x)
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


_ida_kernwin.chooser_row_info_vec_t_swigregister(chooser_row_info_vec_t)


class tagged_line_section_vec_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.tagged_line_section_vec_t_swiginit(self, _ida_kernwin.
            new_tagged_line_section_vec_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_tagged_line_section_vec_t

    def push_back(self, *args) ->'tagged_line_section_t &':
        return _ida_kernwin.tagged_line_section_vec_t_push_back(self, *args)

    def pop_back(self) ->None:
        return _ida_kernwin.tagged_line_section_vec_t_pop_back(self)

    def size(self) ->'size_t':
        return _ida_kernwin.tagged_line_section_vec_t_size(self)

    def empty(self) ->bool:
        return _ida_kernwin.tagged_line_section_vec_t_empty(self)

    def at(self, _idx: 'size_t') ->'tagged_line_section_t const &':
        return _ida_kernwin.tagged_line_section_vec_t_at(self, _idx)

    def qclear(self) ->None:
        return _ida_kernwin.tagged_line_section_vec_t_qclear(self)

    def clear(self) ->None:
        return _ida_kernwin.tagged_line_section_vec_t_clear(self)

    def resize(self, *args) ->None:
        return _ida_kernwin.tagged_line_section_vec_t_resize(self, *args)

    def grow(self, *args) ->None:
        return _ida_kernwin.tagged_line_section_vec_t_grow(self, *args)

    def capacity(self) ->'size_t':
        return _ida_kernwin.tagged_line_section_vec_t_capacity(self)

    def reserve(self, cnt: 'size_t') ->None:
        return _ida_kernwin.tagged_line_section_vec_t_reserve(self, cnt)

    def truncate(self) ->None:
        return _ida_kernwin.tagged_line_section_vec_t_truncate(self)

    def swap(self, r: 'tagged_line_section_vec_t') ->None:
        return _ida_kernwin.tagged_line_section_vec_t_swap(self, r)

    def extract(self) ->'tagged_line_section_t *':
        return _ida_kernwin.tagged_line_section_vec_t_extract(self)

    def inject(self, s: 'tagged_line_section_t', len: 'size_t') ->None:
        return _ida_kernwin.tagged_line_section_vec_t_inject(self, s, len)

    def __eq__(self, r: 'tagged_line_section_vec_t') ->bool:
        return _ida_kernwin.tagged_line_section_vec_t___eq__(self, r)

    def __ne__(self, r: 'tagged_line_section_vec_t') ->bool:
        return _ida_kernwin.tagged_line_section_vec_t___ne__(self, r)

    def begin(self, *args
        ) ->'qvector< tagged_line_section_t >::const_iterator':
        return _ida_kernwin.tagged_line_section_vec_t_begin(self, *args)

    def end(self, *args) ->'qvector< tagged_line_section_t >::const_iterator':
        return _ida_kernwin.tagged_line_section_vec_t_end(self, *args)

    def insert(self, it: 'tagged_line_section_t', x: 'tagged_line_section_t'
        ) ->'qvector< tagged_line_section_t >::iterator':
        return _ida_kernwin.tagged_line_section_vec_t_insert(self, it, x)

    def erase(self, *args) ->'qvector< tagged_line_section_t >::iterator':
        return _ida_kernwin.tagged_line_section_vec_t_erase(self, *args)

    def find(self, *args) ->'qvector< tagged_line_section_t >::const_iterator':
        return _ida_kernwin.tagged_line_section_vec_t_find(self, *args)

    def has(self, x: 'tagged_line_section_t') ->bool:
        return _ida_kernwin.tagged_line_section_vec_t_has(self, x)

    def add_unique(self, x: 'tagged_line_section_t') ->bool:
        return _ida_kernwin.tagged_line_section_vec_t_add_unique(self, x)

    def _del(self, x: 'tagged_line_section_t') ->bool:
        return _ida_kernwin.tagged_line_section_vec_t__del(self, x)

    def __len__(self) ->'size_t':
        return _ida_kernwin.tagged_line_section_vec_t___len__(self)

    def __getitem__(self, i: 'size_t') ->'tagged_line_section_t const &':
        return _ida_kernwin.tagged_line_section_vec_t___getitem__(self, i)

    def __setitem__(self, i: 'size_t', v: 'tagged_line_section_t') ->None:
        return _ida_kernwin.tagged_line_section_vec_t___setitem__(self, i, v)

    def append(self, x: 'tagged_line_section_t') ->None:
        return _ida_kernwin.tagged_line_section_vec_t_append(self, x)

    def extend(self, x: 'tagged_line_section_vec_t') ->None:
        return _ida_kernwin.tagged_line_section_vec_t_extend(self, x)
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


_ida_kernwin.tagged_line_section_vec_t_swigregister(tagged_line_section_vec_t)


def refresh_choosers() ->None:
    return _ida_kernwin.refresh_choosers()


def textctrl_info_t_create() ->'PyObject *':
    return _ida_kernwin.textctrl_info_t_create()


def textctrl_info_t_destroy(py_obj: 'PyObject *') ->bool:
    return _ida_kernwin.textctrl_info_t_destroy(py_obj)


def textctrl_info_t_get_clink(_self: 'PyObject *') ->'textctrl_info_t *':
    return _ida_kernwin.textctrl_info_t_get_clink(_self)


def textctrl_info_t_get_clink_ptr(_self: 'PyObject *') ->'PyObject *':
    return _ida_kernwin.textctrl_info_t_get_clink_ptr(_self)


def register_timer(interval, callback):
    """Register a timer

@param interval: Interval in milliseconds
@param callback: A Python callable that takes no parameters and returns an integer.
                 The callback may return:
                 -1   : to unregister the timer
                 >= 0 : the new or same timer interval
@return: None or a timer object"""
    return _ida_kernwin.register_timer(interval, callback)


def unregister_timer(timer_obj):
    """Unregister a timer

@param timer_obj: a timer object previously returned by a register_timer()
@return: Boolean
@note: After the timer has been deleted, the timer_obj will become invalid."""
    return _ida_kernwin.unregister_timer(timer_obj)


def choose_idasgn():
    """Opens the signature chooser

@return: None or the selected signature name"""
    return _ida_kernwin.choose_idasgn()


def get_highlight(v, flags=0):
    """Returns the currently highlighted identifier and flags

@param v: The UI widget to operate on
@param flags: Optionally specify a slot (see kernwin.hpp), current otherwise
@return: a tuple (text, flags), or None if nothing
         is highlighted or in case of error."""
    return _ida_kernwin.get_highlight(v, flags)


def py_load_custom_icon_fn(filename: str) ->int:
    return _ida_kernwin.py_load_custom_icon_fn(filename)


def py_load_custom_icon_data(data: 'PyObject *', format: str) ->int:
    return _ida_kernwin.py_load_custom_icon_data(data, format)


def msg(message):
    """Display a message in the message window

@param message: message to print"""
    if isinstance(message, bytes):
        message = message.decode('UTF-8')
    return _ida_kernwin.msg(message)


def warning(message):
    """Display a message in a warning message box

@param message: message to print"""
    if isinstance(message, bytes):
        message = message.decode('UTF-8')
    return _ida_kernwin.warning(message)


def error(message):
    """Display a fatal message in a message box and quit IDA

@param format: message to print"""
    if isinstance(message, bytes):
        message = message.decode('UTF-8')
    return _ida_kernwin.error(message)


def ask_text(max_size: int, defval: str, prompt: str) ->Union[str, None]:
    """Asks for a long text

@param max_size: Maximum text length, 0 for unlimited
@param defval: The default value
@param prompt: The prompt value
@return: None or the entered string"""
    return _ida_kernwin.ask_text(max_size, defval, prompt)


def ask_str(defval, hist, prompt):
    """Asks for a long text

@param defval: The default value
@param hist:   history id
@param prompt: The prompt value
@return: None or the entered string"""
    return _ida_kernwin.ask_str(defval, hist, prompt)


def process_ui_action(name: str, flags: int=0):
    """Invokes an IDA UI action by name

@param name:  action name
@param flags: reserved
@return: Boolean"""
    return _ida_kernwin.process_ui_action(name, flags)


def del_hotkey(ctx):
    """Deletes a previously registered function hotkey

@param ctx: Hotkey context previously returned by add_hotkey()

@return: Boolean."""
    return _ida_kernwin.del_hotkey(ctx)


def add_hotkey(hotkey, callable):
    """Associates a function call with a hotkey.
Callable 'callable' will be called each time the hotkey is pressed

@param hotkey: The hotkey
@param callable: Callable

@return: Context object on success or None on failure."""
    return _ida_kernwin.add_hotkey(hotkey, callable)


def take_database_snapshot(snapshot) ->Tuple[bool, str]:
    """Take a database snapshot.

@param snapshot the snapshot object
@return a tuple (success, error-message)"""
    return _ida_kernwin.take_database_snapshot(snapshot)


def restore_database_snapshot(snapshot, callback, userdata) ->bool:
    """Restore a database snapshot.

Note: This call is asynchronous. When it is completed, the callback will be triggered.

@param snapshot the snapshot object
@param callback a callback function
@param userdata payload to pass to the callback
@return success"""
    return _ida_kernwin.restore_database_snapshot(snapshot, callback, userdata)


def execute_sync(callable, reqf):
    """Executes a function in the context of the main thread.
If the current thread not the main thread, then the call is queued and
executed afterwards.

@param callable: A python callable object, must return an integer value
@param reqf: one of MFF_ flags
@return: -1 or the return value of the callable"""
    return _ida_kernwin.execute_sync(callable, reqf)


def execute_ui_requests(callable_list):
    """Inserts a list of callables into the UI message processing queue.
When the UI is ready it will call one callable.
A callable can request to be called more than once if it returns True.

@param callable_list: A list of python callable objects.
@note: A callable should return True if it wants to be called more than once.
@return: Boolean. False if the list contains a non callable item"""
    return _ida_kernwin.execute_ui_requests(callable_list)


class jobj_wrapper_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined')
    __repr__ = _swig_repr

    def get_dict(self) ->dict:
        """Retrieve the contents of this object, as a dict

@return a dict containing all kvp's in this object"""
        return _ida_kernwin.jobj_wrapper_t_get_dict(self)


_ida_kernwin.jobj_wrapper_t_swigregister(jobj_wrapper_t)


class UI_Hooks(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, _flags: int=0, _hkcb_flags: int=1):
        if self.__class__ == UI_Hooks:
            _self = None
        else:
            _self = self
        _ida_kernwin.UI_Hooks_swiginit(self, _ida_kernwin.new_UI_Hooks(
            _self, _flags, _hkcb_flags))

    def hook(self) ->bool:
        return _ida_kernwin.UI_Hooks_hook(self)

    def unhook(self) ->bool:
        return _ida_kernwin.UI_Hooks_unhook(self)

    def range(self) ->None:
        """The disassembly range has been changed ( idainfo::min_ea ... idainfo::max_ea). UI should redraw the scrollbars. See also: ui_lock_range_refresh 
          
@returns void"""
        return _ida_kernwin.UI_Hooks_range(self)

    def idcstart(self) ->None:
        """Start of IDC engine work. 
          
@returns void"""
        return _ida_kernwin.UI_Hooks_idcstart(self)

    def idcstop(self) ->None:
        """Stop of IDC engine work. 
          
@returns void"""
        return _ida_kernwin.UI_Hooks_idcstop(self)

    def suspend(self) ->None:
        """Suspend graphical interface. Only the text version. Interface should respond to it. 
          
@returns void"""
        return _ida_kernwin.UI_Hooks_suspend(self)

    def resume(self) ->None:
        """Resume the suspended graphical interface. Only the text version. Interface should respond to it 
          
@returns void"""
        return _ida_kernwin.UI_Hooks_resume(self)

    def saving(self) ->None:
        """The kernel is flushing its buffers to the disk. The user interface should save its state. Parameters: none Returns: none 
          """
        return _ida_kernwin.UI_Hooks_saving(self)

    def saved(self, path: str) ->None:
        """The kernel has saved the database. This callback just informs the interface. Note that at the time this notification is sent, the internal paths are not updated yet, and calling get_path(PATH_TYPE_IDB) will return the previous path. 
          
@param path: (const char *) the database path
@returns void"""
        return _ida_kernwin.UI_Hooks_saved(self, path)

    def database_closed(self) ->None:
        """The database has been closed. See also processor_t::closebase, it occurs earlier. See also ui_initing_database. This is not the same as IDA exiting. If you need to perform cleanup at the exiting time, use qatexit(). 
          
@returns void"""
        return _ida_kernwin.UI_Hooks_database_closed(self)

    def debugger_menu_change(self, enable: bool) ->None:
        """debugger menu modification detected 
          
@param enable: (bool) true: debugger menu has been added, or a different debugger has been selected false: debugger menu will be removed (user switched to "No debugger")
@returns void"""
        return _ida_kernwin.UI_Hooks_debugger_menu_change(self, enable)

    def widget_visible(self, widget: 'TWidget *') ->None:
        """TWidget is displayed on the screen. Use this event to populate the window with controls 
          
@param widget: (TWidget *)
@returns void"""
        return _ida_kernwin.UI_Hooks_widget_visible(self, widget)

    def widget_closing(self, widget: 'TWidget *') ->None:
        """TWidget is about to close. This event precedes ui_widget_invisible. Use this to perform some possible actions relevant to the lifecycle of this widget 
          
@param widget: (TWidget *)
@returns void"""
        return _ida_kernwin.UI_Hooks_widget_closing(self, widget)

    def widget_invisible(self, widget: 'TWidget *') ->None:
        """TWidget is being closed. Use this event to destroy the window controls 
          
@param widget: (TWidget *)
@returns void"""
        return _ida_kernwin.UI_Hooks_widget_invisible(self, widget)

    def get_ea_hint(self, ea: ida_idaapi.ea_t) ->'PyObject *':
        """ui wants to display a simple hint for an address. Use this event to generate a custom hint See also more generic ui_get_item_hint 
          
@param ea: (::ea_t)
@returns true if generated a hint"""
        return _ida_kernwin.UI_Hooks_get_ea_hint(self, ea)

    def get_item_hint(self, ea: ida_idaapi.ea_t, max_lines: int
        ) ->'PyObject *':
        """ui wants to display multiline hint for an item. See also more generic ui_get_custom_viewer_hint 
          
@param ea: (ea_t) or item id like a structure or enum member
@param max_lines: (int) maximal number of lines
@returns true if generated a hint"""
        return _ida_kernwin.UI_Hooks_get_item_hint(self, ea, max_lines)

    def get_custom_viewer_hint(self, viewer: 'TWidget *', place: 'place_t'
        ) ->'PyObject *':
        """ui wants to display a hint for a viewer (idaview or custom). Every subscriber is supposed to append the hint lines to HINT and increment IMPORTANT_LINES accordingly. Completely overwriting the existing lines in HINT is possible but not recommended. If the REG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the "regular" hints. If the SRCDBG_HINTS_MARKER sequence is found in the returned hints string, it will be replaced with the contents of the source-level debugger-generated hints. The following keywords might appear at the beginning of the returned hints: HIGHLIGHT text
 where text will be highlighted CAPTION caption
 caption for the hint widget 
          
@param viewer: (TWidget*) viewer
@param place: (place_t *) current position in the viewer
@retval 0: continue collecting hints with other subscribers
@retval 1: stop collecting hints"""
        return _ida_kernwin.UI_Hooks_get_custom_viewer_hint(self, viewer, place
            )

    def database_inited(self, is_new_database: int, idc_script: str) ->None:
        """database initialization has completed. the kernel is about to run idc scripts 
          
@param is_new_database: (int)
@param idc_script: (const char *) - may be nullptr
@returns void See also ui_initing_database. This event is called for both new and old databases."""
        return _ida_kernwin.UI_Hooks_database_inited(self, is_new_database,
            idc_script)

    def ready_to_run(self) ->None:
        """all UI elements have been initialized. Automatic plugins may hook to this event to perform their tasks. 
          
@returns void"""
        return _ida_kernwin.UI_Hooks_ready_to_run(self)

    def preprocess_action(self, name: str) ->int:
        """ida ui is about to handle a user action. 
          
@param name: (const char *) ui action name. these names can be looked up in ida[tg]ui.cfg
@retval 0: ok
@retval nonzero: a plugin has handled the command"""
        return _ida_kernwin.UI_Hooks_preprocess_action(self, name)

    def postprocess_action(self) ->None:
        """an ida ui action has been handled
"""
        return _ida_kernwin.UI_Hooks_postprocess_action(self)

    def get_chooser_item_attrs(self, chooser: 'chooser_base_t', n: 'size_t',
        attrs: 'chooser_item_attrs_t') ->None:
        """get item-specific attributes for a chooser. This callback is generated only after enable_chooser_attrs() 
          
@param chooser: (const chooser_base_t *)
@param n: (::size_t)
@param attrs: (chooser_item_attrs_t *)
@returns void"""
        return _ida_kernwin.UI_Hooks_get_chooser_item_attrs(self, chooser,
            n, attrs)

    def updating_actions(self, ctx: 'action_ctx_base_t') ->None:
        """IDA is about to update all actions. If your plugin needs to perform expensive operations more than once (e.g., once per action it registers), you should do them only once, right away. 
          
@param ctx: (action_update_ctx_t *)
@returns void"""
        return _ida_kernwin.UI_Hooks_updating_actions(self, ctx)

    def updated_actions(self) ->None:
        """IDA is done updating actions. 
          
@returns void"""
        return _ida_kernwin.UI_Hooks_updated_actions(self)

    def populating_widget_popup(self, widget: 'TWidget *', popup_handle:
        'TPopupMenu *', ctx: 'action_ctx_base_t'=None) ->None:
        """IDA is populating the context menu for a widget. This is your chance to attach_action_to_popup().
Have a look at ui_finish_populating_widget_popup, if you want to augment the context menu with your own actions after the menu has had a chance to be properly populated by the owning component or plugin (which typically does it on ui_populating_widget_popup.)

@param widget: (TWidget *)
@param popup_handle: (TPopupMenu *)
@param ctx: (const action_activation_ctx_t *)
@returns void"""
        return _ida_kernwin.UI_Hooks_populating_widget_popup(self, widget,
            popup_handle, ctx)

    def finish_populating_widget_popup(self, widget: 'TWidget *',
        popup_handle: 'TPopupMenu *', ctx: 'action_ctx_base_t'=None) ->None:
        """IDA is about to be done populating the context menu for a widget. This is your chance to attach_action_to_popup().

@param widget: (TWidget *)
@param popup_handle: (TPopupMenu *)
@param ctx: (const action_activation_ctx_t *)
@returns void"""
        return _ida_kernwin.UI_Hooks_finish_populating_widget_popup(self,
            widget, popup_handle, ctx)

    def plugin_loaded(self, plugin_info: 'plugin_info_t const *') ->None:
        """The plugin was loaded in memory. 
          
@param plugin_info: (const plugin_info_t *)"""
        return _ida_kernwin.UI_Hooks_plugin_loaded(self, plugin_info)

    def plugin_unloading(self, plugin_info: 'plugin_info_t const *') ->None:
        """The plugin is about to be unloaded 
          
@param plugin_info: (const plugin_info_t *)"""
        return _ida_kernwin.UI_Hooks_plugin_unloading(self, plugin_info)

    def current_widget_changed(self, widget: 'TWidget *', prev_widget:
        'TWidget *') ->None:
        """The currently-active TWidget changed. 
          
@param widget: (TWidget *)
@param prev_widget: (TWidget *)
@returns void"""
        return _ida_kernwin.UI_Hooks_current_widget_changed(self, widget,
            prev_widget)

    def screen_ea_changed(self, ea: ida_idaapi.ea_t, prev_ea: ida_idaapi.ea_t
        ) ->None:
        """The "current address" changed 
          
@param ea: (ea_t)
@param prev_ea: (ea_t)
@returns void"""
        return _ida_kernwin.UI_Hooks_screen_ea_changed(self, ea, prev_ea)

    def create_desktop_widget(self, title: str, cfg: 'jobj_wrapper_t'
        ) ->'PyObject *':
        """create a widget, to be placed in the widget tree (at desktop-creation time.) 
          
@param title: (const char *)
@param cfg: (const jobj_t *)
@returns TWidget * the created widget, or null"""
        return _ida_kernwin.UI_Hooks_create_desktop_widget(self, title, cfg)

    def get_lines_rendering_info(self, out: 'lines_rendering_output_t',
        widget: 'TWidget const *', info: 'lines_rendering_input_t') ->None:
        """get lines rendering information 
          
@param out: (lines_rendering_output_t *)
@param widget: (const TWidget *)
@param info: (const lines_rendering_input_t *)
@returns void"""
        return _ida_kernwin.UI_Hooks_get_lines_rendering_info(self, out,
            widget, info)

    def get_widget_config(self, widget: 'TWidget const *', cfg: 'jobj_t *'
        ) ->'PyObject *':
        """retrieve the widget configuration (it will be passed back at ui_create_desktop_widget-, and ui_set_widget_config-time) 
          
@param widget: (const TWidget *)
@param cfg: (jobj_t *)
@returns void"""
        return _ida_kernwin.UI_Hooks_get_widget_config(self, widget, cfg)

    def set_widget_config(self, widget: 'TWidget const *', cfg:
        'jobj_wrapper_t') ->None:
        """set the widget configuration 
          
@param widget: (const TWidget *)
@param cfg: (const jobj_t *)
@returns void"""
        return _ida_kernwin.UI_Hooks_set_widget_config(self, widget, cfg)

    def initing_database(self) ->None:
        """database initialization has started. 
          
@returns void See also ui_database_inited. This event is called for both new and old databases."""
        return _ida_kernwin.UI_Hooks_initing_database(self)

    def destroying_procmod(self, procmod: 'procmod_t') ->None:
        """The processor module is about to be destroyed 
          
@param procmod: (const procmod_t *)"""
        return _ida_kernwin.UI_Hooks_destroying_procmod(self, procmod)

    def destroying_plugmod(self, plugmod: 'plugmod_t', entry:
        'plugin_t const *') ->None:
        """The plugin object is about to be destroyed 
          
@param plugmod: (const plugmod_t *)
@param entry: (const plugin_t *)"""
        return _ida_kernwin.UI_Hooks_destroying_plugmod(self, plugmod, entry)

    def desktop_applied(self, name: str, from_idb: bool, type: int) ->None:
        """a desktop has been applied 
          
@param name: (const char *) the desktop name
@param from_idb: (bool) the desktop was stored in the IDB (false if it comes from the registry)
@param type: (int) the desktop type (1-disassembly, 2-debugger, 3-merge)"""
        return _ida_kernwin.UI_Hooks_desktop_applied(self, name, from_idb, type
            )
    __swig_destroy__ = _ida_kernwin.delete_UI_Hooks

    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_UI_Hooks(self)
        return weakref.proxy(self)


_ida_kernwin.UI_Hooks_swigregister(UI_Hooks)


def register_action(desc: 'action_desc_t') ->bool:
    """Create a new action (ui_register_action). After an action has been created, it is possible to attach it to menu items (attach_action_to_menu()), or to popup menus (attach_action_to_popup()).
Because the actions will need to call the handler's activate() and update() methods at any time, you shouldn't build your action handler on the stack.
Please see the SDK's "ht_view" plugin for an example how to register actions. 
        
@param desc: action to register
@returns success"""
    return _ida_kernwin.register_action(desc)


def get_registered_actions() ->List[str]:
    """Get a list with the names of all currently-registered actions.

@return the list of action names"""
    return _ida_kernwin.get_registered_actions()


def attach_dynamic_action_to_popup(unused, popup_handle, desc, popuppath=
    None, flags=0):
    """Create & insert an action into the widget's popup menu
(::ui_attach_dynamic_action_to_popup).
Note: The action description in the 'desc' parameter is modified by
      this call so you should prepare a new description for each call.
For example:
    desc = ida_kernwin.action_desc_t(None, 'Dynamic popup action', Handler())
    ida_kernwin.attach_dynamic_action_to_popup(form, popup, desc)

@param unused:       deprecated; should be None
@param popup_handle: target popup
@param desc:         action description of type action_desc_t
@param popuppath:    can be None
@param flags:        a combination of SETMENU_ constants
@return: success"""
    return _ida_kernwin.attach_dynamic_action_to_popup(unused, popup_handle,
        desc, popuppath, flags)


class disasm_line_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _ida_kernwin.delete_disasm_line_t

    def __init__(self, *args):
        _ida_kernwin.disasm_line_t_swiginit(self, _ida_kernwin.
            new_disasm_line_t(*args))
    at: 'place_t *' = property(_ida_kernwin.disasm_line_t_at_get,
        _ida_kernwin.disasm_line_t_at_set)
    line: 'qstring' = property(_ida_kernwin.disasm_line_t_line_get,
        _ida_kernwin.disasm_line_t_line_set)
    prefix_color: 'color_t' = property(_ida_kernwin.
        disasm_line_t_prefix_color_get, _ida_kernwin.
        disasm_line_t_prefix_color_set)
    bg_color: 'bgcolor_t' = property(_ida_kernwin.
        disasm_line_t_bg_color_get, _ida_kernwin.disasm_line_t_bg_color_set)
    is_default: 'bool' = property(_ida_kernwin.disasm_line_t_is_default_get,
        _ida_kernwin.disasm_line_t_is_default_set)


_ida_kernwin.disasm_line_t_swigregister(disasm_line_t)


def py_chooser_base_t_get_row(chobj: 'chooser_base_t', n: 'size_t'
    ) ->'PyObject *':
    return _ida_kernwin.py_chooser_base_t_get_row(chobj, n)


def gen_disasm_text(text: 'disasm_text_t', ea1: ida_idaapi.ea_t, ea2:
    ida_idaapi.ea_t, truncate_lines: bool) ->None:
    """Generate disassembly text for a range. 
        
@param text: result
@param ea1: start address
@param ea2: end address
@param truncate_lines: (on idainfo::margin)"""
    return _ida_kernwin.gen_disasm_text(text, ea1, ea2, truncate_lines)


def set_nav_colorizer(callback):
    """Set a new colorizer for the navigation band.

The 'callback' is a function of 2 arguments:
   - ea (the EA to colorize for)
   - nbytes (the number of bytes at that EA)
and must return a 'long' value.

The previous colorizer is returned, allowing
the new 'callback' to use 'call_nav_colorizer'
with it.

Note that the previous colorizer is returned
only the first time set_nav_colorizer() is called:
due to the way the colorizers API is defined in C,
it is impossible to chain more than 2 colorizers
in IDAPython: the original, IDA-provided colorizer,
and a user-provided one.

Example: colorizer inverting the color provided by the IDA colorizer:
    def my_colorizer(ea, nbytes):
        global ida_colorizer
        orig = ida_kernwin.call_nav_colorizer(ida_colorizer, ea, nbytes)
        return long(~orig)

    ida_colorizer = ida_kernwin.set_nav_colorizer(my_colorizer)

@param callback: the new colorizer"""
    return _ida_kernwin.set_nav_colorizer(callback)


def call_nav_colorizer(colorizer, ea: ida_idaapi.ea_t, nbytes: int):
    """To be used with the IDA-provided colorizer, that is
returned as result of the first call to set_nav_colorizer().

@param colorizer: the Python colorizer to call
@param ea: the address to colorize
@param nbytes: the size of the range to colorize"""
    return _ida_kernwin.call_nav_colorizer(colorizer, ea, nbytes)


def msg_get_lines(count: int=-1) ->'PyObject *':
    """Retrieve the last 'count' lines from the output window, in reverse order (from most recent, to least recent) 
        
@param count: The number of lines to retrieve. -1 means: all"""
    return _ida_kernwin.msg_get_lines(count)


def TWidget__from_ptrval__(ptrval: 'size_t') ->'TWidget *':
    return _ida_kernwin.TWidget__from_ptrval__(ptrval)


MAX_SPACES_ADDED = _ida_kernwin.MAX_SPACES_ADDED


def add_spaces(s: str, len: 'size_t') ->str:
    """Add space characters to the colored string so that its length will be at least 'len' characters. Don't trim the string if it is longer than 'len'. 
        
@param len: the desired length of the string
@returns pointer to the end of input string"""
    return _ida_kernwin.add_spaces(s, len)


def show_wait_box(message: str) ->None:
    """Display a dialog box with "Please wait...". The behavior of the dialog box can be configured with well-known 
tokens, that should be placed at the start of the format string: 
 "NODELAY\\n": the dialog will show immediately, instead of 
 appearing after usual grace threshold 
 "HIDECANCEL\\n": the cancel button won't be added to the dialog box 
 and user_cancelled() will always return false (but 
 can be called to refresh UI) 
 Using "HIDECANCEL" implies "NODELAY" 
Plugins must call hide_wait_box() to close the dialog box, otherwise 
the user interface will remain disabled. 
 Note that, if the wait dialog is already visible, show_wait_box() will 
 1) push the currently-displayed text on a stack 
 2) display the new text 
Then, when hide_wait_box() is called, if that stack isn't empty its top 
label will be popped and restored in the wait dialog. 
This implies that a plugin should call hide_wait_box() exactly as many 
times as it called show_wait_box(), or the wait dialog might remain 
visible and block the UI. 
Also, in case the plugin knows the wait dialog is currently displayed, 
alternatively it can call replace_wait_box(), to replace the text of the
dialog without pushing the currently-displayed text on the stack. 
        """
    return _ida_kernwin.show_wait_box(message)


def hide_wait_box() ->None:
    """Hide the "Please wait dialog box".
"""
    return _ida_kernwin.hide_wait_box()


class line_rendering_output_entries_refs_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.line_rendering_output_entries_refs_t_swiginit(self,
            _ida_kernwin.new_line_rendering_output_entries_refs_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_line_rendering_output_entries_refs_t

    def push_back(self, *args) ->'line_rendering_output_entry_t *&':
        return _ida_kernwin.line_rendering_output_entries_refs_t_push_back(self
            , *args)

    def pop_back(self) ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_pop_back(self)

    def size(self) ->'size_t':
        return _ida_kernwin.line_rendering_output_entries_refs_t_size(self)

    def empty(self) ->bool:
        return _ida_kernwin.line_rendering_output_entries_refs_t_empty(self)

    def at(self, _idx: 'size_t') ->'line_rendering_output_entry_t *const &':
        return _ida_kernwin.line_rendering_output_entries_refs_t_at(self, _idx)

    def qclear(self) ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_qclear(self)

    def clear(self) ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_clear(self)

    def resize(self, *args) ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_resize(self,
            *args)

    def capacity(self) ->'size_t':
        return _ida_kernwin.line_rendering_output_entries_refs_t_capacity(self)

    def reserve(self, cnt: 'size_t') ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_reserve(self,
            cnt)

    def truncate(self) ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_truncate(self)

    def swap(self, r: 'line_rendering_output_entries_refs_t') ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_swap(self, r)

    def extract(self) ->'line_rendering_output_entry_t **':
        return _ida_kernwin.line_rendering_output_entries_refs_t_extract(self)

    def inject(self, s: 'line_rendering_output_entry_t **', len: 'size_t'
        ) ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_inject(self,
            s, len)

    def __eq__(self, r: 'line_rendering_output_entries_refs_t') ->bool:
        return _ida_kernwin.line_rendering_output_entries_refs_t___eq__(self, r
            )

    def __ne__(self, r: 'line_rendering_output_entries_refs_t') ->bool:
        return _ida_kernwin.line_rendering_output_entries_refs_t___ne__(self, r
            )

    def begin(self, *args
        ) ->'qvector< line_rendering_output_entry_t * >::const_iterator':
        return _ida_kernwin.line_rendering_output_entries_refs_t_begin(self,
            *args)

    def end(self, *args
        ) ->'qvector< line_rendering_output_entry_t * >::const_iterator':
        return _ida_kernwin.line_rendering_output_entries_refs_t_end(self,
            *args)

    def insert(self, it:
        'qvector< line_rendering_output_entry_t * >::iterator', x:
        'line_rendering_output_entry_t'
        ) ->'qvector< line_rendering_output_entry_t * >::iterator':
        return _ida_kernwin.line_rendering_output_entries_refs_t_insert(self,
            it, x)

    def erase(self, *args
        ) ->'qvector< line_rendering_output_entry_t * >::iterator':
        return _ida_kernwin.line_rendering_output_entries_refs_t_erase(self,
            *args)

    def find(self, *args
        ) ->'qvector< line_rendering_output_entry_t * >::const_iterator':
        return _ida_kernwin.line_rendering_output_entries_refs_t_find(self,
            *args)

    def has(self, x: 'line_rendering_output_entry_t') ->bool:
        return _ida_kernwin.line_rendering_output_entries_refs_t_has(self, x)

    def add_unique(self, x: 'line_rendering_output_entry_t') ->bool:
        return _ida_kernwin.line_rendering_output_entries_refs_t_add_unique(
            self, x)

    def _del(self, x: 'line_rendering_output_entry_t') ->bool:
        return _ida_kernwin.line_rendering_output_entries_refs_t__del(self, x)

    def __len__(self) ->'size_t':
        return _ida_kernwin.line_rendering_output_entries_refs_t___len__(self)

    def __getitem__(self, i: 'size_t'
        ) ->'line_rendering_output_entry_t *const &':
        return _ida_kernwin.line_rendering_output_entries_refs_t___getitem__(
            self, i)

    def __setitem__(self, i: 'size_t', v: 'line_rendering_output_entry_t'
        ) ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t___setitem__(
            self, i, v)

    def append(self, x: 'line_rendering_output_entry_t') ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_append(self, x
            )

    def extend(self, x: 'line_rendering_output_entries_refs_t') ->None:
        return _ida_kernwin.line_rendering_output_entries_refs_t_extend(self, x
            )
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator

    def _internal_push_back(self, e: 'line_rendering_output_entry_t') ->None:
        return (_ida_kernwin.
            line_rendering_output_entries_refs_t__internal_push_back(self, e))

    def push_back(self, e):
        if e and e.thisown:
            self._internal_push_back(e)
            e.thisown = False


_ida_kernwin.line_rendering_output_entries_refs_t_swigregister(
    line_rendering_output_entries_refs_t)


class section_lines_refs_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.section_lines_refs_t_swiginit(self, _ida_kernwin.
            new_section_lines_refs_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_section_lines_refs_t

    def push_back(self, *args) ->'twinline_t const *&':
        return _ida_kernwin.section_lines_refs_t_push_back(self, *args)

    def pop_back(self) ->None:
        return _ida_kernwin.section_lines_refs_t_pop_back(self)

    def size(self) ->'size_t':
        return _ida_kernwin.section_lines_refs_t_size(self)

    def empty(self) ->bool:
        return _ida_kernwin.section_lines_refs_t_empty(self)

    def at(self, _idx: 'size_t') ->'twinline_t const *const &':
        return _ida_kernwin.section_lines_refs_t_at(self, _idx)

    def qclear(self) ->None:
        return _ida_kernwin.section_lines_refs_t_qclear(self)

    def clear(self) ->None:
        return _ida_kernwin.section_lines_refs_t_clear(self)

    def resize(self, *args) ->None:
        return _ida_kernwin.section_lines_refs_t_resize(self, *args)

    def capacity(self) ->'size_t':
        return _ida_kernwin.section_lines_refs_t_capacity(self)

    def reserve(self, cnt: 'size_t') ->None:
        return _ida_kernwin.section_lines_refs_t_reserve(self, cnt)

    def truncate(self) ->None:
        return _ida_kernwin.section_lines_refs_t_truncate(self)

    def swap(self, r: 'section_lines_refs_t') ->None:
        return _ida_kernwin.section_lines_refs_t_swap(self, r)

    def extract(self) ->'twinline_t const **':
        return _ida_kernwin.section_lines_refs_t_extract(self)

    def inject(self, s: 'twinline_t const **', len: 'size_t') ->None:
        return _ida_kernwin.section_lines_refs_t_inject(self, s, len)

    def __eq__(self, r: 'section_lines_refs_t') ->bool:
        return _ida_kernwin.section_lines_refs_t___eq__(self, r)

    def __ne__(self, r: 'section_lines_refs_t') ->bool:
        return _ida_kernwin.section_lines_refs_t___ne__(self, r)

    def begin(self, *args) ->'qvector< twinline_t const * >::const_iterator':
        return _ida_kernwin.section_lines_refs_t_begin(self, *args)

    def end(self, *args) ->'qvector< twinline_t const * >::const_iterator':
        return _ida_kernwin.section_lines_refs_t_end(self, *args)

    def insert(self, it: 'qvector< twinline_t const * >::iterator', x:
        'twinline_t') ->'qvector< twinline_t const * >::iterator':
        return _ida_kernwin.section_lines_refs_t_insert(self, it, x)

    def erase(self, *args) ->'qvector< twinline_t const * >::iterator':
        return _ida_kernwin.section_lines_refs_t_erase(self, *args)

    def find(self, *args) ->'qvector< twinline_t const * >::const_iterator':
        return _ida_kernwin.section_lines_refs_t_find(self, *args)

    def has(self, x: 'twinline_t') ->bool:
        return _ida_kernwin.section_lines_refs_t_has(self, x)

    def add_unique(self, x: 'twinline_t') ->bool:
        return _ida_kernwin.section_lines_refs_t_add_unique(self, x)

    def _del(self, x: 'twinline_t') ->bool:
        return _ida_kernwin.section_lines_refs_t__del(self, x)

    def __len__(self) ->'size_t':
        return _ida_kernwin.section_lines_refs_t___len__(self)

    def __getitem__(self, i: 'size_t') ->'twinline_t const *const &':
        return _ida_kernwin.section_lines_refs_t___getitem__(self, i)

    def __setitem__(self, i: 'size_t', v: 'twinline_t') ->None:
        return _ida_kernwin.section_lines_refs_t___setitem__(self, i, v)

    def append(self, x: 'twinline_t') ->None:
        return _ida_kernwin.section_lines_refs_t_append(self, x)

    def extend(self, x: 'section_lines_refs_t') ->None:
        return _ida_kernwin.section_lines_refs_t_extend(self, x)
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


_ida_kernwin.section_lines_refs_t_swigregister(section_lines_refs_t)


class sections_lines_refs_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.sections_lines_refs_t_swiginit(self, _ida_kernwin.
            new_sections_lines_refs_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_sections_lines_refs_t

    def push_back(self, *args) ->'section_lines_refs_t &':
        return _ida_kernwin.sections_lines_refs_t_push_back(self, *args)

    def pop_back(self) ->None:
        return _ida_kernwin.sections_lines_refs_t_pop_back(self)

    def size(self) ->'size_t':
        return _ida_kernwin.sections_lines_refs_t_size(self)

    def empty(self) ->bool:
        return _ida_kernwin.sections_lines_refs_t_empty(self)

    def at(self, _idx: 'size_t') ->'section_lines_refs_t const &':
        return _ida_kernwin.sections_lines_refs_t_at(self, _idx)

    def qclear(self) ->None:
        return _ida_kernwin.sections_lines_refs_t_qclear(self)

    def clear(self) ->None:
        return _ida_kernwin.sections_lines_refs_t_clear(self)

    def resize(self, *args) ->None:
        return _ida_kernwin.sections_lines_refs_t_resize(self, *args)

    def grow(self, *args) ->None:
        return _ida_kernwin.sections_lines_refs_t_grow(self, *args)

    def capacity(self) ->'size_t':
        return _ida_kernwin.sections_lines_refs_t_capacity(self)

    def reserve(self, cnt: 'size_t') ->None:
        return _ida_kernwin.sections_lines_refs_t_reserve(self, cnt)

    def truncate(self) ->None:
        return _ida_kernwin.sections_lines_refs_t_truncate(self)

    def swap(self, r: 'sections_lines_refs_t') ->None:
        return _ida_kernwin.sections_lines_refs_t_swap(self, r)

    def extract(self) ->'section_lines_refs_t *':
        return _ida_kernwin.sections_lines_refs_t_extract(self)

    def inject(self, s: 'section_lines_refs_t', len: 'size_t') ->None:
        return _ida_kernwin.sections_lines_refs_t_inject(self, s, len)

    def __eq__(self, r: 'sections_lines_refs_t') ->bool:
        return _ida_kernwin.sections_lines_refs_t___eq__(self, r)

    def __ne__(self, r: 'sections_lines_refs_t') ->bool:
        return _ida_kernwin.sections_lines_refs_t___ne__(self, r)

    def begin(self, *args) ->'qvector< section_lines_refs_t >::const_iterator':
        return _ida_kernwin.sections_lines_refs_t_begin(self, *args)

    def end(self, *args) ->'qvector< section_lines_refs_t >::const_iterator':
        return _ida_kernwin.sections_lines_refs_t_end(self, *args)

    def insert(self, it: 'qvector< section_lines_refs_t >::iterator', x:
        'section_lines_refs_t') ->'qvector< section_lines_refs_t >::iterator':
        return _ida_kernwin.sections_lines_refs_t_insert(self, it, x)

    def erase(self, *args) ->'qvector< section_lines_refs_t >::iterator':
        return _ida_kernwin.sections_lines_refs_t_erase(self, *args)

    def find(self, *args) ->'qvector< section_lines_refs_t >::const_iterator':
        return _ida_kernwin.sections_lines_refs_t_find(self, *args)

    def has(self, x: 'section_lines_refs_t') ->bool:
        return _ida_kernwin.sections_lines_refs_t_has(self, x)

    def add_unique(self, x: 'section_lines_refs_t') ->bool:
        return _ida_kernwin.sections_lines_refs_t_add_unique(self, x)

    def _del(self, x: 'section_lines_refs_t') ->bool:
        return _ida_kernwin.sections_lines_refs_t__del(self, x)

    def __len__(self) ->'size_t':
        return _ida_kernwin.sections_lines_refs_t___len__(self)

    def __getitem__(self, i: 'size_t') ->'section_lines_refs_t const &':
        return _ida_kernwin.sections_lines_refs_t___getitem__(self, i)

    def __setitem__(self, i: 'size_t', v: 'section_lines_refs_t') ->None:
        return _ida_kernwin.sections_lines_refs_t___setitem__(self, i, v)

    def append(self, x: 'section_lines_refs_t') ->None:
        return _ida_kernwin.sections_lines_refs_t_append(self, x)

    def extend(self, x: 'sections_lines_refs_t') ->None:
        return _ida_kernwin.sections_lines_refs_t_extend(self, x)
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


_ida_kernwin.sections_lines_refs_t_swigregister(sections_lines_refs_t)


class text_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.text_t_swiginit(self, _ida_kernwin.new_text_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_text_t

    def push_back(self, *args) ->'twinline_t &':
        return _ida_kernwin.text_t_push_back(self, *args)

    def pop_back(self) ->None:
        return _ida_kernwin.text_t_pop_back(self)

    def size(self) ->'size_t':
        return _ida_kernwin.text_t_size(self)

    def empty(self) ->bool:
        return _ida_kernwin.text_t_empty(self)

    def at(self, _idx: 'size_t') ->'twinline_t const &':
        return _ida_kernwin.text_t_at(self, _idx)

    def qclear(self) ->None:
        return _ida_kernwin.text_t_qclear(self)

    def clear(self) ->None:
        return _ida_kernwin.text_t_clear(self)

    def resize(self, *args) ->None:
        return _ida_kernwin.text_t_resize(self, *args)

    def grow(self, *args) ->None:
        return _ida_kernwin.text_t_grow(self, *args)

    def capacity(self) ->'size_t':
        return _ida_kernwin.text_t_capacity(self)

    def reserve(self, cnt: 'size_t') ->None:
        return _ida_kernwin.text_t_reserve(self, cnt)

    def truncate(self) ->None:
        return _ida_kernwin.text_t_truncate(self)

    def swap(self, r: 'text_t') ->None:
        return _ida_kernwin.text_t_swap(self, r)

    def extract(self) ->'twinline_t *':
        return _ida_kernwin.text_t_extract(self)

    def inject(self, s: 'twinline_t', len: 'size_t') ->None:
        return _ida_kernwin.text_t_inject(self, s, len)

    def begin(self, *args) ->'qvector< twinline_t >::const_iterator':
        return _ida_kernwin.text_t_begin(self, *args)

    def end(self, *args) ->'qvector< twinline_t >::const_iterator':
        return _ida_kernwin.text_t_end(self, *args)

    def insert(self, it: 'twinline_t', x: 'twinline_t'
        ) ->'qvector< twinline_t >::iterator':
        return _ida_kernwin.text_t_insert(self, it, x)

    def erase(self, *args) ->'qvector< twinline_t >::iterator':
        return _ida_kernwin.text_t_erase(self, *args)

    def __len__(self) ->'size_t':
        return _ida_kernwin.text_t___len__(self)

    def __getitem__(self, i: 'size_t') ->'twinline_t const &':
        return _ida_kernwin.text_t___getitem__(self, i)

    def __setitem__(self, i: 'size_t', v: 'twinline_t') ->None:
        return _ida_kernwin.text_t___setitem__(self, i, v)

    def append(self, x: 'twinline_t') ->None:
        return _ida_kernwin.text_t_append(self, x)

    def extend(self, x: 'text_t') ->None:
        return _ida_kernwin.text_t_extend(self, x)
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


_ida_kernwin.text_t_swigregister(text_t)


class sync_source_vec_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.sync_source_vec_t_swiginit(self, _ida_kernwin.
            new_sync_source_vec_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_sync_source_vec_t

    def push_back(self, x: 'sync_source_t') ->None:
        return _ida_kernwin.sync_source_vec_t_push_back(self, x)

    def pop_back(self) ->None:
        return _ida_kernwin.sync_source_vec_t_pop_back(self)

    def size(self) ->'size_t':
        return _ida_kernwin.sync_source_vec_t_size(self)

    def empty(self) ->bool:
        return _ida_kernwin.sync_source_vec_t_empty(self)

    def at(self, _idx: 'size_t') ->'sync_source_t const &':
        return _ida_kernwin.sync_source_vec_t_at(self, _idx)

    def qclear(self) ->None:
        return _ida_kernwin.sync_source_vec_t_qclear(self)

    def clear(self) ->None:
        return _ida_kernwin.sync_source_vec_t_clear(self)

    def capacity(self) ->'size_t':
        return _ida_kernwin.sync_source_vec_t_capacity(self)

    def reserve(self, cnt: 'size_t') ->None:
        return _ida_kernwin.sync_source_vec_t_reserve(self, cnt)

    def truncate(self) ->None:
        return _ida_kernwin.sync_source_vec_t_truncate(self)

    def swap(self, r: 'sync_source_vec_t') ->None:
        return _ida_kernwin.sync_source_vec_t_swap(self, r)

    def extract(self) ->'sync_source_t *':
        return _ida_kernwin.sync_source_vec_t_extract(self)

    def inject(self, s: 'sync_source_t', len: 'size_t') ->None:
        return _ida_kernwin.sync_source_vec_t_inject(self, s, len)

    def __eq__(self, r: 'sync_source_vec_t') ->bool:
        return _ida_kernwin.sync_source_vec_t___eq__(self, r)

    def __ne__(self, r: 'sync_source_vec_t') ->bool:
        return _ida_kernwin.sync_source_vec_t___ne__(self, r)

    def begin(self, *args) ->'qvector< sync_source_t >::const_iterator':
        return _ida_kernwin.sync_source_vec_t_begin(self, *args)

    def end(self, *args) ->'qvector< sync_source_t >::const_iterator':
        return _ida_kernwin.sync_source_vec_t_end(self, *args)

    def insert(self, it: 'sync_source_t', x: 'sync_source_t'
        ) ->'qvector< sync_source_t >::iterator':
        return _ida_kernwin.sync_source_vec_t_insert(self, it, x)

    def erase(self, *args) ->'qvector< sync_source_t >::iterator':
        return _ida_kernwin.sync_source_vec_t_erase(self, *args)

    def find(self, *args) ->'qvector< sync_source_t >::const_iterator':
        return _ida_kernwin.sync_source_vec_t_find(self, *args)

    def has(self, x: 'sync_source_t') ->bool:
        return _ida_kernwin.sync_source_vec_t_has(self, x)

    def add_unique(self, x: 'sync_source_t') ->bool:
        return _ida_kernwin.sync_source_vec_t_add_unique(self, x)

    def _del(self, x: 'sync_source_t') ->bool:
        return _ida_kernwin.sync_source_vec_t__del(self, x)

    def __len__(self) ->'size_t':
        return _ida_kernwin.sync_source_vec_t___len__(self)

    def __getitem__(self, i: 'size_t') ->'sync_source_t const &':
        return _ida_kernwin.sync_source_vec_t___getitem__(self, i)

    def __setitem__(self, i: 'size_t', v: 'sync_source_t') ->None:
        return _ida_kernwin.sync_source_vec_t___setitem__(self, i, v)

    def append(self, x: 'sync_source_t') ->None:
        return _ida_kernwin.sync_source_vec_t_append(self, x)

    def extend(self, x: 'sync_source_vec_t') ->None:
        return _ida_kernwin.sync_source_vec_t_extend(self, x)
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


_ida_kernwin.sync_source_vec_t_swigregister(sync_source_vec_t)
mbox_internal = _ida_kernwin.mbox_internal
"""internal error
"""
mbox_info = _ida_kernwin.mbox_info
mbox_warning = _ida_kernwin.mbox_warning
mbox_error = _ida_kernwin.mbox_error
mbox_nomem = _ida_kernwin.mbox_nomem
mbox_feedback = _ida_kernwin.mbox_feedback
mbox_readerror = _ida_kernwin.mbox_readerror
mbox_writeerror = _ida_kernwin.mbox_writeerror
mbox_filestruct = _ida_kernwin.mbox_filestruct
mbox_wait = _ida_kernwin.mbox_wait
mbox_hide = _ida_kernwin.mbox_hide
mbox_replace = _ida_kernwin.mbox_replace
chtype_generic = _ida_kernwin.chtype_generic
"""the generic choose() function
"""
chtype_idasgn = _ida_kernwin.chtype_idasgn
"""see choose_idasgn()
"""
chtype_entry = _ida_kernwin.chtype_entry
"""see choose_entry()
"""
chtype_name = _ida_kernwin.chtype_name
"""see choose_name()
"""
chtype_stkvar_xref = _ida_kernwin.chtype_stkvar_xref
"""see choose_stkvar_xref()
"""
chtype_xref = _ida_kernwin.chtype_xref
"""see choose_xref()
"""
chtype_func = _ida_kernwin.chtype_func
"""see choose_func()
"""
chtype_segm = _ida_kernwin.chtype_segm
"""see choose_segm()
"""
chtype_strpath = _ida_kernwin.chtype_strpath
"""see choose_struc_path()
"""
chtype_idatil = _ida_kernwin.chtype_idatil
"""see choose_til()
"""
chtype_srcp = _ida_kernwin.chtype_srcp
"""see choose_srcp()
"""
chtype_struct = _ida_kernwin.chtype_struct
"""see choose_struct()
"""
chtype_enum = _ida_kernwin.chtype_enum
"""see choose_enum()
"""
chtype_enum_by_value_and_size = _ida_kernwin.chtype_enum_by_value_and_size
"""see choose_enum_by_value()
"""
beep_default = _ida_kernwin.beep_default
TCCRT_INVALID = _ida_kernwin.TCCRT_INVALID
"""invalid
"""
TCCRT_FLAT = _ida_kernwin.TCCRT_FLAT
"""flat view
"""
TCCRT_GRAPH = _ida_kernwin.TCCRT_GRAPH
"""graph view
"""
TCCRT_PROXIMITY = _ida_kernwin.TCCRT_PROXIMITY
"""proximity view
"""
TCCPT_INVALID = _ida_kernwin.TCCPT_INVALID
"""invalid
"""
TCCPT_PLACE = _ida_kernwin.TCCPT_PLACE
"""place_t
"""
TCCPT_SIMPLELINE_PLACE = _ida_kernwin.TCCPT_SIMPLELINE_PLACE
"""simpleline_place_t
"""
TCCPT_IDAPLACE = _ida_kernwin.TCCPT_IDAPLACE
"""idaplace_t
"""
TCCPT_TIPLACE = _ida_kernwin.TCCPT_TIPLACE
"""tiplace_t
"""
VME_UNKNOWN = _ida_kernwin.VME_UNKNOWN
"""unknown mouse button
"""
VME_LEFT_BUTTON = _ida_kernwin.VME_LEFT_BUTTON
"""left mouse button
"""
VME_RIGHT_BUTTON = _ida_kernwin.VME_RIGHT_BUTTON
"""right mouse button
"""
VME_MID_BUTTON = _ida_kernwin.VME_MID_BUTTON
"""middle mouse button
"""
SETMENU_POSMASK = _ida_kernwin.SETMENU_POSMASK
SETMENU_INS = _ida_kernwin.SETMENU_INS
"""add menu item before the specified path (default)
"""
SETMENU_APP = _ida_kernwin.SETMENU_APP
"""add menu item after the specified path
"""
SETMENU_FIRST = _ida_kernwin.SETMENU_FIRST
"""add item to the beginning of menu
"""
SETMENU_ENSURE_SEP = _ida_kernwin.SETMENU_ENSURE_SEP
"""make sure there is a separator before the action
"""
CREATETB_ADV = _ida_kernwin.CREATETB_ADV
"""toolbar is for 'advanced mode' only
"""
HIF_IDENTIFIER = _ida_kernwin.HIF_IDENTIFIER
"""text is an identifier (i.e., when searching for the current highlight, SEARCH_IDENT will be used)
"""
HIF_REGISTER = _ida_kernwin.HIF_REGISTER
"""text represents a register (aliases/subregisters will be highlit as well)
"""
HIF_LOCKED = _ida_kernwin.HIF_LOCKED
"""locked; clicking/moving the cursor around doesn't change the highlight
"""
HIF_NOCASE = _ida_kernwin.HIF_NOCASE
"""case insensitive
"""
HIF_USE_SLOT = _ida_kernwin.HIF_USE_SLOT
"""use the given number, or just use the "floating" highlight
"""
HIF_SLOT_SHIFT = _ida_kernwin.HIF_SLOT_SHIFT
"""position of the 3 top bits specifying which highlight to use
"""
HIF_SLOT_0 = _ida_kernwin.HIF_SLOT_0
"""operate on slot 0
"""
HIF_SLOT_1 = _ida_kernwin.HIF_SLOT_1
"""operate on slot 1
"""
HIF_SLOT_2 = _ida_kernwin.HIF_SLOT_2
"""operate on slot 2
"""
HIF_SLOT_3 = _ida_kernwin.HIF_SLOT_3
"""operate on slot 3
"""
HIF_SLOT_4 = _ida_kernwin.HIF_SLOT_4
"""operate on slot 4
"""
HIF_SLOT_5 = _ida_kernwin.HIF_SLOT_5
"""operate on slot 5
"""
HIF_SLOT_6 = _ida_kernwin.HIF_SLOT_6
"""operate on slot 6
"""
HIF_SLOT_7 = _ida_kernwin.HIF_SLOT_7
"""operate on slot 7
"""
REG_HINTS_MARKER = _ida_kernwin.REG_HINTS_MARKER
REG_HINTS_MARKER_LEN = _ida_kernwin.REG_HINTS_MARKER_LEN
SRCDBG_HINTS_MARKER = _ida_kernwin.SRCDBG_HINTS_MARKER
SRCDBG_HINTS_MARKER_LEN = _ida_kernwin.SRCDBG_HINTS_MARKER_LEN
CDVF_NOLINES = _ida_kernwin.CDVF_NOLINES
"""don't show line numbers
"""
CDVF_LINEICONS = _ida_kernwin.CDVF_LINEICONS
"""icons can be drawn over the line control
"""
CDVF_STATUSBAR = _ida_kernwin.CDVF_STATUSBAR
"""keep the status bar in the custom viewer
"""
IDCHK_OK = _ida_kernwin.IDCHK_OK
"""ok
"""
IDCHK_ARG = _ida_kernwin.IDCHK_ARG
"""bad argument(s)
"""
IDCHK_KEY = _ida_kernwin.IDCHK_KEY
"""bad hotkey name
"""
IDCHK_MAX = _ida_kernwin.IDCHK_MAX
"""too many IDC hotkeys
"""
WCLS_SAVE = _ida_kernwin.WCLS_SAVE
"""save state in desktop config
"""
WCLS_NO_CONTEXT = _ida_kernwin.WCLS_NO_CONTEXT
"""don't change the current context (useful for toolbars)
"""
WCLS_DONT_SAVE_SIZE = _ida_kernwin.WCLS_DONT_SAVE_SIZE
"""don't save size of the window
"""
WCLS_DELETE_LATER = _ida_kernwin.WCLS_DELETE_LATER
"""assign the deletion of the widget to the UI loop ///<
"""
WCLS_CLOSE_LATER = _ida_kernwin.WCLS_CLOSE_LATER
DP_LEFT = _ida_kernwin.DP_LEFT
"""Dock src_form to the left of dest_form.
"""
DP_TOP = _ida_kernwin.DP_TOP
"""Dock src_form above dest_form.
"""
DP_RIGHT = _ida_kernwin.DP_RIGHT
"""Dock src_form to the right of dest_form.
"""
DP_BOTTOM = _ida_kernwin.DP_BOTTOM
"""Dock src_form below dest_form.
"""
DP_INSIDE = _ida_kernwin.DP_INSIDE
"""Create a new tab bar with both src_form and dest_form.
"""
DP_TAB = _ida_kernwin.DP_TAB
"""Place src_form into a tab next to dest_form, if dest_form is in a tab bar (otherwise the same as DP_INSIDE) 
        """
DP_BEFORE = _ida_kernwin.DP_BEFORE
"""Place src_form before dst_form in the tab bar instead of after; used with DP_INSIDE or DP_TAB. 
        """
DP_FLOATING = _ida_kernwin.DP_FLOATING
"""Make src_form floating.
"""
DP_SZHINT = _ida_kernwin.DP_SZHINT
"""When floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
        """
SVF_COPY_LINES = _ida_kernwin.SVF_COPY_LINES
"""keep a local copy of '*lines'
"""
SVF_LINES_BYPTR = _ida_kernwin.SVF_LINES_BYPTR
"""remember the 'lines' ptr. do not make a copy of '*lines'
"""
CVNF_LAZY = _ida_kernwin.CVNF_LAZY
"""try and move the cursor to a line displaying the place_t if possible. This might disregard the Y position in case of success 
        """
CVNF_JUMP = _ida_kernwin.CVNF_JUMP
"""push the current position in this viewer's lochist_t before going to the new location 
        """
CVNF_ACT = _ida_kernwin.CVNF_ACT
"""activate (i.e., switch to) the viewer. Activation is performed before the new lochist_entry_t instance is actually copied to the viewer's lochist_t (otherwise, if the viewer was invisible its on_location_changed() handler wouldn't be called.) 
        """
WOPN_RESTORE = _ida_kernwin.WOPN_RESTORE
"""if the widget was the only widget in a floating area the last time it was closed, it will be restored as floating, with the same position+size as before 
        """
WOPN_PERSIST = _ida_kernwin.WOPN_PERSIST
"""widget will remain available when starting or stopping debugger sessions
"""
WOPN_CLOSED_BY_ESC = _ida_kernwin.WOPN_CLOSED_BY_ESC
"""override idagui.cfg:CLOSED_BY_ESC: esc will close
"""
WOPN_NOT_CLOSED_BY_ESC = _ida_kernwin.WOPN_NOT_CLOSED_BY_ESC
"""override idagui.cfg:CLOSED_BY_ESC: esc will not close
"""
WOPN_DP_MASK = _ida_kernwin.WOPN_DP_MASK
WOPN_DP_SHIFT = _ida_kernwin.WOPN_DP_SHIFT
WOPN_DP_LEFT = _ida_kernwin.WOPN_DP_LEFT
"""Dock widget to the left of dest_ctrl.
"""
WOPN_DP_TOP = _ida_kernwin.WOPN_DP_TOP
"""Dock widget above dest_ctrl.
"""
WOPN_DP_RIGHT = _ida_kernwin.WOPN_DP_RIGHT
"""Dock widget to the right of dest_ctrl.
"""
WOPN_DP_BOTTOM = _ida_kernwin.WOPN_DP_BOTTOM
"""Dock widget below dest_ctrl.
"""
WOPN_DP_INSIDE = _ida_kernwin.WOPN_DP_INSIDE
"""Create a new tab bar with both widget and dest_ctrl.
"""
WOPN_DP_TAB = _ida_kernwin.WOPN_DP_TAB
"""Place widget into a tab next to dest_ctrl, if dest_ctrl is in a tab bar (otherwise the same as WOPN_DP_INSIDE) 
        """
WOPN_DP_BEFORE = _ida_kernwin.WOPN_DP_BEFORE
"""Place widget before dst_form in the tab bar instead of after; used with WOPN_DP_INSIDE and WOPN_DP_TAB 
        """
WOPN_DP_FLOATING = _ida_kernwin.WOPN_DP_FLOATING
"""Make widget floating.
"""
WOPN_DP_SZHINT = _ida_kernwin.WOPN_DP_SZHINT
"""when floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
        """
WOPN_DP_INSIDE_BEFORE = _ida_kernwin.WOPN_DP_INSIDE_BEFORE
WOPN_DP_TAB_BEFORE = _ida_kernwin.WOPN_DP_TAB_BEFORE
RENADDR_IDA = _ida_kernwin.RENADDR_IDA
"""dialog for "IDA View\"
"""
RENADDR_HR = _ida_kernwin.RENADDR_HR
"""dialog for "Pseudocode"; additional flags:
* 0x01 Library function
* 0x02 Mark as decompiled 


        """
CVLF_USE_MOUSE = _ida_kernwin.CVLF_USE_MOUSE
"""Fetch the location from the mouse, instead of caret in the listing.
"""


def get_kernel_version() ->str:
    """Get IDA kernel version (in a string like "5.1").
"""
    return _ida_kernwin.get_kernel_version()


def is_ida_library(path: 'char *', pathsize: 'size_t', handle: 'void **'
    ) ->bool:
    return _ida_kernwin.is_ida_library(path, pathsize, handle)


class place_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    lnnum: 'int' = property(_ida_kernwin.place_t_lnnum_get, _ida_kernwin.
        place_t_lnnum_set)
    """Number of line within the current object.
"""

    def _print(self, ud: 'void *') ->None:
        return _ida_kernwin.place_t__print(self, ud)

    def touval(self, ud: 'void *') ->int:
        """Map the location to a number. This mapping is used to draw the vertical scrollbar. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t"""
        return _ida_kernwin.place_t_touval(self, ud)

    def clone(self) ->'place_t *':
        """Clone the location. 
        
@returns a pointer to a copy of the current location in dynamic memory"""
        return _ida_kernwin.place_t_clone(self)

    def copyfrom(self, _from: 'place_t') ->None:
        """Copy the specified location object to the current object.
"""
        return _ida_kernwin.place_t_copyfrom(self, _from)

    def makeplace(self, ud: 'void *', x: int, lnnum: int) ->'place_t *':
        """Map a number to a location. When the user clicks on the scrollbar and drags it, we need to determine the location corresponding to the new scrollbar position. This function is used to determine it. It builds a location object for the specified 'x' and returns a pointer to it. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@param x: number to map
@param lnnum: line number to initialize 'lnnum'
@returns a freshly allocated object. See also PCF_MAKEPLACE_ALLOCATES"""
        return _ida_kernwin.place_t_makeplace(self, ud, x, lnnum)

    def compare(self, t2: 'place_t') ->int:
        """Deprecated. Please consider compare2(const place_t *, void *) instead.
"""
        return _ida_kernwin.place_t_compare(self, t2)

    def adjust(self, ud: 'void *') ->None:
        """Adjust the current location to point to a displayable object. This function validates the location and makes sure that it points to an existing object. For example, if the location points to the middle of an instruction, it will be adjusted to point to the beginning of the instruction. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t"""
        return _ida_kernwin.place_t_adjust(self, ud)

    def prev(self, ud: 'void *') ->bool:
        """Move to the previous displayable location. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@returns success"""
        return _ida_kernwin.place_t_prev(self, ud)

    def next(self, ud: 'void *') ->bool:
        """Move to the next displayable location. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@returns success"""
        return _ida_kernwin.place_t_next(self, ud)

    def beginning(self, ud: 'void *') ->bool:
        """Are we at the first displayable object?. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@returns true if the current location points to the first displayable object"""
        return _ida_kernwin.place_t_beginning(self, ud)

    def ending(self, ud: 'void *') ->bool:
        """Are we at the last displayable object?. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@returns true if the current location points to the last displayable object"""
        return _ida_kernwin.place_t_ending(self, ud)

    def serialize(self) ->None:
        """Serialize this instance. It is fundamental that all instances of a particular subclass of of place_t occupy the same number of bytes when serialized. 
        """
        return _ida_kernwin.place_t_serialize(self)

    def id(self) ->int:
        """Get the place's ID (i.e., the value returned by register_place_class()) 
        
@returns the id"""
        return _ida_kernwin.place_t_id(self)

    def name(self) ->str:
        """Get this place type name. All instances of a given class must return the same string. 
        
@returns the place type name. Please try and pick something that is not too generic, as it might clash w/ other plugins. A good practice is to prefix the class name with the name of your plugin. E.g., "myplugin:srcplace_t"."""
        return _ida_kernwin.place_t_name(self)

    def toea(self) ->ida_idaapi.ea_t:
        """Map the location to an ea_t. 
        
@returns the corresponding ea_t, or BADADDR;"""
        return _ida_kernwin.place_t_toea(self)

    def rebase(self, arg2: 'segm_move_infos_t const &') ->bool:
        """Rebase the place instance 
        
@returns true if place was rebased, false otherwise"""
        return _ida_kernwin.place_t_rebase(self, arg2)

    def enter(self, arg2: 'uint32 *') ->'place_t *':
        """Visit this place, possibly 'unhiding' a section of text. If entering that place required some expanding, a place_t should be returned that represents that section, plus some flags for later use by 'leave()'. 
        
@returns a place_t corresponding to the beginning of the section of text that had to be expanded. That place_t's leave() will be called with the flags contained in 'out_flags' when the user navigates away from it."""
        return _ida_kernwin.place_t_enter(self, arg2)

    def leave(self, arg2: int) ->None:
        """Leave this place, possibly 'hiding' a section of text that was previously expanded (at enter()-time.) 
        """
        return _ida_kernwin.place_t_leave(self, arg2)

    def compare2(self, t2: 'place_t', arg3: 'void *') ->int:
        """Compare two locations except line numbers (lnnum). This function is used to organize loops. For example, if the user has selected an range, its boundaries are remembered as location objects. Any operation within the selection will have the following look: for ( loc=starting_location; loc < ending_location; loc.next() ) In this loop, the comparison function is used. 
        
@param t2: the place to compare this one to.
@retval -1: if the current location is less than 't2'
@retval 0: if the current location is equal to than 't2'
@retval 1: if the current location is greater than 't2'"""
        return _ida_kernwin.place_t_compare2(self, t2, arg3)

    def deserialize(self, _in: 'bytevec_t const &') ->bool:
        """De-serialize into this instance. 'pptr' should be incremented by as many bytes as de-serialization consumed. 
        
@returns whether de-serialization was successful"""
        return _ida_kernwin.place_t_deserialize(self, _in)

    @staticmethod
    def as_idaplace_t(p: 'place_t') ->'idaplace_t *':
        return _ida_kernwin.place_t_as_idaplace_t(p)

    @staticmethod
    def as_simpleline_place_t(p: 'place_t') ->'simpleline_place_t *':
        return _ida_kernwin.place_t_as_simpleline_place_t(p)

    @staticmethod
    def as_tiplace_t(p: 'place_t') ->'tiplace_t *':
        return _ida_kernwin.place_t_as_tiplace_t(p)

    def generate(self, ud, maxsize: int) ->Tuple[List[str], int, int, int]:
        """Generate text lines for the current location.

@param ud The user data object
@param maxsize The maximum number of lines to generate
@return a tuple (lines-of-text, default-line-number, prefix-color, background-color)"""
        return _ida_kernwin.place_t_generate(self, ud, maxsize)


_ida_kernwin.place_t_swigregister(place_t)
cvar = _ida_kernwin.cvar
IDALIB_API_MAGIC = cvar.IDALIB_API_MAGIC
DEFAULT_PLACE_LNNUM = _ida_kernwin.DEFAULT_PLACE_LNNUM


def l_compare2(t1: 'place_t', t2: 'place_t', ud: 'void *') ->int:
    return _ida_kernwin.l_compare2(t1, t2, ud)


class simpleline_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    line: 'qstring' = property(_ida_kernwin.simpleline_t_line_get,
        _ida_kernwin.simpleline_t_line_set)
    """line text
"""
    color: 'color_t' = property(_ida_kernwin.simpleline_t_color_get,
        _ida_kernwin.simpleline_t_color_set)
    """line prefix color
"""
    bgcolor: 'bgcolor_t' = property(_ida_kernwin.simpleline_t_bgcolor_get,
        _ida_kernwin.simpleline_t_bgcolor_set)
    """line background color
"""

    def __init__(self, *args):
        _ida_kernwin.simpleline_t_swiginit(self, _ida_kernwin.
            new_simpleline_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_simpleline_t


_ida_kernwin.simpleline_t_swigregister(simpleline_t)


class simpleline_place_t(place_t):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    n: 'uint32' = property(_ida_kernwin.simpleline_place_t_n_get,
        _ida_kernwin.simpleline_place_t_n_set)
    """line number
"""


_ida_kernwin.simpleline_place_t_swigregister(simpleline_place_t)


class idaplace_t(place_t):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    ea: 'ea_t' = property(_ida_kernwin.idaplace_t_ea_get, _ida_kernwin.
        idaplace_t_ea_set)
    """address
"""


_ida_kernwin.idaplace_t_swigregister(idaplace_t)


def is_tif_cursor_header(c: 'tif_cursor_t') ->bool:
    return _ida_kernwin.is_tif_cursor_header(c)


def is_tif_cursor_footer(c: 'tif_cursor_t') ->bool:
    return _ida_kernwin.is_tif_cursor_footer(c)


def is_tif_cursor_index(c: 'tif_cursor_t') ->bool:
    return _ida_kernwin.is_tif_cursor_index(c)


class tiplace_t(place_t):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    ordinal: 'uint32' = property(_ida_kernwin.tiplace_t_ordinal_get,
        _ida_kernwin.tiplace_t_ordinal_set)
    cursor: 'tif_cursor_t' = property(_ida_kernwin.tiplace_t_cursor_get,
        _ida_kernwin.tiplace_t_cursor_set)

    def valid_ord(self) ->bool:
        return _ida_kernwin.tiplace_t_valid_ord(self)

    def reset(self) ->None:
        return _ida_kernwin.tiplace_t_reset(self)

    def is_header(self) ->bool:
        return _ida_kernwin.tiplace_t_is_header(self)

    def is_footer(self) ->bool:
        return _ida_kernwin.tiplace_t_is_footer(self)

    def is_index(self) ->bool:
        return _ida_kernwin.tiplace_t_is_index(self)

    def set_header(self) ->None:
        return _ida_kernwin.tiplace_t_set_header(self)

    def set_footer(self) ->None:
        return _ida_kernwin.tiplace_t_set_footer(self)

    def calc_udm_offset(self, ud: 'void const *', p_udmidx: 'ssize_t *'=
        None, p_bitoff: 'int *'=None) ->'uint64':
        """for structs: calculate the offset that corresponds to the tiplace. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@param p_udmidx: place to return the index of the current udt member, if any. if there is no member at the current offset, return -1
@param p_bitoff: place to return the bit offset of the item from the beginning of the bit bucket if there no bitfields, return -1
@returns the current offset or uint64(-1)"""
        return _ida_kernwin.tiplace_t_calc_udm_offset(self, ud, p_udmidx,
            p_bitoff)

    def set_index_by_offset(self, ud: 'void *', offset: 'uint64') ->None:
        """for structs: calculate the index that corresponds to the offset and set it. 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@param offset: offset of udt member"""
        return _ida_kernwin.tiplace_t_set_index_by_offset(self, ud, offset)

    def get_kind(self, ud: 'void const *') ->'type_t':
        """get the kind of type this place represents 
        
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@returns one of BTF_TYPEDEF, BTF_STRUCT, BTF_UNION, BTF_ENUM or BT_UNK"""
        return _ida_kernwin.tiplace_t_get_kind(self, ud)

    def fill_type_ref(self, out: 'til_type_ref_t', ud: 'void const *') ->bool:
        """fill the type information for use in actions 
        
@param out: pointer to storage
@param ud: pointer to user-defined context data. Is supplied by linearray_t
@returns success"""
        return _ida_kernwin.tiplace_t_fill_type_ref(self, out, ud)


_ida_kernwin.tiplace_t_swigregister(tiplace_t)
PCF_EA_CAPABLE = _ida_kernwin.PCF_EA_CAPABLE
"""toea() implementation returns meaningful data
"""
PCF_MAKEPLACE_ALLOCATES = _ida_kernwin.PCF_MAKEPLACE_ALLOCATES
"""makeplace() returns a freshly allocated (i.e., non-static) instance. All new code should pass that flag to register_place_class(), and the corresponding makeplace() class implementation should return new instances. 
        """


def internal_register_place_class(tmplate: 'place_t', flags: int, owner:
    'plugin_t const *', sdk_version: int) ->int:
    return _ida_kernwin.internal_register_place_class(tmplate, flags, owner,
        sdk_version)


def get_place_class(out_flags: 'int *', out_sdk_version: 'int *', id: int
    ) ->'place_t const *':
    """Get information about a previously-registered place_t class. See also register_place_class(). 
        
@param out_flags: output flags (can be nullptr)
@param out_sdk_version: sdk version the place was created with (can be nullptr)
@param id: place class ID
@returns the place_t template, or nullptr if not found"""
    return _ida_kernwin.get_place_class(out_flags, out_sdk_version, id)


def get_place_class_template(id: int) ->'place_t const *':
    """See get_place_class()
"""
    return _ida_kernwin.get_place_class_template(id)


def is_place_class_ea_capable(id: int) ->bool:
    """See get_place_class()
"""
    return _ida_kernwin.is_place_class_ea_capable(id)


def get_place_class_id(name: str) ->int:
    """Get the place class ID for the place that has been registered as 'name'. 
        
@param name: the class name
@returns the place class ID, or -1 if not found"""
    return _ida_kernwin.get_place_class_id(name)


class sync_source_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.sync_source_t_swiginit(self, _ida_kernwin.
            new_sync_source_t(*args))

    def __eq__(self, _o: 'sync_source_t') ->bool:
        return _ida_kernwin.sync_source_t___eq__(self, _o)

    def __ne__(self, _o: 'sync_source_t') ->bool:
        return _ida_kernwin.sync_source_t___ne__(self, _o)

    def is_register(self) ->bool:
        return _ida_kernwin.sync_source_t_is_register(self)

    def is_widget(self) ->bool:
        return _ida_kernwin.sync_source_t_is_widget(self)

    def get_widget(self) ->'TWidget const *':
        return _ida_kernwin.sync_source_t_get_widget(self)

    def get_register(self) ->str:
        return _ida_kernwin.sync_source_t_get_register(self)
    __swig_destroy__ = _ida_kernwin.delete_sync_source_t


_ida_kernwin.sync_source_t_swigregister(sync_source_t)


class synced_group_t(sync_source_vec_t):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def has_widget(self, v: 'TWidget const *') ->bool:
        return _ida_kernwin.synced_group_t_has_widget(self, v)

    def has_register(self, r: str) ->bool:
        return _ida_kernwin.synced_group_t_has_register(self, r)

    def has(self, ss: 'sync_source_t') ->bool:
        return _ida_kernwin.synced_group_t_has(self, ss)

    def __init__(self):
        _ida_kernwin.synced_group_t_swiginit(self, _ida_kernwin.
            new_synced_group_t())
    __swig_destroy__ = _ida_kernwin.delete_synced_group_t


_ida_kernwin.synced_group_t_swigregister(synced_group_t)
LECVT_CANCELED = _ida_kernwin.LECVT_CANCELED
LECVT_ERROR = _ida_kernwin.LECVT_ERROR
LECVT_OK = _ida_kernwin.LECVT_OK
LECVT_WITHIN_LISTING = _ida_kernwin.LECVT_WITHIN_LISTING


class twinpos_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    at: 'place_t *' = property(_ida_kernwin.twinpos_t_at_get, _ida_kernwin.
        twinpos_t_at_set)
    """location in view
"""
    x: 'int' = property(_ida_kernwin.twinpos_t_x_get, _ida_kernwin.
        twinpos_t_x_set)
    """cursor x
"""

    def __init__(self, *args):
        _ida_kernwin.twinpos_t_swiginit(self, _ida_kernwin.new_twinpos_t(*args)
            )

    def place_as_idaplace_t(self):
        return place_t.as_idaplace_t(self.at)

    def place_as_simpleline_place_t(self):
        return place_t.as_simpleline_place_t(self.at)

    def place_as_tiplace_t(self):
        return place_t.as_tiplace_t(self.at)

    def place(self, view):
        ptype = get_viewer_place_type(view)
        if ptype == TCCPT_IDAPLACE:
            return self.place_as_idaplace_t()
        elif ptype == TCCPT_SIMPLELINE_PLACE:
            return self.place_as_simpleline_place_t()
        elif ptype == TCCPT_TIPLACE:
            return self.place_as_simpleline_place_t()
        else:
            return self.at
    __swig_destroy__ = _ida_kernwin.delete_twinpos_t


_ida_kernwin.twinpos_t_swigregister(twinpos_t)


class twinline_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    at: 'place_t *' = property(_ida_kernwin.twinline_t_at_get, _ida_kernwin
        .twinline_t_at_set)
    """location in view
"""
    line: 'qstring' = property(_ida_kernwin.twinline_t_line_get,
        _ida_kernwin.twinline_t_line_set)
    """line contents
"""
    prefix_color: 'color_t' = property(_ida_kernwin.
        twinline_t_prefix_color_get, _ida_kernwin.twinline_t_prefix_color_set)
    """line prefix color
"""
    bg_color: 'bgcolor_t' = property(_ida_kernwin.twinline_t_bg_color_get,
        _ida_kernwin.twinline_t_bg_color_set)
    """line background color
"""
    is_default: 'bool' = property(_ida_kernwin.twinline_t_is_default_get,
        _ida_kernwin.twinline_t_is_default_set)
    """is this the default line of the current location?
"""

    def __init__(self, *args):
        _ida_kernwin.twinline_t_swiginit(self, _ida_kernwin.new_twinline_t(
            *args))
    __swig_destroy__ = _ida_kernwin.delete_twinline_t


_ida_kernwin.twinline_t_swigregister(twinline_t)


class linearray_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, _ud: 'void *'):
        _ida_kernwin.linearray_t_swiginit(self, _ida_kernwin.
            new_linearray_t(_ud))
    __swig_destroy__ = _ida_kernwin.delete_linearray_t

    def set_place(self, new_at: 'place_t') ->int:
        """Position the array. This function must be called before calling any other member functions.
linearray_t doesn't own place_t structures. The caller must take care of place_t objects.

@param new_at: new position of the array
@returns the delta of lines that the linearray_t had to adjust the place by. 
For example, if the place_t has a lnnum of 5, but it turns out, upon generating lines, 
that the number of lines for that particular place is only 2, then 3 will be returned."""
        return _ida_kernwin.linearray_t_set_place(self, new_at)

    def get_place(self) ->'place_t *':
        """Get the current place. If called before down(), then returns place of line which will be returned by down(). If called after up(), then returns place if line returned by up(). 
        """
        return _ida_kernwin.linearray_t_get_place(self)

    def get_bg_color(self) ->'bgcolor_t':
        """Get current background color. (the same behavior as with get_place(): good before down() and after up()) 
        """
        return _ida_kernwin.linearray_t_get_bg_color(self)

    def get_pfx_color(self) ->'bgcolor_t':
        """Get current prefix color. (the same behavior as with get_place(): good before down() and after up()) 
        """
        return _ida_kernwin.linearray_t_get_pfx_color(self)

    def get_dlnnum(self) ->int:
        """Get default line number. (the same behavior as with get_place(): good before down() and after up()) 
        """
        return _ida_kernwin.linearray_t_get_dlnnum(self)

    def get_linecnt(self) ->int:
        """Get number of lines for the current place. (the same behavior as with get_place(): good before down() and after up()) 
        """
        return _ida_kernwin.linearray_t_get_linecnt(self)

    def userdata(self) ->'void *':
        """Get pointer to user data.
"""
        return _ida_kernwin.linearray_t_userdata(self)

    def set_userdata(self, userd: 'void *') ->None:
        """Change the user data.
"""
        return _ida_kernwin.linearray_t_set_userdata(self, userd)

    def beginning(self) ->bool:
        """Are we at the beginning?
"""
        return _ida_kernwin.linearray_t_beginning(self)

    def ending(self) ->bool:
        return _ida_kernwin.linearray_t_ending(self)

    def down(self) ->str:
        """Get a line from down direction. place is ok BEFORE 
        """
        return _ida_kernwin.linearray_t_down(self)

    def up(self) ->str:
        """Get a line from up direction. place is ok AFTER 
        """
        return _ida_kernwin.linearray_t_up(self)


_ida_kernwin.linearray_t_swigregister(linearray_t)


class lines_rendering_input_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    cb: 'int' = property(_ida_kernwin.lines_rendering_input_t_cb_get,
        _ida_kernwin.lines_rendering_input_t_cb_set)
    sections_lines: 'sections_lines_refs_t' = property(_ida_kernwin.
        lines_rendering_input_t_sections_lines_get, _ida_kernwin.
        lines_rendering_input_t_sections_lines_set)
    """references to the lines that are used for rendering
"""
    sync_group: 'synced_group_t const *' = property(_ida_kernwin.
        lines_rendering_input_t_sync_group_get, _ida_kernwin.
        lines_rendering_input_t_sync_group_set)
    """the 'synced' group 'widget' (see ui_get_lines_rendering_info) belongs to, or nullptr
"""

    def __init__(self):
        _ida_kernwin.lines_rendering_input_t_swiginit(self, _ida_kernwin.
            new_lines_rendering_input_t())
    __swig_destroy__ = _ida_kernwin.delete_lines_rendering_input_t


_ida_kernwin.lines_rendering_input_t_swigregister(lines_rendering_input_t)
CK_TRACE = _ida_kernwin.CK_TRACE
"""traced address
"""
CK_TRACE_OVL = _ida_kernwin.CK_TRACE_OVL
"""overlay trace address
"""
CK_EXTRA1 = _ida_kernwin.CK_EXTRA1
"""extra background overlay #1
"""
CK_EXTRA2 = _ida_kernwin.CK_EXTRA2
"""extra background overlay #2
"""
CK_EXTRA3 = _ida_kernwin.CK_EXTRA3
"""extra background overlay #3
"""
CK_EXTRA4 = _ida_kernwin.CK_EXTRA4
"""extra background overlay #4
"""
CK_EXTRA5 = _ida_kernwin.CK_EXTRA5
"""extra background overlay #5
"""
CK_EXTRA6 = _ida_kernwin.CK_EXTRA6
"""extra background overlay #6
"""
CK_EXTRA7 = _ida_kernwin.CK_EXTRA7
"""extra background overlay #7
"""
CK_EXTRA8 = _ida_kernwin.CK_EXTRA8
"""extra background overlay #8
"""
CK_EXTRA9 = _ida_kernwin.CK_EXTRA9
"""extra background overlay #9
"""
CK_EXTRA10 = _ida_kernwin.CK_EXTRA10
"""extra background overlay #10
"""
CK_EXTRA11 = _ida_kernwin.CK_EXTRA11
"""extra background overlay #11
"""
CK_EXTRA12 = _ida_kernwin.CK_EXTRA12
"""extra background overlay #12
"""
CK_EXTRA13 = _ida_kernwin.CK_EXTRA13
"""extra background overlay #13
"""
CK_EXTRA14 = _ida_kernwin.CK_EXTRA14
"""extra background overlay #14
"""
CK_EXTRA15 = _ida_kernwin.CK_EXTRA15
"""extra background overlay #15
"""
CK_EXTRA16 = _ida_kernwin.CK_EXTRA16
"""extra background overlay #16
"""
LROEF_MASK = _ida_kernwin.LROEF_MASK
LROEF_FULL_LINE = _ida_kernwin.LROEF_FULL_LINE
"""full line background
"""
LROEF_CPS_RANGE = _ida_kernwin.LROEF_CPS_RANGE
"""background for range of chars
"""


class line_rendering_output_entry_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    line: 'twinline_t const *' = property(_ida_kernwin.
        line_rendering_output_entry_t_line_get, _ida_kernwin.
        line_rendering_output_entry_t_line_set)
    flags: 'uint32' = property(_ida_kernwin.
        line_rendering_output_entry_t_flags_get, _ida_kernwin.
        line_rendering_output_entry_t_flags_set)
    """line_rendering_output_entry_t flags
"""
    bg_color: 'bgcolor_t' = property(_ida_kernwin.
        line_rendering_output_entry_t_bg_color_get, _ida_kernwin.
        line_rendering_output_entry_t_bg_color_set)
    cpx: 'int' = property(_ida_kernwin.
        line_rendering_output_entry_t_cpx_get, _ida_kernwin.
        line_rendering_output_entry_t_cpx_set)
    """number of char to start from, valid if LROEF_CPS_RANGE
"""
    nchars: 'int' = property(_ida_kernwin.
        line_rendering_output_entry_t_nchars_get, _ida_kernwin.
        line_rendering_output_entry_t_nchars_set)
    """chars count, valid if LROEF_CPS_RANGE
"""

    def __init__(self, *args):
        _ida_kernwin.line_rendering_output_entry_t_swiginit(self,
            _ida_kernwin.new_line_rendering_output_entry_t(*args))

    def is_bg_color_empty(self) ->bool:
        return _ida_kernwin.line_rendering_output_entry_t_is_bg_color_empty(
            self)

    def is_bg_color_key(self) ->bool:
        return _ida_kernwin.line_rendering_output_entry_t_is_bg_color_key(self)

    def is_bg_color_direct(self) ->bool:
        return _ida_kernwin.line_rendering_output_entry_t_is_bg_color_direct(
            self)

    def __eq__(self, r: 'line_rendering_output_entry_t') ->bool:
        return _ida_kernwin.line_rendering_output_entry_t___eq__(self, r)

    def __ne__(self, r: 'line_rendering_output_entry_t') ->bool:
        return _ida_kernwin.line_rendering_output_entry_t___ne__(self, r)
    __swig_destroy__ = _ida_kernwin.delete_line_rendering_output_entry_t


_ida_kernwin.line_rendering_output_entry_t_swigregister(
    line_rendering_output_entry_t)


class lines_rendering_output_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    entries: 'line_rendering_output_entries_refs_t' = property(_ida_kernwin
        .lines_rendering_output_t_entries_get, _ida_kernwin.
        lines_rendering_output_t_entries_set)
    flags: 'uint32' = property(_ida_kernwin.
        lines_rendering_output_t_flags_get, _ida_kernwin.
        lines_rendering_output_t_flags_set)

    def __init__(self):
        _ida_kernwin.lines_rendering_output_t_swiginit(self, _ida_kernwin.
            new_lines_rendering_output_t())
    __swig_destroy__ = _ida_kernwin.delete_lines_rendering_output_t

    def clear(self) ->None:
        return _ida_kernwin.lines_rendering_output_t_clear(self)

    def __eq__(self, r: 'lines_rendering_output_t') ->bool:
        return _ida_kernwin.lines_rendering_output_t___eq__(self, r)

    def __ne__(self, r: 'lines_rendering_output_t') ->bool:
        return _ida_kernwin.lines_rendering_output_t___ne__(self, r)

    def swap(self, r: 'lines_rendering_output_t') ->None:
        return _ida_kernwin.lines_rendering_output_t_swap(self, r)


_ida_kernwin.lines_rendering_output_t_swigregister(lines_rendering_output_t)


class line_section_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    start: 'cpidx_t' = property(_ida_kernwin.line_section_t_start_get,
        _ida_kernwin.line_section_t_start_set)
    length: 'cplen_t' = property(_ida_kernwin.line_section_t_length_get,
        _ida_kernwin.line_section_t_length_set)

    def contains(self, x: 'cpidx_t') ->bool:
        return _ida_kernwin.line_section_t_contains(self, x)

    def is_open(self) ->bool:
        return _ida_kernwin.line_section_t_is_open(self)

    def is_closed(self) ->bool:
        return _ida_kernwin.line_section_t_is_closed(self)

    def valid(self) ->bool:
        return _ida_kernwin.line_section_t_valid(self)

    def __eq__(self, r: 'line_section_t') ->bool:
        return _ida_kernwin.line_section_t___eq__(self, r)

    def __ne__(self, r: 'line_section_t') ->bool:
        return _ida_kernwin.line_section_t___ne__(self, r)

    def __init__(self):
        _ida_kernwin.line_section_t_swiginit(self, _ida_kernwin.
            new_line_section_t())
    __swig_destroy__ = _ida_kernwin.delete_line_section_t


_ida_kernwin.line_section_t_swigregister(line_section_t)


class tagged_line_section_t(line_section_t):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    tag: 'color_t' = property(_ida_kernwin.tagged_line_section_t_tag_get,
        _ida_kernwin.tagged_line_section_t_tag_set)

    def __init__(self):
        _ida_kernwin.tagged_line_section_t_swiginit(self, _ida_kernwin.
            new_tagged_line_section_t())

    def __eq__(self, r: 'tagged_line_section_t') ->bool:
        return _ida_kernwin.tagged_line_section_t___eq__(self, r)

    def __ne__(self, r: 'tagged_line_section_t') ->bool:
        return _ida_kernwin.tagged_line_section_t___ne__(self, r)

    def valid(self) ->bool:
        return _ida_kernwin.tagged_line_section_t_valid(self)

    def valid_in(self, _in: str) ->bool:
        return _ida_kernwin.tagged_line_section_t_valid_in(self, _in)

    def substr(self, _in: str, end: 'tagged_line_section_t'=None) ->bool:
        return _ida_kernwin.tagged_line_section_t_substr(self, _in, end)

    def __str__(self) ->str:
        return _ida_kernwin.tagged_line_section_t___str__(self)
    __swig_destroy__ = _ida_kernwin.delete_tagged_line_section_t


_ida_kernwin.tagged_line_section_t_swigregister(tagged_line_section_t)


class tagged_line_sections_t(tagged_line_section_vec_t):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def first(self, tag: 'color_t') ->'tagged_line_section_t const *':
        return _ida_kernwin.tagged_line_sections_t_first(self, tag)

    def sections_at(self, out: 'tagged_line_sections_t', x: 'cpidx_t', tag:
        'color_t'=0) ->None:
        return _ida_kernwin.tagged_line_sections_t_sections_at(self, out, x,
            tag)

    def nearest_at(self, x: 'cpidx_t', tag: 'color_t'=0
        ) ->'tagged_line_section_t const *':
        return _ida_kernwin.tagged_line_sections_t_nearest_at(self, x, tag)

    def nearest_before(self, range: 'tagged_line_section_t', start:
        'cpidx_t', tag: 'color_t'=0) ->'tagged_line_section_t const *':
        return _ida_kernwin.tagged_line_sections_t_nearest_before(self,
            range, start, tag)

    def nearest_after(self, range: 'tagged_line_section_t', start:
        'cpidx_t', tag: 'color_t'=0) ->'tagged_line_section_t const *':
        return _ida_kernwin.tagged_line_sections_t_nearest_after(self,
            range, start, tag)

    def __init__(self):
        _ida_kernwin.tagged_line_sections_t_swiginit(self, _ida_kernwin.
            new_tagged_line_sections_t())
    __swig_destroy__ = _ida_kernwin.delete_tagged_line_sections_t


_ida_kernwin.tagged_line_sections_t_swigregister(tagged_line_sections_t)


class listing_location_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    cb: 'int' = property(_ida_kernwin.listing_location_t_cb_get,
        _ida_kernwin.listing_location_t_cb_set)
    loc: 'lochist_entry_t const *' = property(_ida_kernwin.
        listing_location_t_loc_get, _ida_kernwin.listing_location_t_loc_set)
    text: 'qstring const *' = property(_ida_kernwin.
        listing_location_t_text_get, _ida_kernwin.listing_location_t_text_set)
    tagged_sections: 'tagged_line_sections_t const *' = property(_ida_kernwin
        .listing_location_t_tagged_sections_get, _ida_kernwin.
        listing_location_t_tagged_sections_set)

    def __init__(self):
        _ida_kernwin.listing_location_t_swiginit(self, _ida_kernwin.
            new_listing_location_t())
    __swig_destroy__ = _ida_kernwin.delete_listing_location_t


_ida_kernwin.listing_location_t_swigregister(listing_location_t)


def request_refresh(mask: 'uint64', cnd: bool=True) ->None:
    """Request a refresh of a builtin window. 
        
@param mask: Window refresh flags
@param cnd: set if true or clear flag otherwise"""
    return _ida_kernwin.request_refresh(mask, cnd)


def clear_refresh_request(mask: 'uint64') ->None:
    return _ida_kernwin.clear_refresh_request(mask)


def is_refresh_requested(mask: 'uint64') ->bool:
    """Get a refresh request state 
        
@param mask: Window refresh flags
@returns the state (set or cleared)"""
    return _ida_kernwin.is_refresh_requested(mask)


BWN_UNKNOWN = _ida_kernwin.BWN_UNKNOWN
"""unknown window
"""
BWN_EXPORTS = _ida_kernwin.BWN_EXPORTS
"""exports
"""
BWN_IMPORTS = _ida_kernwin.BWN_IMPORTS
"""imports
"""
BWN_NAMES = _ida_kernwin.BWN_NAMES
"""names
"""
BWN_FUNCS = _ida_kernwin.BWN_FUNCS
"""functions
"""
BWN_STRINGS = _ida_kernwin.BWN_STRINGS
"""strings
"""
BWN_SEGS = _ida_kernwin.BWN_SEGS
"""segments
"""
BWN_SEGREGS = _ida_kernwin.BWN_SEGREGS
"""segment registers
"""
BWN_SELS = _ida_kernwin.BWN_SELS
"""selectors
"""
BWN_SIGNS = _ida_kernwin.BWN_SIGNS
"""signatures
"""
BWN_TILS = _ida_kernwin.BWN_TILS
"""type libraries
"""
BWN_TICSR = _ida_kernwin.BWN_TICSR
"""type library widget's (e.g., "Local types") chooser
"""
BWN_CALLS = _ida_kernwin.BWN_CALLS
"""function calls
"""
BWN_PROBS = _ida_kernwin.BWN_PROBS
"""problems
"""
BWN_BPTS = _ida_kernwin.BWN_BPTS
"""breakpoints
"""
BWN_THREADS = _ida_kernwin.BWN_THREADS
"""threads
"""
BWN_MODULES = _ida_kernwin.BWN_MODULES
"""modules
"""
BWN_TRACE = _ida_kernwin.BWN_TRACE
"""tracing view
"""
BWN_CALL_STACK = _ida_kernwin.BWN_CALL_STACK
"""call stack
"""
BWN_XREFS = _ida_kernwin.BWN_XREFS
"""xrefs
"""
BWN_SEARCH = _ida_kernwin.BWN_SEARCH
"""search results
"""
BWN_FRAME = _ida_kernwin.BWN_FRAME
"""function frame
"""
BWN_NAVBAND = _ida_kernwin.BWN_NAVBAND
"""navigation band
"""
BWN_DISASM = _ida_kernwin.BWN_DISASM
"""disassembly views
"""
BWN_HEXVIEW = _ida_kernwin.BWN_HEXVIEW
"""hex view
"""
BWN_NOTEPAD = _ida_kernwin.BWN_NOTEPAD
"""notepad
"""
BWN_OUTPUT = _ida_kernwin.BWN_OUTPUT
"""the text area, in the output window
"""
BWN_CLI = _ida_kernwin.BWN_CLI
"""the command-line, in the output window
"""
BWN_WATCH = _ida_kernwin.BWN_WATCH
"""the 'watches' debugger window
"""
BWN_LOCALS = _ida_kernwin.BWN_LOCALS
"""the 'locals' debugger window
"""
BWN_STKVIEW = _ida_kernwin.BWN_STKVIEW
"""the 'Stack view' debugger window
"""
BWN_CHOOSER = _ida_kernwin.BWN_CHOOSER
"""a non-builtin chooser
"""
BWN_SHORTCUTCSR = _ida_kernwin.BWN_SHORTCUTCSR
"""the shortcuts chooser (Qt version only)
"""
BWN_SHORTCUTWIN = _ida_kernwin.BWN_SHORTCUTWIN
"""the shortcuts window (Qt version only)
"""
BWN_CPUREGS = _ida_kernwin.BWN_CPUREGS
"""one of the 'General registers', 'FPU register', ... debugger windows
"""
BWN_SO_STRUCTS = _ida_kernwin.BWN_SO_STRUCTS
"""the 'Structure offsets' dialog's 'Structures and Unions' panel
"""
BWN_SO_OFFSETS = _ida_kernwin.BWN_SO_OFFSETS
"""the 'Structure offsets' dialog's offset panel
"""
BWN_CMDPALCSR = _ida_kernwin.BWN_CMDPALCSR
"""the command palette chooser (Qt version only)
"""
BWN_CMDPALWIN = _ida_kernwin.BWN_CMDPALWIN
"""the command palette window (Qt version only)
"""
BWN_SNIPPETS = _ida_kernwin.BWN_SNIPPETS
"""the 'Execute script' window
"""
BWN_CUSTVIEW = _ida_kernwin.BWN_CUSTVIEW
"""custom viewers
"""
BWN_ADDRWATCH = _ida_kernwin.BWN_ADDRWATCH
"""the 'Watch List' window
"""
BWN_PSEUDOCODE = _ida_kernwin.BWN_PSEUDOCODE
"""hexrays decompiler views
"""
BWN_CALLS_CALLERS = _ida_kernwin.BWN_CALLS_CALLERS
"""function calls, callers
"""
BWN_CALLS_CALLEES = _ida_kernwin.BWN_CALLS_CALLEES
"""function calls, callees
"""
BWN_MDVIEWCSR = _ida_kernwin.BWN_MDVIEWCSR
"""lumina metadata view chooser
"""
BWN_DISASM_ARROWS = _ida_kernwin.BWN_DISASM_ARROWS
"""disassembly arrows widget
"""
BWN_CV_LINE_INFOS = _ida_kernwin.BWN_CV_LINE_INFOS
"""custom viewers' lineinfo widget
"""
BWN_SRCPTHMAP_CSR = _ida_kernwin.BWN_SRCPTHMAP_CSR
""""Source paths..."'s path mappings chooser
"""
BWN_SRCPTHUND_CSR = _ida_kernwin.BWN_SRCPTHUND_CSR
""""Source paths..."'s undesired paths chooser
"""
BWN_UNDOHIST = _ida_kernwin.BWN_UNDOHIST
"""Undo history.
"""
BWN_SNIPPETS_CSR = _ida_kernwin.BWN_SNIPPETS_CSR
"""the list of snippets in the 'Execute script' window
"""
BWN_SCRIPTS_CSR = _ida_kernwin.BWN_SCRIPTS_CSR
"""the "Recent scripts" chooser
"""
BWN_BOOKMARKS = _ida_kernwin.BWN_BOOKMARKS
"""a persistent 'Bookmarks' widget
"""
BWN_TILIST = _ida_kernwin.BWN_TILIST
"""a type listing widget
"""
BWN_TIL_VIEW = _ida_kernwin.BWN_TIL_VIEW
"""a type library's toplevel widget
"""
IWID_EXPORTS = _ida_kernwin.IWID_EXPORTS
"""exports
"""
IWID_IMPORTS = _ida_kernwin.IWID_IMPORTS
"""imports
"""
IWID_NAMES = _ida_kernwin.IWID_NAMES
"""names
"""
IWID_FUNCS = _ida_kernwin.IWID_FUNCS
"""functions
"""
IWID_STRINGS = _ida_kernwin.IWID_STRINGS
"""strings
"""
IWID_SEGS = _ida_kernwin.IWID_SEGS
"""segments
"""
IWID_SEGREGS = _ida_kernwin.IWID_SEGREGS
"""segment registers
"""
IWID_SELS = _ida_kernwin.IWID_SELS
"""selectors
"""
IWID_SIGNS = _ida_kernwin.IWID_SIGNS
"""signatures
"""
IWID_TILS = _ida_kernwin.IWID_TILS
"""type libraries
"""
IWID_TICSR = _ida_kernwin.IWID_TICSR
"""type library widget's (e.g., "Local types") chooser
"""
IWID_CALLS = _ida_kernwin.IWID_CALLS
"""function calls
"""
IWID_PROBS = _ida_kernwin.IWID_PROBS
"""problems
"""
IWID_BPTS = _ida_kernwin.IWID_BPTS
"""breakpoints
"""
IWID_THREADS = _ida_kernwin.IWID_THREADS
"""threads
"""
IWID_MODULES = _ida_kernwin.IWID_MODULES
"""modules
"""
IWID_TRACE = _ida_kernwin.IWID_TRACE
"""tracing view
"""
IWID_CALL_STACK = _ida_kernwin.IWID_CALL_STACK
"""call stack
"""
IWID_XREFS = _ida_kernwin.IWID_XREFS
"""xrefs
"""
IWID_SEARCH = _ida_kernwin.IWID_SEARCH
"""search results
"""
IWID_FRAME = _ida_kernwin.IWID_FRAME
"""function frame
"""
IWID_NAVBAND = _ida_kernwin.IWID_NAVBAND
"""navigation band
"""
IWID_DISASM = _ida_kernwin.IWID_DISASM
"""disassembly views
"""
IWID_HEXVIEW = _ida_kernwin.IWID_HEXVIEW
"""hex views
"""
IWID_NOTEPAD = _ida_kernwin.IWID_NOTEPAD
"""notepad
"""
IWID_OUTPUT = _ida_kernwin.IWID_OUTPUT
"""output
"""
IWID_CLI = _ida_kernwin.IWID_CLI
"""input line
"""
IWID_WATCH = _ida_kernwin.IWID_WATCH
"""watches
"""
IWID_LOCALS = _ida_kernwin.IWID_LOCALS
"""locals
"""
IWID_STKVIEW = _ida_kernwin.IWID_STKVIEW
"""stack view
"""
IWID_CHOOSER = _ida_kernwin.IWID_CHOOSER
"""chooser
"""
IWID_SHORTCUTCSR = _ida_kernwin.IWID_SHORTCUTCSR
"""shortcuts chooser
"""
IWID_SHORTCUTWIN = _ida_kernwin.IWID_SHORTCUTWIN
"""shortcuts window
"""
IWID_CPUREGS = _ida_kernwin.IWID_CPUREGS
"""registers
"""
IWID_SO_STRUCTS = _ida_kernwin.IWID_SO_STRUCTS
"""stroff
"""
IWID_SO_OFFSETS = _ida_kernwin.IWID_SO_OFFSETS
"""stroff
"""
IWID_CMDPALCSR = _ida_kernwin.IWID_CMDPALCSR
"""command palette
"""
IWID_CMDPALWIN = _ida_kernwin.IWID_CMDPALWIN
"""command palette
"""
IWID_SNIPPETS = _ida_kernwin.IWID_SNIPPETS
"""snippets
"""
IWID_CUSTVIEW = _ida_kernwin.IWID_CUSTVIEW
"""custom viewers
"""
IWID_ADDRWATCH = _ida_kernwin.IWID_ADDRWATCH
"""address watches
"""
IWID_PSEUDOCODE = _ida_kernwin.IWID_PSEUDOCODE
"""decompiler
"""
IWID_CALLS_CALLERS = _ida_kernwin.IWID_CALLS_CALLERS
"""funcalls, callers
"""
IWID_CALLS_CALLEES = _ida_kernwin.IWID_CALLS_CALLEES
"""funcalls, callees
"""
IWID_MDVIEWCSR = _ida_kernwin.IWID_MDVIEWCSR
"""lumina md view
"""
IWID_DISASM_ARROWS = _ida_kernwin.IWID_DISASM_ARROWS
"""arrows widget
"""
IWID_CV_LINE_INFOS = _ida_kernwin.IWID_CV_LINE_INFOS
"""lineinfo widget
"""
IWID_SRCPTHMAP_CSR = _ida_kernwin.IWID_SRCPTHMAP_CSR
"""mappings chooser
"""
IWID_SRCPTHUND_CSR = _ida_kernwin.IWID_SRCPTHUND_CSR
"""undesired chooser
"""
IWID_UNDOHIST = _ida_kernwin.IWID_UNDOHIST
"""Undo history.
"""
IWID_SNIPPETS_CSR = _ida_kernwin.IWID_SNIPPETS_CSR
"""snippets chooser
"""
IWID_SCRIPTS_CSR = _ida_kernwin.IWID_SCRIPTS_CSR
"""recent scripts
"""
IWID_BOOKMARKS = _ida_kernwin.IWID_BOOKMARKS
"""bookmarks list
"""
IWID_TILIST = _ida_kernwin.IWID_TILIST
"""type listing
"""
IWID_TIL_VIEW = _ida_kernwin.IWID_TIL_VIEW
"""type library's toplevel widget
"""
IWID_ANY_LISTING = _ida_kernwin.IWID_ANY_LISTING
"""anything that uses a listing widget
"""
IWID_EA_LISTING = _ida_kernwin.IWID_EA_LISTING
"""anything that can be used to represent data/code at an address
"""
IWID_ALL = _ida_kernwin.IWID_ALL
"""mask
"""


def is_chooser_widget(t: 'twidget_type_t') ->bool:
    """Does the given widget type specify a chooser widget?
"""
    return _ida_kernwin.is_chooser_widget(t)


IDA_DEBUG_DREFS = _ida_kernwin.IDA_DEBUG_DREFS
"""drefs
"""
IDA_DEBUG_OFFSET = _ida_kernwin.IDA_DEBUG_OFFSET
"""offsets
"""
IDA_DEBUG_FLIRT = _ida_kernwin.IDA_DEBUG_FLIRT
"""flirt
"""
IDA_DEBUG_IDP = _ida_kernwin.IDA_DEBUG_IDP
"""idp module
"""
IDA_DEBUG_LDR = _ida_kernwin.IDA_DEBUG_LDR
"""ldr module
"""
IDA_DEBUG_PLUGIN = _ida_kernwin.IDA_DEBUG_PLUGIN
"""plugin module
"""
IDA_DEBUG_IDS = _ida_kernwin.IDA_DEBUG_IDS
"""ids files
"""
IDA_DEBUG_CONFIG = _ida_kernwin.IDA_DEBUG_CONFIG
"""config file
"""
IDA_DEBUG_CHECKMEM = _ida_kernwin.IDA_DEBUG_CHECKMEM
"""check heap consistency
"""
IDA_DEBUG_LICENSE = _ida_kernwin.IDA_DEBUG_LICENSE
"""licensing
"""
IDA_DEBUG_DEMANGLE = _ida_kernwin.IDA_DEBUG_DEMANGLE
"""demangler
"""
IDA_DEBUG_QUEUE = _ida_kernwin.IDA_DEBUG_QUEUE
"""queue
"""
IDA_DEBUG_ROLLBACK = _ida_kernwin.IDA_DEBUG_ROLLBACK
"""rollback
"""
IDA_DEBUG_ALREADY = _ida_kernwin.IDA_DEBUG_ALREADY
"""already data or code
"""
IDA_DEBUG_TIL = _ida_kernwin.IDA_DEBUG_TIL
"""type system
"""
IDA_DEBUG_NOTIFY = _ida_kernwin.IDA_DEBUG_NOTIFY
"""show all notifications
"""
IDA_DEBUG_DEBUGGER = _ida_kernwin.IDA_DEBUG_DEBUGGER
"""debugger
"""
IDA_DEBUG_APPCALL = _ida_kernwin.IDA_DEBUG_APPCALL
"""appcall
"""
IDA_DEBUG_SRCDBG = _ida_kernwin.IDA_DEBUG_SRCDBG
"""source debugging
"""
IDA_DEBUG_ACCESSIBILITY = _ida_kernwin.IDA_DEBUG_ACCESSIBILITY
"""accessibility
"""
IDA_DEBUG_NETWORK = _ida_kernwin.IDA_DEBUG_NETWORK
"""network
"""
IDA_DEBUG_INTERNET = _ida_kernwin.IDA_DEBUG_INTERNET
"""internet connection (for API backward compatibility)
"""
IDA_DEBUG_SIMPLEX = _ida_kernwin.IDA_DEBUG_SIMPLEX
"""full stack analysis
"""
IDA_DEBUG_DBGINFO = _ida_kernwin.IDA_DEBUG_DBGINFO
"""handling of debug info (e.g. pdb, dwarf)
"""
IDA_DEBUG_LUMINA = _ida_kernwin.IDA_DEBUG_LUMINA
"""lumina related
"""
IDA_DEBUG_THEMES = _ida_kernwin.IDA_DEBUG_THEMES
"""themes
"""
IDA_DEBUG_REGEX = _ida_kernwin.IDA_DEBUG_REGEX
"""regular expression
"""
IDA_DEBUG_SUBPROC = _ida_kernwin.IDA_DEBUG_SUBPROC
"""sub process
"""
IDA_DEBUG_RANGECB = _ida_kernwin.IDA_DEBUG_RANGECB
"""range-based entities like segments, functions and so on
"""
IDA_DEBUG_ALWAYS = _ida_kernwin.IDA_DEBUG_ALWAYS
"""everything
"""
AST_ENABLE_ALWAYS = _ida_kernwin.AST_ENABLE_ALWAYS
"""enable action and do not call action_handler_t::update() anymore
"""
AST_ENABLE_FOR_IDB = _ida_kernwin.AST_ENABLE_FOR_IDB
"""enable action for the current idb. call action_handler_t::update() when a database is opened/closed 
          """
AST_ENABLE_FOR_WIDGET = _ida_kernwin.AST_ENABLE_FOR_WIDGET
"""enable action for the current widget. call action_handler_t::update() when a widget gets/loses focus 
          """
AST_ENABLE = _ida_kernwin.AST_ENABLE
"""enable action - call action_handler_t::update() when anything changes
"""
AST_DISABLE_ALWAYS = _ida_kernwin.AST_DISABLE_ALWAYS
"""disable action and do not call action_handler_t::action() anymore
"""
AST_DISABLE_FOR_IDB = _ida_kernwin.AST_DISABLE_FOR_IDB
"""analog of AST_ENABLE_FOR_IDB
"""
AST_DISABLE_FOR_WIDGET = _ida_kernwin.AST_DISABLE_FOR_WIDGET
"""analog of AST_ENABLE_FOR_WIDGET
"""
AST_DISABLE = _ida_kernwin.AST_DISABLE
"""analog of AST_ENABLE
"""


def is_action_enabled(s: 'action_state_t') ->bool:
    """Check if the given action state is one of AST_ENABLE*.
"""
    return _ida_kernwin.is_action_enabled(s)


CH_MODAL = _ida_kernwin.CH_MODAL
"""Modal chooser.
"""
CH_KEEP = _ida_kernwin.CH_KEEP
"""The chooser instance's lifecycle is not tied to the lifecycle of the widget showing its contents. Closing the widget will not destroy the chooser structure. This allows for, e.g., static global chooser instances that don't need to be allocated on the heap. Also stack-allocated chooser instances must set this bit. 
        """
CH_MULTI = _ida_kernwin.CH_MULTI
"""The chooser will allow multi-selection (only for GUI choosers). This bit is set when using the chooser_multi_t structure. 
        """
CH_MULTI_EDIT = _ida_kernwin.CH_MULTI_EDIT
"""Obsolete.
"""
CH_NOBTNS = _ida_kernwin.CH_NOBTNS
"""do not display ok/cancel/help/search buttons. Meaningful only for gui modal windows because non-modal windows do not have any buttons anyway. Text mode does not have them neither. 
        """
CH_ATTRS = _ida_kernwin.CH_ATTRS
"""generate ui_get_chooser_item_attrs (gui only)
"""
CH_UNUSED = _ida_kernwin.CH_UNUSED
CH_FORCE_DEFAULT = _ida_kernwin.CH_FORCE_DEFAULT
"""if a non-modal chooser was already open, change selection to the default one 
        """
CH_CAN_INS = _ida_kernwin.CH_CAN_INS
"""allow to insert new items
"""
CH_CAN_DEL = _ida_kernwin.CH_CAN_DEL
"""allow to delete existing item(s)
"""
CH_CAN_EDIT = _ida_kernwin.CH_CAN_EDIT
"""allow to edit existing item(s)
"""
CH_CAN_REFRESH = _ida_kernwin.CH_CAN_REFRESH
"""allow to refresh chooser
"""
CH_QFLT = _ida_kernwin.CH_QFLT
"""open with quick filter enabled and focused
"""
CH_QFTYP_SHIFT = _ida_kernwin.CH_QFTYP_SHIFT
CH_QFTYP_DEFAULT = _ida_kernwin.CH_QFTYP_DEFAULT
"""set quick filtering type to the possible existing default for this chooser
"""
CH_QFTYP_NORMAL = _ida_kernwin.CH_QFTYP_NORMAL
"""normal (i.e., lexicographical) quick filter type
"""
CH_QFTYP_WHOLE_WORDS = _ida_kernwin.CH_QFTYP_WHOLE_WORDS
"""whole words quick filter type
"""
CH_QFTYP_REGEX = _ida_kernwin.CH_QFTYP_REGEX
"""regex quick filter type
"""
CH_QFTYP_FUZZY = _ida_kernwin.CH_QFTYP_FUZZY
"""fuzzy search quick filter type
"""
CH_QFTYP_MASK = _ida_kernwin.CH_QFTYP_MASK
CH_NO_STATUS_BAR = _ida_kernwin.CH_NO_STATUS_BAR
"""don't show a status bar
"""
CH_RESTORE = _ida_kernwin.CH_RESTORE
"""restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)
"""
CH_RENAME_IS_EDIT = _ida_kernwin.CH_RENAME_IS_EDIT
"""triggering a 'edit/rename' (i.e., F2 shortcut) on a cell, should call the edit() callback for the corresponding row. 
        """
CH_BUILTIN_SHIFT = _ida_kernwin.CH_BUILTIN_SHIFT
CH_BUILTIN_MASK = _ida_kernwin.CH_BUILTIN_MASK
"""Mask for builtin chooser numbers. Plugins should not use them.
"""
CH_HAS_DIRTREE = _ida_kernwin.CH_HAS_DIRTREE
"""The chooser can provide a dirtree_t, meaning a tree-like structure can be provided to the user (instead of a flat table) 
        """
CH_TM_NO_TREE = _ida_kernwin.CH_TM_NO_TREE
"""chooser will show in no-tree mode
"""
CH_TM_FOLDERS_ONLY = _ida_kernwin.CH_TM_FOLDERS_ONLY
"""chooser will show in folders-only mode
"""
CH_TM_FULL_TREE = _ida_kernwin.CH_TM_FULL_TREE
"""chooser will show in full-tree mode
"""
CH_TM_SHIFT = _ida_kernwin.CH_TM_SHIFT
CH_TM_MASK = _ida_kernwin.CH_TM_MASK
CH_HAS_DIFF = _ida_kernwin.CH_HAS_DIFF
"""The chooser can be used in a diffing/merging workflow.
"""
CH_NO_SORT = _ida_kernwin.CH_NO_SORT
"""The chooser will not have sorting abilities.
"""
CH_NO_FILTER = _ida_kernwin.CH_NO_FILTER
"""The chooser will not have filtering abilities.
"""
CH_NON_PERSISTED_TREE = _ida_kernwin.CH_NON_PERSISTED_TREE
"""the chooser tree is not persisted (it is not loaded on startup and is not saved on exit) 
        """
CH2_LAZY_LOADED = _ida_kernwin.CH2_LAZY_LOADED
"""The chooser is lazy-loaded; it receives the callback do_lazy_load_dir() (only meaningful when CH_HAS_DIRTREE is set) 
        """
CH2_HAS_INODE2INDEX = _ida_kernwin.CH2_HAS_INODE2INDEX
CHCOL_PLAIN = _ida_kernwin.CHCOL_PLAIN
"""plain string
"""
CHCOL_PATH = _ida_kernwin.CHCOL_PATH
"""file path. TUI IDA will truncate excessive cell lengths starting at their beginning, and prepending the resulting text with "..." order to leave the filename visible 
        """
CHCOL_HEX = _ida_kernwin.CHCOL_HEX
"""hexadecimal number
"""
CHCOL_DEC = _ida_kernwin.CHCOL_DEC
"""decimal number
"""
CHCOL_EA = _ida_kernwin.CHCOL_EA
"""address
"""
CHCOL_FNAME = _ida_kernwin.CHCOL_FNAME
"""function name. If a chooser column has this flag set and implements chooser_base_t::get_ea(), rows background colors will be automatically set to match the navigator's "Library function", "Lumina function" and "External symbol" colors 
        """
CHCOL_FORMAT = _ida_kernwin.CHCOL_FORMAT
"""column format mask
"""
CHCOL_DEFHIDDEN = _ida_kernwin.CHCOL_DEFHIDDEN
"""column should be hidden by default
"""
CHCOL_DRAGHINT = _ida_kernwin.CHCOL_DRAGHINT
"""the column number that will be used to build hints for the dragging undo label. This should be provided for at most one column for any given chooser. 
        """
CHCOL_INODENAME = _ida_kernwin.CHCOL_INODENAME
"""if CH_HAS_DIRTREE has been specified, this instructs the chooser that this column shows the inode name. This should be provided for at most one column for any given chooser. 
        """
CHITEM_BOLD = _ida_kernwin.CHITEM_BOLD
"""display the item in bold
"""
CHITEM_ITALIC = _ida_kernwin.CHITEM_ITALIC
"""display the item in italic
"""
CHITEM_UNDER = _ida_kernwin.CHITEM_UNDER
"""underline the item
"""
CHITEM_STRIKE = _ida_kernwin.CHITEM_STRIKE
"""strikeout the item
"""
CHITEM_GRAY = _ida_kernwin.CHITEM_GRAY
"""gray out the item
"""
CHOOSER_NOMAINMENU = _ida_kernwin.CHOOSER_NOMAINMENU
"""do not display main menu
"""
CHOOSER_NOSTATUSBAR = _ida_kernwin.CHOOSER_NOSTATUSBAR
"""do not display status bar (obsolete. Use CH_NO_STATUS_BAR instead)
"""


class chooser_item_attrs_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    flags: 'int' = property(_ida_kernwin.chooser_item_attrs_t_flags_get,
        _ida_kernwin.chooser_item_attrs_t_flags_set)
    """Chooser item property bits
"""
    color: 'bgcolor_t' = property(_ida_kernwin.
        chooser_item_attrs_t_color_get, _ida_kernwin.
        chooser_item_attrs_t_color_set)
    """item color
"""

    def __init__(self):
        _ida_kernwin.chooser_item_attrs_t_swiginit(self, _ida_kernwin.
            new_chooser_item_attrs_t())

    def reset(self) ->None:
        return _ida_kernwin.chooser_item_attrs_t_reset(self)

    def __eq__(self, other: 'chooser_item_attrs_t') ->bool:
        return _ida_kernwin.chooser_item_attrs_t___eq__(self, other)
    __swig_destroy__ = _ida_kernwin.delete_chooser_item_attrs_t


_ida_kernwin.chooser_item_attrs_t_swigregister(chooser_item_attrs_t)


class chooser_row_info_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    texts: 'qstrvec_t' = property(_ida_kernwin.chooser_row_info_t_texts_get,
        _ida_kernwin.chooser_row_info_t_texts_set)
    """texts, one per chooser column
"""
    attrs: 'chooser_item_attrs_t' = property(_ida_kernwin.
        chooser_row_info_t_attrs_get, _ida_kernwin.chooser_row_info_t_attrs_set
        )
    """styling attributes
"""
    icon: 'int' = property(_ida_kernwin.chooser_row_info_t_icon_get,
        _ida_kernwin.chooser_row_info_t_icon_set)
    """icon number
"""

    def __eq__(self, other: 'chooser_row_info_t') ->bool:
        return _ida_kernwin.chooser_row_info_t___eq__(self, other)

    def __ne__(self, other: 'chooser_row_info_t') ->bool:
        return _ida_kernwin.chooser_row_info_t___ne__(self, other)

    def __init__(self):
        _ida_kernwin.chooser_row_info_t_swiginit(self, _ida_kernwin.
            new_chooser_row_info_t())
    __swig_destroy__ = _ida_kernwin.delete_chooser_row_info_t


_ida_kernwin.chooser_row_info_t_swigregister(chooser_row_info_t)
GCRF_HIGH_BIT = _ida_kernwin.GCRF_HIGH_BIT
GCRF_HEADER = _ida_kernwin.GCRF_HEADER
"""Return header texts.
"""
GCRF_SELECTION = _ida_kernwin.GCRF_SELECTION
"""Return selected rows.
"""
GCRF_CURRENT = _ida_kernwin.GCRF_CURRENT
"""Return the current row.
"""
GCRF_ALL = _ida_kernwin.GCRF_ALL
"""Return all rows.
"""


class chooser_stdact_desc_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    version: 'int' = property(_ida_kernwin.
        chooser_stdact_desc_t_version_get, _ida_kernwin.
        chooser_stdact_desc_t_version_set)
    """to support the backward compatibility
"""
    label: 'char const *' = property(_ida_kernwin.
        chooser_stdact_desc_t_label_get, _ida_kernwin.
        chooser_stdact_desc_t_label_set)
    """see action_desc_t
"""
    tooltip: 'char const *' = property(_ida_kernwin.
        chooser_stdact_desc_t_tooltip_get, _ida_kernwin.
        chooser_stdact_desc_t_tooltip_set)
    icon: 'int' = property(_ida_kernwin.chooser_stdact_desc_t_icon_get,
        _ida_kernwin.chooser_stdact_desc_t_icon_set)

    def __init__(self, _label: str=None, _tooltip: str=None, _icon: int=-1):
        if self.__class__ == chooser_stdact_desc_t:
            _self = None
        else:
            _self = self
        _ida_kernwin.chooser_stdact_desc_t_swiginit(self, _ida_kernwin.
            new_chooser_stdact_desc_t(_self, _label, _tooltip, _icon))
    __swig_destroy__ = _ida_kernwin.delete_chooser_stdact_desc_t

    def ucb(self, arg0: 'action_ctx_base_t') ->'action_state_t':
        """the update callback, see action_handler_t::update() When the update callback is called from the chooser UI engine, it can be sure that ctx.source.chooser is a valid pointer to chooser_base_t and that there are selected items for the Delete and Edit actions. 
        """
        return _ida_kernwin.chooser_stdact_desc_t_ucb(self, arg0)

    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_chooser_stdact_desc_t(self)
        return weakref.proxy(self)


_ida_kernwin.chooser_stdact_desc_t_swigregister(chooser_stdact_desc_t)


class chooser_base_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError('No constructor defined - class is abstract')
    __repr__ = _swig_repr
    x0: 'int' = property(_ida_kernwin.chooser_base_t_x0_get)
    """screen position, Functions: generic list choosers
"""
    y0: 'int' = property(_ida_kernwin.chooser_base_t_y0_get)
    x1: 'int' = property(_ida_kernwin.chooser_base_t_x1_get)
    y1: 'int' = property(_ida_kernwin.chooser_base_t_y1_get)
    width: 'int' = property(_ida_kernwin.chooser_base_t_width_get)
    """(in chars)
"""
    height: 'int' = property(_ida_kernwin.chooser_base_t_height_get)
    """(in chars)
"""
    title: 'char const *' = property(_ida_kernwin.chooser_base_t_title_get)
    """menu title (includes ptr to help). May have chooser title prefixes (see "Chooser
 title" above). 
        """
    columns: 'int' = property(_ida_kernwin.chooser_base_t_columns_get)
    """number of columns
"""
    widths: 'int const *' = property(_ida_kernwin.chooser_base_t_widths_get)
    """column widths
* low 16 bits of each value hold the column width
* high 16 bits are flags (see Chooser column flags) 


        """
    header: 'char const *const *' = property(_ida_kernwin.
        chooser_base_t_header_get)
    """header line; contains the tooltips, and column name for each of 'columns' columns. When tooltips need to be provided, the syntax should be: "#tooltip#column-name". (Otherwise, the syntax is simply "column-name".) 
        """
    icon: 'int' = property(_ida_kernwin.chooser_base_t_icon_get)
    """default icon
"""
    POPUP_INS = _ida_kernwin.chooser_base_t_POPUP_INS
    POPUP_DEL = _ida_kernwin.chooser_base_t_POPUP_DEL
    POPUP_EDIT = _ida_kernwin.chooser_base_t_POPUP_EDIT
    POPUP_REFRESH = _ida_kernwin.chooser_base_t_POPUP_REFRESH
    NSTDPOPUPS = _ida_kernwin.chooser_base_t_NSTDPOPUPS
    popup_names: 'qstring [chooser_base_t::NSTDPOPUPS]' = property(_ida_kernwin
        .chooser_base_t_popup_names_get)
    """array of custom labels of the standard actions. Used to replace labels for these actions. 
An empty name means that the default name will be used. 
        """
    deflt_col: 'int' = property(_ida_kernwin.chooser_base_t_deflt_col_get)
    """Column that will have focus.
"""

    def is_same(self, other: 'chooser_base_t') ->bool:
        """do the current and the given objects hold the same data?
"""
        return _ida_kernwin.chooser_base_t_is_same(self, other)

    def can_ins(self) ->bool:
        """is an operation allowed?
"""
        return _ida_kernwin.chooser_base_t_can_ins(self)

    def can_del(self) ->bool:
        return _ida_kernwin.chooser_base_t_can_del(self)

    def can_edit(self) ->bool:
        return _ida_kernwin.chooser_base_t_can_edit(self)

    def can_refresh(self) ->bool:
        return _ida_kernwin.chooser_base_t_can_refresh(self)

    def popup_allowed(self, stdact_idx: int) ->bool:
        """is a standard action allowed?
"""
        return _ida_kernwin.chooser_base_t_popup_allowed(self, stdact_idx)

    def is_status_bar_hidden(self) ->bool:
        return _ida_kernwin.chooser_base_t_is_status_bar_hidden(self)

    def should_restore_geometry(self) ->bool:
        return _ida_kernwin.chooser_base_t_should_restore_geometry(self)

    def is_modal(self) ->bool:
        """is choose modal?
"""
        return _ida_kernwin.chooser_base_t_is_modal(self)

    def has_widget_lifecycle(self) ->bool:
        """should chooser object be deleted when the widget gets destroyed?
"""
        return _ida_kernwin.chooser_base_t_has_widget_lifecycle(self)

    def is_multi(self) ->bool:
        """is multi-selection allowed?
"""
        return _ida_kernwin.chooser_base_t_is_multi(self)

    def ask_item_attrs(self) ->bool:
        """should chooser generate ui_get_chooser_item_attrs events?
"""
        return _ida_kernwin.chooser_base_t_ask_item_attrs(self)

    def is_force_default(self) ->bool:
        """should selection of the already opened non-modal chooser be changed?
"""
        return _ida_kernwin.chooser_base_t_is_force_default(self)

    def get_builtin_number(self) ->'uint':
        """get number of the built-in chooser
"""
        return _ida_kernwin.chooser_base_t_get_builtin_number(self)

    def is_quick_filter_visible_initially(self) ->bool:
        return _ida_kernwin.chooser_base_t_is_quick_filter_visible_initially(
            self)

    def get_quick_filter_initial_mode(self) ->int:
        return _ida_kernwin.chooser_base_t_get_quick_filter_initial_mode(self)

    def has_dirtree(self) ->bool:
        return _ida_kernwin.chooser_base_t_has_dirtree(self)

    def has_diff_capability(self) ->bool:
        return _ida_kernwin.chooser_base_t_has_diff_capability(self)

    def can_sort(self) ->bool:
        return _ida_kernwin.chooser_base_t_can_sort(self)

    def can_filter(self) ->bool:
        return _ida_kernwin.chooser_base_t_can_filter(self)

    def should_rename_trigger_edit(self) ->bool:
        return _ida_kernwin.chooser_base_t_should_rename_trigger_edit(self)

    def is_dirtree_persisted(self) ->bool:
        return _ida_kernwin.chooser_base_t_is_dirtree_persisted(self)

    def is_lazy_loaded(self) ->bool:
        return _ida_kernwin.chooser_base_t_is_lazy_loaded(self)

    def has_inode_to_index(self) ->bool:
        return _ida_kernwin.chooser_base_t_has_inode_to_index(self)

    def get_count(self) ->'size_t':
        """get the number of elements in the chooser
"""
        return _ida_kernwin.chooser_base_t_get_count(self)

    def get_ea(self, arg2: 'size_t') ->ida_idaapi.ea_t:
        """get the address of an element. When this function returns valid addresses: * If any column has the `CHCOL_FNAME` flag, rows will be colored according to the attributes of the functions who own those addresses (extern, library function, Lumina, ... - similar to what the "Functions" widget does) * When a selection is present and the user presses `<Enter>` (`<Shift+Enter>` if the chooser is modal), IDA will jump to that address (through jumpto()) 
        
@returns the effective address, BADADDR if the element has no address"""
        return _ida_kernwin.chooser_base_t_get_ea(self, arg2)

    def get_row(self, n: int) ->Tuple[List[str], int, chooser_item_attrs_t]:
        """Get data & attributes for a row in a chooser.

@param n The row number
@return a tuple (list-of-strings, icon-id, row-attributes)"""
        return _ida_kernwin.chooser_base_t_get_row(self, n)


_ida_kernwin.chooser_base_t_swigregister(chooser_base_t)
nat_lib = _ida_kernwin.nat_lib
nat_fun = _ida_kernwin.nat_fun
nat_cod = _ida_kernwin.nat_cod
nat_dat = _ida_kernwin.nat_dat
nat_und = _ida_kernwin.nat_und
nat_ext = _ida_kernwin.nat_ext
nat_err = _ida_kernwin.nat_err
nat_gap = _ida_kernwin.nat_gap
nat_cur = _ida_kernwin.nat_cur
nat_auto = _ida_kernwin.nat_auto
nat_lum = _ida_kernwin.nat_lum
nat_hlo = _ida_kernwin.nat_hlo
nat_last = _ida_kernwin.nat_last
CVH_USERDATA = _ida_kernwin.CVH_USERDATA
CVH_KEYDOWN = _ida_kernwin.CVH_KEYDOWN
"""see custom_viewer_keydown_t
"""
CVH_POPUP = _ida_kernwin.CVH_POPUP
"""see custom_viewer_popup_t
"""
CVH_DBLCLICK = _ida_kernwin.CVH_DBLCLICK
"""see custom_viewer_dblclick_t
"""
CVH_CURPOS = _ida_kernwin.CVH_CURPOS
"""see custom_viewer_curpos_t
"""
CVH_CLOSE = _ida_kernwin.CVH_CLOSE
"""see custom_viewer_close_t
"""
CVH_CLICK = _ida_kernwin.CVH_CLICK
"""see custom_viewer_click_t
"""
CVH_QT_AWARE = _ida_kernwin.CVH_QT_AWARE
"""see set_custom_viewer_qt_aware()
"""
CVH_HELP = _ida_kernwin.CVH_HELP
"""see custom_viewer_help_t
"""
CVH_MOUSEMOVE = _ida_kernwin.CVH_MOUSEMOVE
"""see custom_viewer_mouse_moved_t
"""
CDVH_USERDATA = _ida_kernwin.CDVH_USERDATA
"""see set_code_viewer_user_data()
"""
CDVH_SRCVIEW = _ida_kernwin.CDVH_SRCVIEW
"""see set_code_viewer_is_source()
"""
CDVH_LINES_CLICK = _ida_kernwin.CDVH_LINES_CLICK
"""see code_viewer_lines_click_t
"""
CDVH_LINES_DBLCLICK = _ida_kernwin.CDVH_LINES_DBLCLICK
"""see code_viewer_lines_click_t
"""
CDVH_LINES_POPUP = _ida_kernwin.CDVH_LINES_POPUP
"""see code_viewer_lines_click_t
"""
CDVH_LINES_DRAWICON = _ida_kernwin.CDVH_LINES_DRAWICON
"""see code_viewer_lines_icon_t
"""
CDVH_LINES_LINENUM = _ida_kernwin.CDVH_LINES_LINENUM
"""see code_viewer_lines_linenum_t
"""
CDVH_LINES_ICONMARGIN = _ida_kernwin.CDVH_LINES_ICONMARGIN
"""see set_code_viewer_lines_icon_margin()
"""
CDVH_LINES_RADIX = _ida_kernwin.CDVH_LINES_RADIX
"""see set_code_viewer_lines_radix()
"""
CDVH_LINES_ALIGNMENT = _ida_kernwin.CDVH_LINES_ALIGNMENT
"""see set_code_viewer_lines_alignment()
"""
VES_SHIFT = _ida_kernwin.VES_SHIFT
"""state & 1 => Shift is pressed 
state & 2 => Alt is pressed 
state & 4 => Ctrl is pressed 
state & 8 => Mouse left button is pressed 
state & 16 => Mouse right button is pressed 
state & 32 => Mouse middle button is pressed 
state & 128 => Meta is pressed (OSX only) 
        """
VES_ALT = _ida_kernwin.VES_ALT
VES_CTRL = _ida_kernwin.VES_CTRL
VES_MOUSE_LEFT = _ida_kernwin.VES_MOUSE_LEFT
VES_MOUSE_RIGHT = _ida_kernwin.VES_MOUSE_RIGHT
VES_MOUSE_MIDDLE = _ida_kernwin.VES_MOUSE_MIDDLE
VES_META = _ida_kernwin.VES_META
msg_activated = _ida_kernwin.msg_activated
"""The message window is activated. 
          """
msg_deactivated = _ida_kernwin.msg_deactivated
"""The message window is deactivated. 
          """
msg_click = _ida_kernwin.msg_click
"""Click event. 
          """
msg_dblclick = _ida_kernwin.msg_dblclick
"""Double click event. 
          """
msg_closed = _ida_kernwin.msg_closed
"""View closed. 
          """
msg_keydown = _ida_kernwin.msg_keydown
"""Key down event. 
          """


class renderer_pos_info_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _ida_kernwin.renderer_pos_info_t_swiginit(self, _ida_kernwin.
            new_renderer_pos_info_t())
    node: 'int' = property(_ida_kernwin.renderer_pos_info_t_node_get,
        _ida_kernwin.renderer_pos_info_t_node_set)
    """the node, or -1 if the current renderer is not a graph renderer. 
        """
    cx: 'short' = property(_ida_kernwin.renderer_pos_info_t_cx_get,
        _ida_kernwin.renderer_pos_info_t_cx_set)
    """the X coords of the character in the current line. When in graph mode: X coords of the character in 'node'. 
When in flat mode: X coords of the character in the line, w/o 
taking scrolling into consideration. 
        """
    cy: 'short' = property(_ida_kernwin.renderer_pos_info_t_cy_get,
        _ida_kernwin.renderer_pos_info_t_cy_set)
    """the Y coords of the character. When in graph mode: Y coords of the character in 'node'. 
When in flat mode: Line number, starting from the top. 
        """
    sx: 'short' = property(_ida_kernwin.renderer_pos_info_t_sx_get,
        _ida_kernwin.renderer_pos_info_t_sx_set)
    """the number of chars that are scrolled (flat mode only)
"""

    def __eq__(self, r: 'renderer_pos_info_t') ->bool:
        return _ida_kernwin.renderer_pos_info_t___eq__(self, r)

    def __ne__(self, r: 'renderer_pos_info_t') ->bool:
        return _ida_kernwin.renderer_pos_info_t___ne__(self, r)
    __swig_destroy__ = _ida_kernwin.delete_renderer_pos_info_t


_ida_kernwin.renderer_pos_info_t_swigregister(renderer_pos_info_t)


class view_mouse_event_location_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    ea: 'ea_t' = property(_ida_kernwin.view_mouse_event_location_t_ea_get,
        _ida_kernwin.view_mouse_event_location_t_ea_set)
    """flat view (rtype == TCCRT_FLAT)
"""
    item: 'selection_item_t const *' = property(_ida_kernwin.
        view_mouse_event_location_t_item_get, _ida_kernwin.
        view_mouse_event_location_t_item_set)
    """graph views (rtype != TCCRT_FLAT). nullptr if mouse is not currently over an item. 
        """

    def __init__(self):
        _ida_kernwin.view_mouse_event_location_t_swiginit(self,
            _ida_kernwin.new_view_mouse_event_location_t())
    __swig_destroy__ = _ida_kernwin.delete_view_mouse_event_location_t


_ida_kernwin.view_mouse_event_location_t_swigregister(
    view_mouse_event_location_t)


class view_mouse_event_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    rtype: 'tcc_renderer_type_t' = property(_ida_kernwin.
        view_mouse_event_t_rtype_get, _ida_kernwin.view_mouse_event_t_rtype_set
        )
    """type of renderer that received the event
"""
    x: 'uint32' = property(_ida_kernwin.view_mouse_event_t_x_get,
        _ida_kernwin.view_mouse_event_t_x_set)
    """screen x coordinate
"""
    y: 'uint32' = property(_ida_kernwin.view_mouse_event_t_y_get,
        _ida_kernwin.view_mouse_event_t_y_set)
    """screen y coordinate
"""
    location: 'view_mouse_event_t::location_t' = property(_ida_kernwin.
        view_mouse_event_t_location_get, _ida_kernwin.
        view_mouse_event_t_location_set)
    """location where event was generated
"""
    state: 'view_event_state_t' = property(_ida_kernwin.
        view_mouse_event_t_state_get, _ida_kernwin.view_mouse_event_t_state_set
        )
    """contains information about what buttons are CURRENTLY pressed on the keyboard and mouse. view_mouse_event_t instances created in functions like mouseReleaseEvent() won't contain any information about the mouse, because it has been released. 
        """
    button: 'vme_button_t' = property(_ida_kernwin.
        view_mouse_event_t_button_get, _ida_kernwin.
        view_mouse_event_t_button_set)
    """represents which mouse button was responsible for generating the event. This field does not care about the current state of the mouse. 
        """
    renderer_pos: 'renderer_pos_info_t' = property(_ida_kernwin.
        view_mouse_event_t_renderer_pos_get, _ida_kernwin.
        view_mouse_event_t_renderer_pos_set)
    """position where event was generated, relative to the renderer
"""

    def __init__(self):
        _ida_kernwin.view_mouse_event_t_swiginit(self, _ida_kernwin.
            new_view_mouse_event_t())
    __swig_destroy__ = _ida_kernwin.delete_view_mouse_event_t


_ida_kernwin.view_mouse_event_t_swigregister(view_mouse_event_t)
view_activated = _ida_kernwin.view_activated
"""A view is activated 
          """
view_deactivated = _ida_kernwin.view_deactivated
"""A view is deactivated 
          """
view_keydown = _ida_kernwin.view_keydown
"""Key down event 
          """
view_click = _ida_kernwin.view_click
"""Click event 
          """
view_dblclick = _ida_kernwin.view_dblclick
"""Double click event 
          """
view_curpos = _ida_kernwin.view_curpos
"""Cursor position changed 
          """
view_created = _ida_kernwin.view_created
"""A view is being created. 
          """
view_close = _ida_kernwin.view_close
"""View closed 
          """
view_switched = _ida_kernwin.view_switched
"""A view's renderer has changed. 
          """
view_mouse_over = _ida_kernwin.view_mouse_over
"""The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
          """
view_loc_changed = _ida_kernwin.view_loc_changed
"""The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
          """
view_mouse_moved = _ida_kernwin.view_mouse_moved
"""The mouse moved on the view 
          """
iek_unknown = _ida_kernwin.iek_unknown
iek_shortcut = _ida_kernwin.iek_shortcut
iek_key_press = _ida_kernwin.iek_key_press
iek_key_release = _ida_kernwin.iek_key_release
iek_mouse_button_press = _ida_kernwin.iek_mouse_button_press
iek_mouse_button_release = _ida_kernwin.iek_mouse_button_release
iek_mouse_wheel = _ida_kernwin.iek_mouse_wheel


class input_event_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    cb: 'int' = property(_ida_kernwin.input_event_t_cb_get, _ida_kernwin.
        input_event_t_cb_set)
    """size marker
"""
    kind: 'input_event_kind_t' = property(_ida_kernwin.
        input_event_t_kind_get, _ida_kernwin.input_event_t_kind_set)
    """the kind of event
"""
    modifiers: 'input_event_modifiers_t' = property(_ida_kernwin.
        input_event_t_modifiers_get, _ida_kernwin.input_event_t_modifiers_set)
    """current keyboard (and mouse) modifiers
"""
    target: 'TWidget *' = property(_ida_kernwin.input_event_t_target_get,
        _ida_kernwin.input_event_t_target_set)
    """the target widget
"""
    source: 'void *' = property(_ida_kernwin.input_event_t_source_get,
        _ida_kernwin.input_event_t_source_set)
    """the source event, should it be required for detailed inform (e.g., a QEvent in the GUI version of IDA)
"""
    shortcut: 'input_event_t::input_event_shortcut_data_t' = property(
        _ida_kernwin.input_event_t_shortcut_get, _ida_kernwin.
        input_event_t_shortcut_set)
    keyboard: 'input_event_t::input_event_keyboard_data_t' = property(
        _ida_kernwin.input_event_t_keyboard_get, _ida_kernwin.
        input_event_t_keyboard_set)
    mouse: 'input_event_t::input_event_mouse_data_t' = property(_ida_kernwin
        .input_event_t_mouse_get, _ida_kernwin.input_event_t_mouse_set)

    def __init__(self):
        _ida_kernwin.input_event_t_swiginit(self, _ida_kernwin.
            new_input_event_t())

    def _source_as_size(self) ->'size_t':
        return _ida_kernwin.input_event_t__source_as_size(self)

    def _target_as_size(self) ->'size_t':
        return _ida_kernwin.input_event_t__target_as_size(self)

    def get_source_QEvent(self):
        ptr = self._source_as_size()
        if ptr:
            from PyQt5 import sip
            if self.kind in [iek_key_press, iek_key_release]:
                from PyQt5.QtGui import QInputEvent
                return sip.wrapinstance(ptr, QInputEvent)
            elif self.kind in [iek_mouse_button_press, iek_mouse_button_release
                ]:
                from PyQt5.QtGui import QMouseEvent
                return sip.wrapinstance(ptr, QMouseEvent)
            elif self.kind == iek_mouse_wheel:
                from PyQt5.QtGui import QWheelEvent
                return sip.wrapinstance(ptr, QWheelEvent)
            else:
                from PyQt5.QtCore import QEvent
                return sip.wrapinstance(ptr, QEvent)

    def get_target_QWidget(self):
        ptr = self._target_as_size()
        if ptr:
            from PyQt5 import sip
            from PyQt5.QtWidgets import QWidget, QAbstractScrollArea
            return sip.wrapinstance(ptr, QWidget)
    __swig_destroy__ = _ida_kernwin.delete_input_event_t


_ida_kernwin.input_event_t_swigregister(input_event_t)


class input_event_shortcut_data_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    action_name: 'char const *' = property(_ida_kernwin.
        input_event_shortcut_data_t_action_name_get, _ida_kernwin.
        input_event_shortcut_data_t_action_name_set)

    def __init__(self):
        _ida_kernwin.input_event_shortcut_data_t_swiginit(self,
            _ida_kernwin.new_input_event_shortcut_data_t())
    __swig_destroy__ = _ida_kernwin.delete_input_event_shortcut_data_t


_ida_kernwin.input_event_shortcut_data_t_swigregister(
    input_event_shortcut_data_t)


class input_event_keyboard_data_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    key: 'int' = property(_ida_kernwin.input_event_keyboard_data_t_key_get,
        _ida_kernwin.input_event_keyboard_data_t_key_set)
    text: 'char [8]' = property(_ida_kernwin.
        input_event_keyboard_data_t_text_get, _ida_kernwin.
        input_event_keyboard_data_t_text_set)

    def __init__(self):
        _ida_kernwin.input_event_keyboard_data_t_swiginit(self,
            _ida_kernwin.new_input_event_keyboard_data_t())
    __swig_destroy__ = _ida_kernwin.delete_input_event_keyboard_data_t


_ida_kernwin.input_event_keyboard_data_t_swigregister(
    input_event_keyboard_data_t)


class input_event_mouse_data_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    x: 'int' = property(_ida_kernwin.input_event_mouse_data_t_x_get,
        _ida_kernwin.input_event_mouse_data_t_x_set)
    y: 'int' = property(_ida_kernwin.input_event_mouse_data_t_y_get,
        _ida_kernwin.input_event_mouse_data_t_y_set)
    button: 'vme_button_t' = property(_ida_kernwin.
        input_event_mouse_data_t_button_get, _ida_kernwin.
        input_event_mouse_data_t_button_set)

    def __init__(self):
        _ida_kernwin.input_event_mouse_data_t_swiginit(self, _ida_kernwin.
            new_input_event_mouse_data_t())
    __swig_destroy__ = _ida_kernwin.delete_input_event_mouse_data_t


_ida_kernwin.input_event_mouse_data_t_swigregister(input_event_mouse_data_t)
MFF_FAST = _ida_kernwin.MFF_FAST
"""Execute code as soon as possible. this mode is ok for calling ui related functions that do not query the database. 
        """
MFF_READ = _ida_kernwin.MFF_READ
"""Execute code only when ida is idle and it is safe to query the database. This mode is recommended only for code that does not modify the database. (nb: ida may be in the middle of executing another user request, for example it may be waiting for him to enter values into a modal dialog box) 
        """
MFF_WRITE = _ida_kernwin.MFF_WRITE
"""Execute code only when ida is idle and it is safe to modify the database. in particular, this flag will suspend execution if there is a modal dialog box on the screen. this mode can be used to call any ida api function. MFF_WRITE implies MFF_READ 
        """
MFF_NOWAIT = _ida_kernwin.MFF_NOWAIT
"""Do not wait for the request to be executed. the caller should ensure that the request is not destroyed until the execution completes. if not, the request will be ignored. the request must be created using the 'new' operator to use it with this flag. it can be used in cancel_exec_request(). This flag can be used to delay the code execution until the next UI loop run even from the main thread. 
        """


class ui_requests_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _ida_kernwin.ui_requests_t_swiginit(self, _ida_kernwin.
            new_ui_requests_t())
    __swig_destroy__ = _ida_kernwin.delete_ui_requests_t


_ida_kernwin.ui_requests_t_swigregister(ui_requests_t)
UIJMP_ACTIVATE = _ida_kernwin.UIJMP_ACTIVATE
"""activate the new window
"""
UIJMP_DONTPUSH = _ida_kernwin.UIJMP_DONTPUSH
"""do not remember the current address in the navigation history 
        """
UIJMP_VIEWMASK = _ida_kernwin.UIJMP_VIEWMASK
UIJMP_ANYVIEW = _ida_kernwin.UIJMP_ANYVIEW
"""jump in any ea_t-capable view
"""
UIJMP_IDAVIEW = _ida_kernwin.UIJMP_IDAVIEW
"""jump in idaview
"""
UIJMP_IDAVIEW_NEW = _ida_kernwin.UIJMP_IDAVIEW_NEW
"""jump in new idaview
"""


class action_ctx_base_cur_sel_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    _from: 'twinpos_t' = property(_ida_kernwin.
        action_ctx_base_cur_sel_t__from_get, _ida_kernwin.
        action_ctx_base_cur_sel_t__from_set)
    to: 'twinpos_t' = property(_ida_kernwin.
        action_ctx_base_cur_sel_t_to_get, _ida_kernwin.
        action_ctx_base_cur_sel_t_to_set)
    """end of selection
"""

    def __init__(self):
        _ida_kernwin.action_ctx_base_cur_sel_t_swiginit(self, _ida_kernwin.
            new_action_ctx_base_cur_sel_t())

    def reset(self) ->None:
        return _ida_kernwin.action_ctx_base_cur_sel_t_reset(self)
    __swig_destroy__ = _ida_kernwin.delete_action_ctx_base_cur_sel_t


_ida_kernwin.action_ctx_base_cur_sel_t_swigregister(action_ctx_base_cur_sel_t)


class action_ctx_base_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _ida_kernwin.action_ctx_base_t_swiginit(self, _ida_kernwin.
            new_action_ctx_base_t())

    def reset(self) ->None:
        """Invalidate all context info.
"""
        return _ida_kernwin.action_ctx_base_t_reset(self)
    widget: 'TWidget *' = property(_ida_kernwin.
        action_ctx_base_t_widget_get, _ida_kernwin.action_ctx_base_t_widget_set
        )
    widget_type: 'twidget_type_t' = property(_ida_kernwin.
        action_ctx_base_t_widget_type_get, _ida_kernwin.
        action_ctx_base_t_widget_type_set)
    """type of current widget
"""
    widget_title: 'qstring' = property(_ida_kernwin.
        action_ctx_base_t_widget_title_get, _ida_kernwin.
        action_ctx_base_t_widget_title_set)
    """title of current widget
"""
    chooser: 'chooser_base_t *' = property(_ida_kernwin.
        action_ctx_base_t_chooser_get, _ida_kernwin.
        action_ctx_base_t_chooser_set)
    """the underlying chooser_base_t (if 'widget' is a chooser widget)
"""
    chooser_selection: 'sizevec_t' = property(_ida_kernwin.
        action_ctx_base_t_chooser_selection_get, _ida_kernwin.
        action_ctx_base_t_chooser_selection_set)
    """current chooser selection (0-based)
"""
    action: 'char const *' = property(_ida_kernwin.
        action_ctx_base_t_action_get, _ida_kernwin.action_ctx_base_t_action_set
        )
    """action name
"""
    cur_flags: 'uint32' = property(_ida_kernwin.
        action_ctx_base_t_cur_flags_get, _ida_kernwin.
        action_ctx_base_t_cur_flags_set)
    """Current address information. see Action context property bits.
"""

    def has_flag(self, flag: int) ->bool:
        """Check if the given flag is set.
"""
        return _ida_kernwin.action_ctx_base_t_has_flag(self, flag)
    cur_ea: 'ea_t' = property(_ida_kernwin.action_ctx_base_t_cur_ea_get,
        _ida_kernwin.action_ctx_base_t_cur_ea_set)
    """the current EA of the position in the view
"""
    cur_value: 'uval_t' = property(_ida_kernwin.
        action_ctx_base_t_cur_value_get, _ida_kernwin.
        action_ctx_base_t_cur_value_set)
    """the possible address, or value the cursor is positioned on
"""
    cur_func: 'func_t *' = property(_ida_kernwin.
        action_ctx_base_t_cur_func_get, _ida_kernwin.
        action_ctx_base_t_cur_func_set)
    """the current function
"""
    cur_fchunk: 'func_t *' = property(_ida_kernwin.
        action_ctx_base_t_cur_fchunk_get, _ida_kernwin.
        action_ctx_base_t_cur_fchunk_set)
    """the current function chunk
"""
    cur_seg: 'segment_t *' = property(_ida_kernwin.
        action_ctx_base_t_cur_seg_get, _ida_kernwin.
        action_ctx_base_t_cur_seg_set)
    """the current segment
"""
    cur_sel: 'action_ctx_base_cur_sel_t' = property(_ida_kernwin.
        action_ctx_base_t_cur_sel_get, _ida_kernwin.
        action_ctx_base_t_cur_sel_set)
    """the currently selected range. also see ACF_HAS_SELECTION
"""
    regname: 'char const *' = property(_ida_kernwin.
        action_ctx_base_t_regname_get, _ida_kernwin.
        action_ctx_base_t_regname_set)
    """register name (if widget_type == BWN_CPUREGS and context menu opened on register)
"""
    focus: 'TWidget *' = property(_ida_kernwin.action_ctx_base_t_focus_get,
        _ida_kernwin.action_ctx_base_t_focus_set)
    """The focused widget in case it is not the 'form' itself (e.g., the 'quick filter' input in choosers.)
"""
    graph: 'interactive_graph_t *' = property(_ida_kernwin.
        action_ctx_base_t_graph_get, _ida_kernwin.action_ctx_base_t_graph_set)
    """the current graph (if in a graph view)
"""
    graph_selection: 'screen_graph_selection_t *' = property(_ida_kernwin.
        action_ctx_base_t_graph_selection_get, _ida_kernwin.
        action_ctx_base_t_graph_selection_set)
    """the current graph selection (if in a graph view)
"""
    hovered: 'selection_item_t const *' = property(_ida_kernwin.
        action_ctx_base_t_hovered_get, _ida_kernwin.
        action_ctx_base_t_hovered_set)
    """the current item being hovered (if in a graph view)
"""
    dirtree_selection: 'dirtree_selection_t *' = property(_ida_kernwin.
        action_ctx_base_t_dirtree_selection_get, _ida_kernwin.
        action_ctx_base_t_dirtree_selection_set)
    """the current dirtree_t selection (if applicable)
"""
    type_ref: 'til_type_ref_t *' = property(_ida_kernwin.
        action_ctx_base_t_type_ref_get, _ida_kernwin.
        action_ctx_base_t_type_ref_set)
    """a reference to the current type (if 'widget' is a type listing widget; nullptr otherwise)
"""
    cur_extracted_ea = cur_value
    form = ida_idaapi._make_missed_695bwcompat_property('form', 'widget',
        has_setter=False)
    form_type = ida_idaapi._make_missed_695bwcompat_property('form_type',
        'widget_type', has_setter=False)
    form_title = ida_idaapi._make_missed_695bwcompat_property('form_title',
        'widget_title', has_setter=False)
    __swig_destroy__ = _ida_kernwin.delete_action_ctx_base_t


_ida_kernwin.action_ctx_base_t_swigregister(action_ctx_base_t)
ACF_HAS_SELECTION = _ida_kernwin.ACF_HAS_SELECTION
"""there is currently a valid selection
"""
ACF_XTRN_EA = _ida_kernwin.ACF_XTRN_EA
"""cur_ea is in 'externs' segment
"""
ACF_HAS_FIELD_DIRTREE_SELECTION = _ida_kernwin.ACF_HAS_FIELD_DIRTREE_SELECTION
"""'dirtree_selection' field is present
"""
ACF_HAS_SOURCE = _ida_kernwin.ACF_HAS_SOURCE
"""'source' field is present
"""
ACF_HAS_TYPE_REF = _ida_kernwin.ACF_HAS_TYPE_REF
"""'type_ref' field is present
"""
AHF_VERSION = _ida_kernwin.AHF_VERSION
"""action handler version (used by action_handler_t::flags)
"""
AHF_VERSION_MASK = _ida_kernwin.AHF_VERSION_MASK
"""mask for action_handler_t::flags
"""


class action_desc_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    cb: 'int' = property(_ida_kernwin.action_desc_t_cb_get, _ida_kernwin.
        action_desc_t_cb_set)
    """size of this structure
"""
    name: 'char const *' = property(_ida_kernwin.action_desc_t_name_get,
        _ida_kernwin.action_desc_t_name_set)
    """the internal name of the action; must be unique. a way to reduce possible conflicts is to prefix it with some specific prefix. E.g., "myplugin:doSthg". 
        """
    label: 'char const *' = property(_ida_kernwin.action_desc_t_label_get,
        _ida_kernwin.action_desc_t_label_set)
    """the label of the action, possibly with an accelerator key definition (e.g., "~J~ump to operand") 
        """
    owner: 'void const *' = property(_ida_kernwin.action_desc_t_owner_get,
        _ida_kernwin.action_desc_t_owner_set)
    """either the plugin_t, or plugmod_t responsible for registering the action. Can be nullptr Please see ACTION_DESC_LITERAL_PLUGMOD 
        """
    shortcut: 'char const *' = property(_ida_kernwin.
        action_desc_t_shortcut_get, _ida_kernwin.action_desc_t_shortcut_set)
    """an optional shortcut definition. E.g., "Ctrl+Enter\"
"""
    tooltip: 'char const *' = property(_ida_kernwin.
        action_desc_t_tooltip_get, _ida_kernwin.action_desc_t_tooltip_set)
    """an optional tooltip for the action
"""
    icon: 'int' = property(_ida_kernwin.action_desc_t_icon_get,
        _ida_kernwin.action_desc_t_icon_set)
    """an optional icon ID to use
"""
    flags: 'int' = property(_ida_kernwin.action_desc_t_flags_get,
        _ida_kernwin.action_desc_t_flags_set)
    """See Action flags.
"""

    def __init__(self, name: str, label: str, handler: 'PyObject *',
        shortcut: str=None, tooltip: str=None, icon: int=-1, flags: int=0):
        _ida_kernwin.action_desc_t_swiginit(self, _ida_kernwin.
            new_action_desc_t(name, label, handler, shortcut, tooltip, icon,
            flags))
    __swig_destroy__ = _ida_kernwin.delete_action_desc_t


_ida_kernwin.action_desc_t_swigregister(action_desc_t)
ADF_OWN_HANDLER = _ida_kernwin.ADF_OWN_HANDLER
"""handler is owned by the action; it'll be destroyed when the action is unregistered. Use DYNACTION_DESC_LITERAL to set this bit. 
        """
ADF_NO_UNDO = _ida_kernwin.ADF_NO_UNDO
"""the action does not create an undo point. useful for actions that do not modify the database. 
        """
ADF_OT_MASK = _ida_kernwin.ADF_OT_MASK
"""Owner type mask.
"""
ADF_OT_PLUGIN = _ida_kernwin.ADF_OT_PLUGIN
"""Owner is a plugin_t.
"""
ADF_OT_PLUGMOD = _ida_kernwin.ADF_OT_PLUGMOD
"""Owner is a plugmod_t.
"""
ADF_OT_PROCMOD = _ida_kernwin.ADF_OT_PROCMOD
"""Owner is a procmod_t.
"""
ADF_GLOBAL = _ida_kernwin.ADF_GLOBAL
"""Register the action globally, so that it's available even if no IDB is present 
        """
ADF_NO_HIGHLIGHT = _ida_kernwin.ADF_NO_HIGHLIGHT
"""After activating, do not update the highlight according to what's under the cursor (listings only.) 
        """
ADF_CHECKABLE = _ida_kernwin.ADF_CHECKABLE
"""action is checkable
"""
ADF_CHECKED = _ida_kernwin.ADF_CHECKED
"""starts in a checked state (requires ADF_CHECKABLE)
"""
AA_NONE = _ida_kernwin.AA_NONE
"""no effect
"""
AA_LABEL = _ida_kernwin.AA_LABEL
"""see update_action_label()
"""
AA_SHORTCUT = _ida_kernwin.AA_SHORTCUT
"""see update_action_shortcut()
"""
AA_TOOLTIP = _ida_kernwin.AA_TOOLTIP
"""see update_action_tooltip()
"""
AA_ICON = _ida_kernwin.AA_ICON
"""see update_action_icon()
"""
AA_STATE = _ida_kernwin.AA_STATE
"""see update_action_state()
"""
AA_CHECKABLE = _ida_kernwin.AA_CHECKABLE
"""see update_action_checkable()
"""
AA_CHECKED = _ida_kernwin.AA_CHECKED
"""see update_action_checked()
"""
AA_VISIBILITY = _ida_kernwin.AA_VISIBILITY
"""see update_action_visibility()
"""


def cancel_exec_request(req_id: int) ->bool:
    """Try to cancel an asynchronous exec request (::ui_cancel_exec_request). 
        
@param req_id: request id
@retval true: successfully canceled
@retval false: request has already been processed."""
    return _ida_kernwin.cancel_exec_request(req_id)


def cancel_thread_exec_requests(tid: '__qthread_t') ->int:
    """Try to cancel asynchronous exec requests created by the specified thread. 
        
@param tid: thread id
@returns number of the canceled requests."""
    return _ida_kernwin.cancel_thread_exec_requests(tid)


def set_execute_sync_availability(tid: '__qthread_t', availability:
    'execute_sync_availability_t') ->'execute_sync_availability_t':
    """Set the availability of the execute_sync functionality for the given thread
Setting it to `esa_unavailable` will cause the existing requests for this thread to be cancelled. Setting it to `esa_release` will clear the status for this thread, and should be issued right before a call to `qthread_free` is issued.

@param tid: thread id
@param availability: the availability
@returns the previous availability"""
    return _ida_kernwin.set_execute_sync_availability(tid, availability)


def get_synced_group(w: 'TWidget const *') ->'synced_group_t const *':
    """Get the group of widgets/registers this view is synchronized with 
        
@param w: the widget
@returns the group of widgets/registers, or nullptr"""
    return _ida_kernwin.get_synced_group(w)


def banner(wait: int) ->bool:
    """Show a banner dialog box (ui_banner). 
        
@param wait: time to wait before closing
@retval 1: ok
@retval 0: esc was pressed"""
    return _ida_kernwin.banner(wait)


def is_msg_inited() ->bool:
    """Can we use msg() functions?
"""
    return _ida_kernwin.is_msg_inited()


def refresh_idaview() ->None:
    """Refresh marked windows (ui_refreshmarked)
"""
    return _ida_kernwin.refresh_idaview()


def refresh_idaview_anyway() ->None:
    """Refresh all disassembly views (ui_refresh), forces an immediate refresh. Please consider request_refresh() instead 
        """
    return _ida_kernwin.refresh_idaview_anyway()


def analyzer_options() ->None:
    """Allow the user to set analyzer options. (show a dialog box) (ui_analyzer_options)
"""
    return _ida_kernwin.analyzer_options()


def get_screen_ea() ->ida_idaapi.ea_t:
    """Get the address at the screen cursor (ui_screenea)
"""
    return _ida_kernwin.get_screen_ea()


def get_opnum() ->int:
    """Get current operand number, -1 means no operand (ui_get_opnum)
"""
    return _ida_kernwin.get_opnum()


def get_cursor() ->'int *, int *':
    """Get the cursor position on the screen (ui_get_cursor). 
        
@retval true: pointers are filled
@retval false: no disassembly window open"""
    return _ida_kernwin.get_cursor()


def get_output_cursor() ->'int *, int *':
    """Get coordinates of the output window's cursor (ui_get_output_cursor). 
        
@retval false: the output window has been destroyed.
@retval true: pointers are filled"""
    return _ida_kernwin.get_output_cursor()


def get_curline() ->str:
    """Get current line from the disassemble window (ui_get_curline). 
        
@returns cptr current line with the color codes (use tag_remove() to remove the color codes)"""
    return _ida_kernwin.get_curline()


def open_url(url: str) ->None:
    """Open the given url (ui_open_url)
"""
    return _ida_kernwin.open_url(url)


def get_hexdump_ea(hexdump_num: int) ->ida_idaapi.ea_t:
    """Get the current address in a hex view. 
        
@param hexdump_num: number of hexview window"""
    return _ida_kernwin.get_hexdump_ea(hexdump_num)


def get_key_code(keyname: str) ->'ushort':
    """Get keyboard key code by its name (ui_get_key_code)
"""
    return _ida_kernwin.get_key_code(keyname)


def lookup_key_code(key: int, shift: int, is_qt: bool) ->'ushort':
    """Get shortcut code previously created by ui_get_key_code. 
        
@param key: key constant
@param shift: modifiers
@param is_qt: are we using gui version?"""
    return _ida_kernwin.lookup_key_code(key, shift, is_qt)


def refresh_navband(force: bool) ->None:
    """Refresh navigation band if changed (ui_refresh_navband). 
        
@param force: refresh regardless"""
    return _ida_kernwin.refresh_navband(force)


def refresh_chooser(title: str) ->bool:
    """Mark a non-modal custom chooser for a refresh (ui_refresh_chooser). 
        
@param title: title of chooser
@returns success"""
    return _ida_kernwin.refresh_chooser(title)


def close_chooser(title: str) ->bool:
    """Close a non-modal chooser (ui_close_chooser). 
        
@param title: window title of chooser to close
@returns success"""
    return _ida_kernwin.close_chooser(title)


def set_dock_pos(src_ctrl, dest_ctrl, orient, left=0, top=0, right=0, bottom=0
    ):
    """Sets the dock orientation of a window relatively to another window.

Use the left, top, right, bottom parameters if DP_FLOATING is used,
or if you want to specify the width of docked windows.

@param src_ctrl: Source docking control
@param dest_ctrl: Destination docking control
@param orient: One of DP_XXXX constants
@return: Boolean

Example:
    set_dock_pos('Structures', 'Enums', DP_RIGHT) <- docks the Structures window to the right of Enums window"""
    return _ida_kernwin.set_dock_pos(src_ctrl, dest_ctrl, orient, left, top,
        right, bottom)


def get_icon_id_by_name(icon_name: str) ->int:
    """Retrieve the id of the icon by name (ui_get_icon_id_by_name). 
        
@param icon_name: full name of the icon
@returns icon id"""
    return _ida_kernwin.get_icon_id_by_name(icon_name)


def free_custom_icon(icon_id):
    """Frees an icon loaded with load_custom_icon()

@param icon_id: The ID of the icon to free"""
    return _ida_kernwin.free_custom_icon(icon_id)


class __qtimer_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        _ida_kernwin.__qtimer_t_swiginit(self, _ida_kernwin.new___qtimer_t())
    __swig_destroy__ = _ida_kernwin.delete___qtimer_t


_ida_kernwin.__qtimer_t_swigregister(__qtimer_t)


def unregister_action(name: str) ->bool:
    """Delete a previously-registered action (ui_unregister_action). 
        
@param name: name of action
@returns success"""
    return _ida_kernwin.unregister_action(name)


def create_toolbar(name: str, label: str, before: str=None, flags: int=0
    ) ->bool:
    """Create a toolbar with the given name, label and optional position 
        
@param name: name of toolbar (must be unique)
@param label: label of toolbar
@param before: if non-nullptr, the toolbar before which the new toolbar will be inserted
@param flags: a combination of create toolbar flags, to determine toolbar position
@returns success"""
    return _ida_kernwin.create_toolbar(name, label, before, flags)


def delete_toolbar(name: str) ->bool:
    """Delete an existing toolbar 
        
@param name: name of toolbar
@returns success"""
    return _ida_kernwin.delete_toolbar(name)


def create_menu(name: str, label: str, menupath: str=None) ->bool:
    """Create a menu with the given name, label and optional position, either in the menubar, or as a submenu. If 'menupath' is non-nullptr, it provides information about where the menu should be positioned. First, IDA will try and resolve the corresponding menu by its name. If such an existing menu is found and is present in the menubar, then the new menu will be inserted in the menubar before it. Otherwise, IDA will try to resolve 'menupath' as it would for attach_action_to_menu() and, if found, add the new menu like so: 
     The new 'My menu' submenu will appear in the 'Comments' submenu
     before the 'Enter comment..." command
     "My menu", "Edit/Comments/Enter comment...");


     The new 'My menu' submenu will appear at the end of the
     'Comments' submenu.
     "My menu", "Edit/Comments/");


        
@param name: name of menu (must be unique)
@param label: label of menu
@param menupath: where should the menu be inserted
@returns success"""
    return _ida_kernwin.create_menu(name, label, menupath)


def delete_menu(name: str) ->bool:
    """Delete an existing menu 
        
@param name: name of menu
@returns success"""
    return _ida_kernwin.delete_menu(name)


def attach_action_to_menu(menupath: str, name: str, flags: int=0) ->bool:
    """Attach a previously-registered action to the menu (ui_attach_action_to_menu). 
        
@param menupath: path to the menu item after or before which the insertion will take place. 

* Example: Debug/StartProcess
* Whitespace, punctuation are ignored.
* It is allowed to specify only the prefix of the menu item.
* Comparison is case insensitive.
* menupath may start with the following prefixes:
* [S] - modify the main menu of the structure window
* [E] - modify the main menu of the enum window
@param name: the action name
@param flags: a combination of Set menu flags, to determine menu item position
@returns success"""
    return _ida_kernwin.attach_action_to_menu(menupath, name, flags)


def detach_action_from_menu(menupath: str, name: str) ->bool:
    """Detach an action from the menu (ui_detach_action_from_menu). 
        
@param menupath: path to the menu item
@param name: the action name
@returns success"""
    return _ida_kernwin.detach_action_from_menu(menupath, name)


def attach_action_to_toolbar(toolbar_name: str, name: str) ->bool:
    """Attach an action to an existing toolbar (ui_attach_action_to_toolbar). 
        
@param toolbar_name: the name of the toolbar
@param name: the action name
@returns success"""
    return _ida_kernwin.attach_action_to_toolbar(toolbar_name, name)


def detach_action_from_toolbar(toolbar_name: str, name: str) ->bool:
    """Detach an action from the toolbar (ui_detach_action_from_toolbar). 
        
@param toolbar_name: the name of the toolbar
@param name: the action name
@returns success"""
    return _ida_kernwin.detach_action_from_toolbar(toolbar_name, name)


def register_and_attach_to_menu(menupath: str, name: str, label: str,
    shortcut: str, flags: int, handler: 'action_handler_t *', owner:
    'void *', action_desc_t_flags: int) ->bool:
    """Helper.
You are not encouraged to use this, as it mixes flags for both register_action(), and attach_action_to_menu().
The only reason for its existence is to make it simpler to port existing plugins to the new actions API. 
        """
    return _ida_kernwin.register_and_attach_to_menu(menupath, name, label,
        shortcut, flags, handler, owner, action_desc_t_flags)


def display_widget(widget: 'TWidget *', options: int, dest_ctrl: str=None
    ) ->None:
    """Display a widget, dock it if not done before 
        
@param widget: widget to display
@param options: Widget open flags
@param dest_ctrl: where to dock: if nullptr or invalid then use the active docker if there is not create a new tab relative to current active tab"""
    return _ida_kernwin.display_widget(widget, options, dest_ctrl)


def close_widget(widget: 'TWidget *', options: int) ->None:
    """Close widget (ui_close_widget, only gui version). 
        
@param widget: pointer to the widget to close
@param options: Form close flags"""
    return _ida_kernwin.close_widget(widget, options)


def activate_widget(widget: 'TWidget *', take_focus: bool) ->None:
    """Activate widget (only gui version) (ui_activate_widget). 
        
@param widget: existing widget to display
@param take_focus: give focus to given widget"""
    return _ida_kernwin.activate_widget(widget, take_focus)


def find_widget(caption: str) ->'TWidget *':
    """Find widget with the specified caption (only gui version) (ui_find_widget). NB: this callback works only with the tabbed widgets! 
        
@param caption: title of tab, or window title if widget is not tabbed
@returns pointer to the TWidget, nullptr if none is found"""
    return _ida_kernwin.find_widget(caption)


def get_current_widget() ->'TWidget *':
    """Get a pointer to the current widget (ui_get_current_widget).
"""
    return _ida_kernwin.get_current_widget()


def get_widget_type(widget: 'TWidget *') ->'twidget_type_t':
    """Get the type of the TWidget * (ui_get_widget_type).
"""
    return _ida_kernwin.get_widget_type(widget)


def get_widget_title(widget: 'TWidget *') ->str:
    """Get the TWidget's title (ui_get_widget_title).
"""
    return _ida_kernwin.get_widget_title(widget)


def custom_viewer_jump(v: 'TWidget *', loc: 'lochist_entry_t const &',
    flags: int=0) ->bool:
    """Append 'loc' to the viewer's history, and cause the viewer to display it. 
        
@param v: (TWidget *)
@param loc: (const lochist_entry_t &)
@param flags: (uint32) or'ed combination of CVNF_* values
@returns success"""
    return _ida_kernwin.custom_viewer_jump(v, loc, flags)


def ea_viewer_history_push_and_jump(v: 'TWidget *', ea: ida_idaapi.ea_t, x:
    int, y: int, lnnum: int) ->bool:
    """Push current location in the history and jump to the given location (ui_ea_viewer_history_push_and_jump). This will jump in the given ea viewer and also in other synchronized views. 
        
@param v: ea viewer
@param ea: jump destination
@param x: coords on screen
@param y: coords on screen
@param lnnum: desired line number of given address"""
    return _ida_kernwin.ea_viewer_history_push_and_jump(v, ea, x, y, lnnum)


def get_ea_viewer_history_info(nback: 'int *', nfwd: 'int *', v: 'TWidget *'
    ) ->bool:
    """Get information about what's in the history (ui_ea_viewer_history_info). 
        
@param nback: number of available back steps
@param nfwd: number of available forward steps
@param v: ea viewer
@retval false: if the given ea viewer does not exist
@retval true: otherwise"""
    return _ida_kernwin.get_ea_viewer_history_info(nback, nfwd, v)


def refresh_custom_viewer(custom_viewer: 'TWidget *') ->None:
    """Refresh custom ida viewer (ui_refresh_custom_viewer)
"""
    return _ida_kernwin.refresh_custom_viewer(custom_viewer)


def repaint_custom_viewer(custom_viewer: 'TWidget *') ->None:
    """Repaint the given widget immediately (ui_repaint_qwidget)
"""
    return _ida_kernwin.repaint_custom_viewer(custom_viewer)


def jumpto(*args) ->bool:
    """This function has the following signatures:

    0. jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool
    1. jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool

# 0: jumpto(ea: ida_idaapi.ea_t, opnum: int=-1, uijmp_flags: int=UIJMP_ACTIVATE) -> bool

Jump to the specified address (ui_jumpto). 
        
@returns success

# 1: jumpto(custom_viewer: TWidget *, place: place_t *, x: int, y: int) -> bool

Set cursor position in custom ida viewer. 
        
@returns success
"""
    return _ida_kernwin.jumpto(*args)


def get_custom_viewer_place(custom_viewer: 'TWidget *', mouse: bool
    ) ->'int *, int *':
    """Get current place in a custom viewer (ui_get_curplace).
See also the more complete get_custom_viewer_location()

@param custom_viewer: view
@param mouse: mouse position (otherwise cursor position)"""
    return _ida_kernwin.get_custom_viewer_place(custom_viewer, mouse)


def get_custom_viewer_location(*args) ->bool:
    """Get information about the current location in a listing

This function has the following signatures:

    1. get_custom_viewer_location(out_entry: ida_moves.lochist_entry_t, widget: TWidget, mouse: bool=False) -> bool
    2. get_custom_viewer_location(out_entry: ida_kernwin.listing_location_t, widget: TWidget, flags: int=0) -> bool

The 2nd form is a superset of the 1st, and retrieves
the text (and tags) of the text."""
    return _ida_kernwin.get_custom_viewer_location(*args)


def is_idaq():
    """Returns True or False depending if IDAPython is hosted by IDAQ"""
    return _ida_kernwin.is_idaq()


def attach_action_to_popup(widget: 'TWidget *', popup_handle:
    'TPopupMenu *', name: str, popuppath: str=None, flags: int=0) ->bool:
    """Insert a previously-registered action into the widget's popup menu (ui_attach_action_to_popup). This function has two "modes": 'single-shot', and 'permanent'. 
        
@param widget: target widget
@param popup_handle: target popup menu
* if non-nullptr, the action is added to this popup menu invocation (i.e., 'single-shot')
* if nullptr, the action is added to a list of actions that should always be present in context menus for this widget (i.e., 'permanent'.)
@param name: action name
@param popuppath: can be nullptr
@param flags: a combination of SETMENU_ flags (see Set menu flags)
@returns success"""
    return _ida_kernwin.attach_action_to_popup(widget, popup_handle, name,
        popuppath, flags)


def detach_action_from_popup(widget: 'TWidget *', name: str) ->bool:
    """Remove a previously-registered action, from the list of 'permanent' context menu actions for this widget (ui_detach_action_from_popup). This only makes sense if the action has been added to 'widget's list of permanent popup actions by calling attach_action_to_popup in 'permanent' mode. 
        
@param widget: target widget
@param name: action name"""
    return _ida_kernwin.detach_action_from_popup(widget, name)


def update_action_label(name: str, label: str) ->bool:
    """Update an action's label (ui_update_action_attr). 
        
@param name: action name
@param label: new label
@returns success"""
    return _ida_kernwin.update_action_label(name, label)


def update_action_shortcut(name: str, shortcut: str) ->bool:
    """Update an action's shortcut (ui_update_action_attr). 
        
@param name: action name
@param shortcut: new shortcut
@returns success"""
    return _ida_kernwin.update_action_shortcut(name, shortcut)


def update_action_tooltip(name: str, tooltip: str) ->bool:
    """Update an action's tooltip (ui_update_action_attr). 
        
@param name: action name
@param tooltip: new tooltip
@returns success"""
    return _ida_kernwin.update_action_tooltip(name, tooltip)


def update_action_icon(name: str, icon: int) ->bool:
    """Update an action's icon (ui_update_action_attr). 
        
@param name: action name
@param icon: new icon id
@returns success"""
    return _ida_kernwin.update_action_icon(name, icon)


def update_action_state(name: str, state: 'action_state_t') ->bool:
    """Update an action's state (ui_update_action_attr). 
        
@param name: action name
@param state: new state
@returns success"""
    return _ida_kernwin.update_action_state(name, state)


def update_action_checkable(name: str, checkable: bool) ->bool:
    """Update an action's checkability (ui_update_action_attr). 
        
@param name: action name
@param checkable: new checkability
@returns success"""
    return _ida_kernwin.update_action_checkable(name, checkable)


def update_action_checked(name: str, checked: bool) ->bool:
    """Update an action's checked state (ui_update_action_attr). 
        
@param name: action name
@param checked: new checked state
@returns success"""
    return _ida_kernwin.update_action_checked(name, checked)


def update_action_visibility(name: str, visible: bool) ->bool:
    """Update an action's visibility (ui_update_action_attr). 
        
@param name: action name
@param visible: new visibility
@returns success"""
    return _ida_kernwin.update_action_visibility(name, visible)


def get_action_label(name: str) ->str:
    """Get an action's label (ui_get_action_attr). 
        
@param name: the action name
@returns success"""
    return _ida_kernwin.get_action_label(name)


def get_action_shortcut(name: str) ->str:
    """Get an action's shortcut (ui_get_action_attr). 
        
@param name: the action name
@returns success"""
    return _ida_kernwin.get_action_shortcut(name)


def get_action_tooltip(name: str) ->str:
    """Get an action's tooltip (ui_get_action_attr). 
        
@param name: the action name
@returns success"""
    return _ida_kernwin.get_action_tooltip(name)


def get_action_icon(name: str) ->'int *':
    """Get an action's icon (ui_get_action_attr). 
        
@param name: the action name
@returns success"""
    return _ida_kernwin.get_action_icon(name)


def get_action_state(name: str) ->'action_state_t *':
    """Get an action's state (ui_get_action_attr). 
        
@param name: the action name
@returns success"""
    return _ida_kernwin.get_action_state(name)


def get_action_checkable(name: str) ->'bool *':
    """Get an action's checkability (ui_get_action_attr). 
        
@param name: the action name
@returns success"""
    return _ida_kernwin.get_action_checkable(name)


def get_action_checked(name: str) ->'bool *':
    """Get an action's checked state (ui_get_action_attr). 
        
@param name: the action name
@returns success"""
    return _ida_kernwin.get_action_checked(name)


def get_action_visibility(name: str) ->'bool *':
    """Get an action's visibility (ui_get_action_attr). 
        
@param name: the action name
@returns success"""
    return _ida_kernwin.get_action_visibility(name)


def set_custom_viewer_qt_aware(custom_viewer: 'TWidget *') ->bool:
    """Allow the given viewer to interpret Qt events (ui_set_custom_viewer_handler)
"""
    return _ida_kernwin.set_custom_viewer_qt_aware(custom_viewer)


def get_custom_viewer_curline(custom_viewer: 'TWidget *', mouse: bool) ->str:
    """Get current line of custom viewer (ui_get_custom_viewer_curline). The returned line contains color codes
See also the more powerful get_custom_viewer_location()

@param custom_viewer: view
@param mouse: mouse position (otherwise cursor position)
@returns pointer to contents of current line"""
    return _ida_kernwin.get_custom_viewer_curline(custom_viewer, mouse)


def get_custom_viewer_place_xcoord(custom_viewer: 'TWidget *', pline:
    'place_t', pitem: 'place_t') ->int:
    """Get the X position of the item, in the line 
        
@param custom_viewer: the widget
@param pline: a place corresponding to the line
@param pitem: a place corresponding to the item
@retval -1: if 'pitem' is not included in the line
@retval -2: if 'pitem' points at the entire line
@retval >=: 0 for the X coordinate within the pline, where pitem points"""
    return _ida_kernwin.get_custom_viewer_place_xcoord(custom_viewer, pline,
        pitem)


def get_user_input_event(out: 'input_event_t') ->bool:
    """Get the current user input event (mouse button press, key press, ...) It is sometimes desirable to be able to tell when a certain situation happens (e.g., 'view_curpos' gets triggered); this function exists to provide that context (GUI version only) 
        
@param out: the input event data
@returns false if we are not currently processing a user input event"""
    return _ida_kernwin.get_user_input_event(out)


def get_output_curline(mouse: bool) ->str:
    """Get current line of output window (ui_get_output_curline). 
        
@param mouse: current for mouse pointer?
@returns false if output contains no text"""
    return _ida_kernwin.get_output_curline(mouse)


def get_output_selected_text() ->str:
    """Returns selected text from output window (ui_get_output_selected_text). 
        
@returns true if there is a selection"""
    return _ida_kernwin.get_output_selected_text()


def get_current_viewer() ->'TWidget *':
    """Get current ida viewer (idaview or custom viewer) (ui_get_current_viewer)
"""
    return _ida_kernwin.get_current_viewer()


def get_last_widget(*args) ->'TWidget *':
    """Get last ida viewer (idaview or custom viewer) (ui_get_last_widget) 
        
@param mask: an OR'ed set of IWID_* to limit the search to
@returns the viewer, if found"""
    return _ida_kernwin.get_last_widget(*args)


def prompt_function_prototype(out_tif: 'tinfo_t', pfn: 'func_t *', tif:
    'tinfo_t', name: str) ->str:
    """Open function prototype editor to edit function type and create new type. Allows to change the function prototype either in the "old" one-liner mode or in the new multi-line editor, which supports shortcuts, etc. Note: changes will not apply! It is the caller's job to apply the resulting out_tif. Parameters: 
        
@param out_tif: - (tinfo_t *) tif for created type
@param pfn: - (func_t *) editing function
@param tif: - (tinfo_t *) current function type
@param name: - (const char *) function name
@returns true if new type created successfully"""
    return _ida_kernwin.prompt_function_prototype(out_tif, pfn, tif, name)


def parse_tagged_line_sections(out: 'tagged_line_sections_t', line: str
    ) ->bool:
    """Collect tagged sections in a color-tagged line (produced by `place_t::generate`)

@param out: sections storage
@param line: input line
@returns success"""
    return _ida_kernwin.parse_tagged_line_sections(out, line)


def get_view_renderer_type(v: 'TWidget *') ->'tcc_renderer_type_t':
    """Get the type of renderer currently in use in the given view (ui_get_renderer_type)
"""
    return _ida_kernwin.get_view_renderer_type(v)


def set_view_renderer_type(v: 'TWidget *', rt: 'tcc_renderer_type_t') ->None:
    """Set the type of renderer to use in a view (ui_set_renderer_type)
"""
    return _ida_kernwin.set_view_renderer_type(v, rt)


def create_empty_widget(title: str, icon: int=-1) ->'TWidget *':
    """Create an empty widget, serving as a container for custom user widgets 
        """
    return _ida_kernwin.create_empty_widget(title, icon)


def msg_clear() ->None:
    """Clear the "Output" window.
"""
    return _ida_kernwin.msg_clear()


def msg_save(path: str) ->bool:
    """Save the "Output" window contents into a file 
        
@param path: The path of the file to save the contents into. An empty path means that the user will be prompted for the destination and, if the file already exists, the user will be asked to confirm before overriding its contents. Upon return, 'path' will contain the path that the user chose.
@returns success"""
    return _ida_kernwin.msg_save(path)


def get_active_modal_widget() ->'TWidget *':
    """Get the current, active modal TWidget instance. Note that in this context, the "wait dialog" is not considered: this function will return nullptr even if it is currently shown. 
        
@returns TWidget * the active modal widget, or nullptr"""
    return _ida_kernwin.get_active_modal_widget()


def get_navband_pixel(ea):
    """Maps an address, onto a pixel coordinate within the navigation band

@param ea: The address to map
@return: a list [pixel, is_vertical]"""
    return _ida_kernwin.get_navband_pixel(ea)


def get_navband_ea(pixel: int) ->ida_idaapi.ea_t:
    """Translate the pixel position on the navigation band, into an address.
"""
    return _ida_kernwin.get_navband_ea(pixel)


def get_window_id(name: str=None) ->'void *':
    """Get the system-specific window ID (GUI version only) 
        
@param name: name of the window (nullptr means the main IDA window)
@returns the low-level window ID"""
    return _ida_kernwin.get_window_id(name)


def is_idaview(v: 'TWidget *') ->bool:
    """Is the given custom view an idaview? (ui_is_idaview)
"""
    return _ida_kernwin.is_idaview(v)


def read_selection(v, p1, p2):
    """Read the user selection, and store its information in p1 (from) and p2 (to).

This can be used as follows:


>>> p1 = ida_kernwin.twinpos_t()
p2 = ida_kernwin.twinpos_t()
view = ida_kernwin.get_current_viewer()
ida_kernwin.read_selection(view, p1, p2)


At that point, p1 and p2 hold information for the selection.
But, the 'at' property of p1 and p2 is not properly typed.
To specialize it, call #place() on it, passing it the view
they were retrieved from. Like so:


>>> place0 = p1.place(view)
place1 = p2.place(view)


This will effectively "cast" the place into a specialized type,
holding proper information, depending on the view type (e.g.,
disassembly, structures, enums, ...)

@param v: The view to retrieve the selection for.
@param p1: Storage for the "from" part of the selection.
@param p2: Storage for the "to" part of the selection.
@return: a bool value indicating success."""
    return _ida_kernwin.read_selection(v, p1, p2)


def read_range_selection(v: 'TWidget *') ->'ea_t *, ea_t *':
    """Get the address range for the selected range boundaries, this is the convenient function for read_selection() 
        
@param v: view, nullptr means the last active window containing addresses
@retval 0: no range is selected
@retval 1: ok, start ea and end ea are filled"""
    return _ida_kernwin.read_range_selection(v)


def unmark_selection() ->None:
    """Unmark selection (ui_unmarksel)
"""
    return _ida_kernwin.unmark_selection()


def create_code_viewer(custview: 'TWidget *', flags: int=0, parent:
    'TWidget *'=None) ->'TWidget *':
    """Create a code viewer (ui_create_code_viewer). A code viewer contains on the left side a widget representing the line numbers, and on the right side, the child widget passed as parameter. It will inherit its title from the child widget.

@param custview: the custom view to be added
@param flags: Code viewer flags
@param parent: widget to contain the new code viewer"""
    return _ida_kernwin.create_code_viewer(custview, flags, parent)


def set_code_viewer_handler(code_viewer: 'TWidget *', handler_id:
    'custom_viewer_handler_id_t', handler_or_data: 'void *') ->'void *':
    """Set a handler for a code viewer event (ui_set_custom_viewer_handler). 
        
@param code_viewer: the code viewer
@param handler_id: one of CDVH_ in custom_viewer_handler_id_t
@param handler_or_data: can be a handler or data. see examples in Functions: custom viewer handlers
@returns old value of the handler or data"""
    return _ida_kernwin.set_code_viewer_handler(code_viewer, handler_id,
        handler_or_data)


def set_code_viewer_user_data(code_viewer: 'TWidget *', ud: 'void *') ->bool:
    """Set the user data on a code viewer (ui_set_custom_viewer_handler).
"""
    return _ida_kernwin.set_code_viewer_user_data(code_viewer, ud)


def get_viewer_user_data(viewer: 'TWidget *') ->'void *':
    """Get the user data from a custom viewer (ui_get_viewer_user_data)
"""
    return _ida_kernwin.get_viewer_user_data(viewer)


def get_viewer_place_type(viewer: 'TWidget *') ->'tcc_place_type_t':
    """Get the type of place_t instances a viewer uses & creates (ui_get_viewer_place_type).
"""
    return _ida_kernwin.get_viewer_place_type(viewer)


def set_code_viewer_line_handlers(code_viewer: 'TWidget *', click_handler:
    'code_viewer_lines_click_t *', popup_handler:
    'code_viewer_lines_click_t *', dblclick_handler:
    'code_viewer_lines_click_t *', drawicon_handler:
    'code_viewer_lines_icon_t *', linenum_handler:
    'code_viewer_lines_linenum_t *') ->None:
    """Set handlers for code viewer line events. Any of these handlers may be nullptr 
        """
    return _ida_kernwin.set_code_viewer_line_handlers(code_viewer,
        click_handler, popup_handler, dblclick_handler, drawicon_handler,
        linenum_handler)


def set_code_viewer_lines_icon_margin(code_viewer: 'TWidget *', margin: int
    ) ->bool:
    """Set space allowed for icons in the margin of a code viewer (ui_set_custom_viewer_handler).
"""
    return _ida_kernwin.set_code_viewer_lines_icon_margin(code_viewer, margin)


def set_code_viewer_lines_alignment(code_viewer: 'TWidget *', align: int
    ) ->bool:
    """Set alignment for lines in a code viewer (ui_set_custom_viewer_handler).
"""
    return _ida_kernwin.set_code_viewer_lines_alignment(code_viewer, align)


def set_code_viewer_lines_radix(code_viewer: 'TWidget *', radix: int) ->bool:
    """Set radix for values displayed in a code viewer (ui_set_custom_viewer_handler).
"""
    return _ida_kernwin.set_code_viewer_lines_radix(code_viewer, radix)


def set_code_viewer_is_source(code_viewer: 'TWidget *') ->bool:
    """Specify that the given code viewer is used to display source code (ui_set_custom_viewer_handler).
"""
    return _ida_kernwin.set_code_viewer_is_source(code_viewer)


def get_tab_size(path: str) ->int:
    """Get the size of a tab in spaces (ui_get_tab_size). 
        
@param path: the path of the source view for which the tab size is requested.
* if nullptr, the default size is returned."""
    return _ida_kernwin.get_tab_size(path)


def clr_cancelled() ->None:
    """Clear "Cancelled" flag (ui_clr_cancelled)
"""
    return _ida_kernwin.clr_cancelled()


def set_cancelled() ->None:
    """Set "Cancelled" flag (ui_set_cancelled)
"""
    return _ida_kernwin.set_cancelled()


def user_cancelled() ->bool:
    """Test the ctrl-break flag (ui_test_cancelled). 
        
@retval 1: Ctrl-Break is detected, a message is displayed
@retval 2: Ctrl-Break is detected again, a message is not displayed
@retval 0: Ctrl-Break is not detected"""
    return _ida_kernwin.user_cancelled()


def ui_load_new_file(temp_file: str, filename: str, pli: 'linput_t **',
    neflags: 'ushort', ploaders: 'load_info_t **') ->bool:
    """Display a load file dialog and load file (ui_load_file). 
        
@param temp_file: name of the file with the extracted archive member.
@param filename: the name of input file as is, library or archive name
@param pli: loader input source, may be changed to point to temp_file
@param neflags: combination of NEF_... bits (see Load file flags)
@param ploaders: list of loaders which accept file, may be changed for loaders of temp_file
@retval true: file was successfully loaded
@retval false: otherwise"""
    return _ida_kernwin.ui_load_new_file(temp_file, filename, pli, neflags,
        ploaders)


def ui_run_debugger(dbgopts: str, exename: str, argc: int, argv:
    'char const *const *') ->bool:
    """Load a debugger plugin and run the specified program (ui_run_dbg). 
        
@param dbgopts: value of the -r command line switch
@param exename: name of the file to run
@param argc: number of arguments for the executable
@param argv: argument vector
@returns success"""
    return _ida_kernwin.ui_run_debugger(dbgopts, exename, argc, argv)


def load_dbg_dbginfo(*args) ->bool:
    """Load debugging information from a file. 
        
@param path: path to file
@param li: loader input. if nullptr, check DBG_NAME_KEY
@param base: loading address
@param verbose: dump status to message window"""
    return _ida_kernwin.load_dbg_dbginfo(*args)


def add_idc_hotkey(hotkey: str, idcfunc: str) ->int:
    """Add hotkey for IDC function (ui_add_idckey). 
        
@param hotkey: hotkey name
@param idcfunc: IDC function name
@returns IDC hotkey error codes"""
    return _ida_kernwin.add_idc_hotkey(hotkey, idcfunc)


def set_highlight(viewer: 'TWidget *', str: str, flags: int) ->bool:
    """Set the highlighted identifier in the viewer (ui_set_highlight). 
        
@param viewer: the viewer
@param str: the text to match, or nullptr to remove current
@param flags: combination of HIF_... bits (see set_highlight flags)
@returns false if an error occurred"""
    return _ida_kernwin.set_highlight(viewer, str, flags)


def open_exports_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the exports window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_exports_window(ea)


def open_imports_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the exports window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_imports_window(ea)


def open_names_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the names window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_names_window(ea)


def open_funcs_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the 'Functions' window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_funcs_window(ea)


def open_strings_window(*args) ->'TWidget *':
    """Open the 'Strings' window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@param selstart: only display strings that occur within this range
@param selend: only display strings that occur within this range
@returns pointer to resulting window"""
    return _ida_kernwin.open_strings_window(*args)


def open_segments_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the segments window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_segments_window(ea)


def open_segregs_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the segment registers window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_segregs_window(ea)


def open_selectors_window() ->'TWidget *':
    """Open the selectors window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_selectors_window()


def open_signatures_window() ->'TWidget *':
    """Open the signatures window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_signatures_window()


def open_tils_window() ->'TWidget *':
    """Open the type libraries window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_tils_window()


def open_loctypes_window(ordinal: int, cursor: 'tif_cursor_t const *'=None
    ) ->'TWidget *':
    """Open the local types window (ui_open_builtin2). 
        
@param ordinal: ordinal of type to select by default
@param cursor: cursor to the type member
@returns pointer to resulting window"""
    return _ida_kernwin.open_loctypes_window(ordinal, cursor)


def open_til_view_window(tif: 'tinfo_t', cursor: 'tif_cursor_t const *'=None
    ) ->'TWidget *':
    """Open the sub-til window (ui_open_builtin2). 
        
@param tif: tif to open
@param cursor: cursor to the type member
@returns pointer to resulting window"""
    return _ida_kernwin.open_til_view_window(tif, cursor)


def open_calls_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the function calls window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_calls_window(ea)


def open_problems_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the problems window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_problems_window(ea)


def open_bpts_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the breakpoints window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_bpts_window(ea)


def open_threads_window() ->'TWidget *':
    """Open the threads window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_threads_window()


def open_modules_window() ->'TWidget *':
    """Open the modules window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_modules_window()


def open_trace_window() ->'TWidget *':
    """Open the tracing window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_trace_window()


def open_stack_window() ->'TWidget *':
    """Open the call stack window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_stack_window()


def open_xrefs_window(ea: ida_idaapi.ea_t) ->'TWidget *':
    """Open the cross references window (ui_open_builtin). 
        
@param ea: index of entry to select by default
@returns pointer to resulting window"""
    return _ida_kernwin.open_xrefs_window(ea)


def open_frame_window(pfn: 'func_t *', offset: int) ->'TWidget *':
    """Open the frame window for the given function (ui_open_builtin). 
        
@param pfn: function to analyze
@param offset: offset where the cursor is placed
@returns pointer to resulting window if 'pfn' is a valid function and the window was displayed, 
 nullptr otherwise"""
    return _ida_kernwin.open_frame_window(pfn, offset)


def open_navband_window(ea: ida_idaapi.ea_t, zoom: int) ->'TWidget *':
    """Open the navigation band window (ui_open_builtin). 
        
@param ea: sets the address of the navband arrow
@param zoom: sets the navband zoom level
@returns pointer to resulting window"""
    return _ida_kernwin.open_navband_window(ea, zoom)


def open_disasm_window(window_title: str, ranges: 'rangevec_t'=None
    ) ->'TWidget *':
    """Open a disassembly view (ui_open_builtin). 
        
@param window_title: title of view to open
@param ranges: if != nullptr, then display a flow chart with the specified ranges
@returns pointer to resulting window"""
    return _ida_kernwin.open_disasm_window(window_title, ranges)


def open_hexdump_window(window_title: str) ->'TWidget *':
    """Open a hexdump view (ui_open_builtin). 
        
@param window_title: title of view to open
@returns pointer to resulting window"""
    return _ida_kernwin.open_hexdump_window(window_title)


def open_notepad_window() ->'TWidget *':
    """Open the notepad window (ui_open_builtin). 
        
@returns pointer to resulting window"""
    return _ida_kernwin.open_notepad_window()


def open_bookmarks_window(w: 'TWidget *') ->'TWidget *':
    """Open the bookmarks window (ui_open_builtin). 
        
@param w: The widget for which the bookmarks will open. For example, this can be an IDAView, or Enums view, etc.
@returns pointer to resulting window"""
    return _ida_kernwin.open_bookmarks_window(w)


def sync_sources(what: 'sync_source_t', _with: 'sync_source_t', sync: bool
    ) ->bool:
    """[Un]synchronize sources 
        
@returns success"""
    return _ida_kernwin.sync_sources(what, _with, sync)


def choose_til() ->str:
    """Choose a type library (ui_choose, chtype_idatil). 
        
@retval true: 'buf' was filled with the name of the selected til
@retval false: otherwise"""
    return _ida_kernwin.choose_til()


def choose_entry(title: str) ->ida_idaapi.ea_t:
    """Choose an entry point (ui_choose, chtype_entry). 
        
@param title: chooser title
@returns ea of selected entry point, BADADDR if none selected"""
    return _ida_kernwin.choose_entry(title)


def choose_name(title: str) ->ida_idaapi.ea_t:
    """Choose a name (ui_choose, chtype_name). 
        
@param title: chooser title
@returns ea of selected name, BADADDR if none selected"""
    return _ida_kernwin.choose_name(title)


def choose_stkvar_xref(pfn: 'func_t *', srkvar_tid: 'tid_t') ->ida_idaapi.ea_t:
    """Choose an xref to a stack variable (ui_choose, chtype_name). 
        
@param pfn: function
@param srkvar_tid: frame variable TID
@returns ea of the selected xref, BADADDR if none selected"""
    return _ida_kernwin.choose_stkvar_xref(pfn, srkvar_tid)


def choose_xref(to: ida_idaapi.ea_t) ->ida_idaapi.ea_t:
    """Choose an xref to an address (ui_choose, chtype_xref). 
        
@param to: referenced address
@returns ea of selected xref, BADADDR if none selected"""
    return _ida_kernwin.choose_xref(to)


def choose_enum(out: 'tinfo_t', title: str, default_ord: int) ->bool:
    """Choose an enum (ui_choose, chtype_enum). 
        
@param out: the selected enum type
@param title: chooser title
@param default_ord: ordinal of enum to select by default
@retval true: the selected type is in OUT
@retval false: nothing was selected"""
    return _ida_kernwin.choose_enum(out, title, default_ord)


def choose_enum_by_value(out: 'tinfo_t', title: str, default_ord: int,
    value: 'uint64', nbytes: int) ->'uchar *':
    """Choose an enum, restricted by value & size (ui_choose, chtype_enum_by_value_and_size). If the given value cannot be found initially, this function will ask if the user would like to import a standard enum. 
        
@param out: the selected enum type
@param title: chooser title
@param default_ord: ordinal of enum to select by default
@param value: value to search for
@param nbytes: size of value
@retval true: the selected type is in OUT
@retval false: nothing was selected"""
    return _ida_kernwin.choose_enum_by_value(out, title, default_ord, value,
        nbytes)


def choose_func(title: str, default_ea: ida_idaapi.ea_t) ->'func_t *':
    """Choose a function (ui_choose, chtype_func). 
        
@param title: chooser title
@param default_ea: ea of function to select by default
@returns pointer to function that was selected, nullptr if none selected"""
    return _ida_kernwin.choose_func(title, default_ea)


def choose_segm(title: str, default_ea: ida_idaapi.ea_t) ->'segment_t *':
    """Choose a segment (ui_choose, chtype_segm). 
        
@param title: chooser title
@param default_ea: ea of segment to select by default
@returns pointer to segment that was selected, nullptr if none selected"""
    return _ida_kernwin.choose_segm(title, default_ea)


def choose_struct(out: 'tinfo_t', title: str) ->bool:
    """Choose a structure (ui_choose, chtype_struct). 
        
@param out: the selected structure type
@param title: chooser title
@retval true: the selected type is in OUT
@retval false: nothing was selected"""
    return _ida_kernwin.choose_struct(out, title)


def choose_srcp(title: str) ->'sreg_range_t *':
    """Choose a segment register change point (ui_choose, chtype_srcp). 
        
@param title: chooser title
@returns pointer to segment register range of selected change point, nullptr if none selected"""
    return _ida_kernwin.choose_srcp(title)


def get_chooser_obj(chooser_caption: str) ->'void *':
    """Get the underlying object of the specified chooser (ui_get_chooser_obj).
This attemps to find the choser by its title and, if found, returns the result of calling its chooser_base_t::get_chooser_obj() method.

@returns the object that was used to create the chooser"""
    return _ida_kernwin.get_chooser_obj(chooser_caption)


def get_chooser_rows(out: 'chooser_row_info_vec_t', chooser_caption: str,
    what: 'size_t') ->bool:
    """Get the chooser contents corresponding to the rows indicated by "what". 
        
@param out: A vector of chooser_row_info_t, one entry per returned row.
@param chooser_caption: The caption that identifies the desired chooser.
@param what: Either one of the GCRF_ flags, or a row index.
@returns Success."""
    return _ida_kernwin.get_chooser_rows(out, chooser_caption, what)


def enable_chooser_item_attrs(chooser_caption: str, enable: bool) ->bool:
    """Enable item-specific attributes for chooser items (ui_enable_chooser_item_attrs). For example: color list items differently depending on a criterium. 
If enabled, the chooser will generate ui_get_chooser_item_attrs 
events that can be intercepted by a plugin to modify the item attributes. 
This event is generated only in the GUI version of IDA. 
Specifying CH_ATTRS bit at the chooser creation time has the same effect. 
        
@returns success"""
    return _ida_kernwin.enable_chooser_item_attrs(chooser_caption, enable)


def replace_wait_box(*args) ->None:
    """Replace the label of "Please wait dialog box".
"""
    return _ida_kernwin.replace_wait_box(*args)


def beep(beep_type: 'beep_t'=beep_default) ->None:
    """Issue a beeping sound (ui_beep). 
        
@param beep_type: beep_t"""
    return _ida_kernwin.beep(beep_type)


def display_copyright_warning() ->bool:
    """Display copyright warning (ui_copywarn). 
        
@returns yes/no"""
    return _ida_kernwin.display_copyright_warning()


def ask_for_feedback(*args) ->None:
    """Show a message box asking to send the input file to [support@hex-rays.com](mailto:support@hex-rays.com). 
        
@param format: the reason why the input file is bad"""
    return _ida_kernwin.ask_for_feedback(*args)


def _ask_addr(*args) ->'ea_t *':
    import ida_kernwin
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_addr(*args)
    return _ida_kernwin._ask_addr(*args)


def _ask_seg(*args) ->'sel_t *':
    import ida_kernwin
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_seg(*args)
    return _ida_kernwin._ask_seg(*args)


def _ask_long(*args) ->'sval_t *':
    import ida_kernwin
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_long(*args)
    return _ida_kernwin._ask_long(*args)


def info(*args) ->'ssize_t':
    return _ida_kernwin.info(*args)


def nomem(*args) ->None:
    return _ida_kernwin.nomem(*args)


ASKBTN_YES = _ida_kernwin.ASKBTN_YES
"""Yes button.
"""
ASKBTN_NO = _ida_kernwin.ASKBTN_NO
"""No button.
"""
ASKBTN_CANCEL = _ida_kernwin.ASKBTN_CANCEL
"""Cancel button.
"""
ASKBTN_BTN1 = _ida_kernwin.ASKBTN_BTN1
"""First (Yes) button.
"""
ASKBTN_BTN2 = _ida_kernwin.ASKBTN_BTN2
"""Second (No) button.
"""
ASKBTN_BTN3 = _ida_kernwin.ASKBTN_BTN3
"""Third (Cancel) button.
"""


def ask_yn(*args) ->int:
    """Display a dialog box and get choice from "Yes", "No", "Cancel". 
        
@param deflt: default choice: one of Button IDs
@param format: The question in printf() style format
@returns the selected button (one of Button IDs). Esc key returns ASKBTN_CANCEL."""
    import ida_kernwin
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_yn(*args)
    return _ida_kernwin.ask_yn(*args)


def ask_buttons(*args) ->int:
    """Display a dialog box and get choice from maximum three possibilities (ui_ask_buttons). 
        
@param Yes: text for the first button
@param No: text for the second button
@param Cancel: text for the third button
@param deflt: default choice: one of Button IDs
@param format: printf-style format string for question. It may have some prefixes, see below.
@returns one of Button IDs specifying the selected button (Esc key returns Cancel/3rd button value)"""
    import ida_kernwin
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_buttons(*args)
    return _ida_kernwin.ask_buttons(*args)


HIST_SEG = _ida_kernwin.HIST_SEG
"""segment names
"""
HIST_CMT = _ida_kernwin.HIST_CMT
"""comments
"""
HIST_SRCH = _ida_kernwin.HIST_SRCH
"""search substrings
"""
HIST_IDENT = _ida_kernwin.HIST_IDENT
"""identifiers. usually CPU register names are forbidden
"""
HIST_FILE = _ida_kernwin.HIST_FILE
"""file names
"""
HIST_TYPE = _ida_kernwin.HIST_TYPE
"""type declarations
"""
HIST_CMD = _ida_kernwin.HIST_CMD
"""commands
"""
HIST_DIR = _ida_kernwin.HIST_DIR
"""directory names (text version only)
"""
HIST_IDENT2 = _ida_kernwin.HIST_IDENT2
"""identifiers, including CPU register names
"""


def ask_ident2(*args) ->bool:
    """Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are permitted. 
        
@param str: qstring to fill. Can contain the default value. Cannot be nullptr.
@param format: printf() style format string with the question
@returns false if the user cancelled the dialog, otherwise returns true."""
    return _ida_kernwin.ask_ident2(*args)


def ask_file(*args) ->'char *':
    import ida_kernwin
    with ida_kernwin.disabled_script_timeout_t():
        return _ida_kernwin.ask_file(*args)
    return _ida_kernwin.ask_file(*args)


class addon_info_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    cb: 'size_t' = property(_ida_kernwin.addon_info_t_cb_get, _ida_kernwin.
        addon_info_t_cb_set)
    id: 'char const *' = property(_ida_kernwin.addon_info_t_id_get,
        _ida_kernwin.addon_info_t_id_set)
    name: 'char const *' = property(_ida_kernwin.addon_info_t_name_get,
        _ida_kernwin.addon_info_t_name_set)
    producer: 'char const *' = property(_ida_kernwin.
        addon_info_t_producer_get, _ida_kernwin.addon_info_t_producer_set)
    version: 'char const *' = property(_ida_kernwin.
        addon_info_t_version_get, _ida_kernwin.addon_info_t_version_set)
    url: 'char const *' = property(_ida_kernwin.addon_info_t_url_get,
        _ida_kernwin.addon_info_t_url_set)
    freeform: 'char const *' = property(_ida_kernwin.
        addon_info_t_freeform_get, _ida_kernwin.addon_info_t_freeform_set)
    custom_data: 'void const *' = property(_ida_kernwin.
        addon_info_t_custom_data_get, _ida_kernwin.addon_info_t_custom_data_set
        )
    custom_size: 'size_t' = property(_ida_kernwin.
        addon_info_t_custom_size_get, _ida_kernwin.addon_info_t_custom_size_set
        )

    def __init__(self):
        _ida_kernwin.addon_info_t_swiginit(self, _ida_kernwin.
            new_addon_info_t())
    __swig_destroy__ = _ida_kernwin.delete_addon_info_t


_ida_kernwin.addon_info_t_swigregister(addon_info_t)


def register_addon(info: 'addon_info_t') ->int:
    """Register an add-on. Show its info in the About box. For plugins, should be called from init() function (repeated calls with the same product code overwrite previous entries) returns: index of the add-on in the list, or -1 on error 
        """
    return _ida_kernwin.register_addon(info)


def addon_count() ->int:
    """Get number of installed addons.
"""
    return _ida_kernwin.addon_count()


def get_addon_info(id: str, info: 'addon_info_t') ->bool:
    """Get info about a registered addon with a given product code. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
        
@returns false if not found"""
    return _ida_kernwin.get_addon_info(id, info)


def get_addon_info_idx(index: int, info: 'addon_info_t') ->bool:
    """Get info about a registered addon with specific index. info->cb must be valid! NB: all pointers are invalidated by next call to register_addon or get_addon_info 
        
@returns false if index is out of range"""
    return _ida_kernwin.get_addon_info_idx(index, info)


class strarray_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr
    code: 'int' = property(_ida_kernwin.strarray_t_code_get, _ida_kernwin.
        strarray_t_code_set)
    text: 'char const *' = property(_ida_kernwin.strarray_t_text_get,
        _ida_kernwin.strarray_t_text_set)

    def __init__(self):
        _ida_kernwin.strarray_t_swiginit(self, _ida_kernwin.new_strarray_t())
    __swig_destroy__ = _ida_kernwin.delete_strarray_t


_ida_kernwin.strarray_t_swigregister(strarray_t)
CLNL_RTRIM = _ida_kernwin.CLNL_RTRIM
"""Remove trailing space characters.
"""
CLNL_LTRIM = _ida_kernwin.CLNL_LTRIM
"""Remove leading space characters.
"""
CLNL_FINDCMT = _ida_kernwin.CLNL_FINDCMT
"""Search for the comment symbol everywhere in the line, not only at the beginning.
"""
CLNL_TRIM = _ida_kernwin.CLNL_TRIM


def qcleanline(*args) ->str:
    """Performs some cleanup operations to a line. 
        
@param buf: string to modify
@param cmt_char: character that denotes the start of a comment:
* the entire text is removed if the line begins with this character (ignoring leading spaces)
* all text after (and including) this character is removed if flag CLNL_FINDCMT is set
@param flags: a combination of line cleanup flags. defaults to CLNL_TRIM
@returns length of line"""
    return _ida_kernwin.qcleanline(*args)


def strarray(array: 'strarray_t', array_size: 'size_t', code: int) ->str:
    """Find a line with the specified code in the strarray_t array. If the last element of the array has code==0 then it is considered as the default entry. 
If no default entry exists and the code is not found, strarray() returns "". 
        """
    return _ida_kernwin.strarray(array, array_size, code)


def ea2str(ea: ida_idaapi.ea_t) ->str:
    """Convert linear address to UTF-8 string.
"""
    return _ida_kernwin.ea2str(ea)


def str2ea(*args) ->'uint64 *':
    """Convert string to linear address. Tries to interpret the string as: 
1) "current IP" keyword if supported by assembler (e.g. "$" in x86) 
2) segment:offset expression, where "segment" may be a name or a fixed segment register (e.g. cs, ds) 
3) just segment name/register (translated to segment's start address) 
4) a name in the database (or debug name during debugging) 
5) hexadecimal value without prefix or suffix 
6) +delta or -delta, where numerical 'delta' is added to or subtracted from 'screen_ea' 
7) register name (only during debugging) 
8) if all else fails, try to evaluate 'str' as an IDC expression

@param str: string to parse
@param screen_ea: the current address in the disassembly/pseudocode view
@returns success"""
    return _ida_kernwin.str2ea(*args)


def str2ea_ex(*args) ->'uint64 *':
    """Same as str2ea() but possibly with some steps skipped. 
        
@param out: the buffer to put the result
@param str: string to parse
@param screen_ea: the current address in the disassembly/pseudocode view
@param flags: see String to address conversion flags
@returns success"""
    return _ida_kernwin.str2ea_ex(*args)


S2EAOPT_NOCALC = _ida_kernwin.S2EAOPT_NOCALC
"""don't try to interpret string as IDC (or current extlang) expression
"""


def atoea(str: str) ->'uint64 *':
    """Convert a number in C notation to an address. decimal: 1234 
octal: 0123 
hexadecimal: 0xabcd 
binary: 0b00101010 
        
@param str: the string to parse"""
    return _ida_kernwin.atoea(str)


IK_CANCEL = _ida_kernwin.IK_CANCEL
IK_BACK = _ida_kernwin.IK_BACK
IK_TAB = _ida_kernwin.IK_TAB
IK_CLEAR = _ida_kernwin.IK_CLEAR
IK_RETURN = _ida_kernwin.IK_RETURN
IK_SHIFT = _ida_kernwin.IK_SHIFT
IK_CONTROL = _ida_kernwin.IK_CONTROL
IK_MENU = _ida_kernwin.IK_MENU
IK_PAUSE = _ida_kernwin.IK_PAUSE
IK_CAPITAL = _ida_kernwin.IK_CAPITAL
IK_KANA = _ida_kernwin.IK_KANA
IK_ESCAPE = _ida_kernwin.IK_ESCAPE
IK_MODECHANGE = _ida_kernwin.IK_MODECHANGE
IK_SPACE = _ida_kernwin.IK_SPACE
IK_PRIOR = _ida_kernwin.IK_PRIOR
IK_NEXT = _ida_kernwin.IK_NEXT
IK_END = _ida_kernwin.IK_END
IK_HOME = _ida_kernwin.IK_HOME
IK_LEFT = _ida_kernwin.IK_LEFT
IK_UP = _ida_kernwin.IK_UP
IK_RIGHT = _ida_kernwin.IK_RIGHT
IK_DOWN = _ida_kernwin.IK_DOWN
IK_SELECT = _ida_kernwin.IK_SELECT
IK_PRINT = _ida_kernwin.IK_PRINT
IK_EXECUTE = _ida_kernwin.IK_EXECUTE
IK_SNAPSHOT = _ida_kernwin.IK_SNAPSHOT
IK_INSERT = _ida_kernwin.IK_INSERT
IK_DELETE = _ida_kernwin.IK_DELETE
IK_HELP = _ida_kernwin.IK_HELP
IK_LWIN = _ida_kernwin.IK_LWIN
IK_RWIN = _ida_kernwin.IK_RWIN
IK_APPS = _ida_kernwin.IK_APPS
IK_SLEEP = _ida_kernwin.IK_SLEEP
IK_NUMPAD0 = _ida_kernwin.IK_NUMPAD0
IK_NUMPAD1 = _ida_kernwin.IK_NUMPAD1
IK_NUMPAD2 = _ida_kernwin.IK_NUMPAD2
IK_NUMPAD3 = _ida_kernwin.IK_NUMPAD3
IK_NUMPAD4 = _ida_kernwin.IK_NUMPAD4
IK_NUMPAD5 = _ida_kernwin.IK_NUMPAD5
IK_NUMPAD6 = _ida_kernwin.IK_NUMPAD6
IK_NUMPAD7 = _ida_kernwin.IK_NUMPAD7
IK_NUMPAD8 = _ida_kernwin.IK_NUMPAD8
IK_NUMPAD9 = _ida_kernwin.IK_NUMPAD9
IK_MULTIPLY = _ida_kernwin.IK_MULTIPLY
IK_ADD = _ida_kernwin.IK_ADD
IK_SEPARATOR = _ida_kernwin.IK_SEPARATOR
IK_SUBTRACT = _ida_kernwin.IK_SUBTRACT
IK_DECIMAL = _ida_kernwin.IK_DECIMAL
IK_DIVIDE = _ida_kernwin.IK_DIVIDE
IK_F1 = _ida_kernwin.IK_F1
IK_F2 = _ida_kernwin.IK_F2
IK_F3 = _ida_kernwin.IK_F3
IK_F4 = _ida_kernwin.IK_F4
IK_F5 = _ida_kernwin.IK_F5
IK_F6 = _ida_kernwin.IK_F6
IK_F7 = _ida_kernwin.IK_F7
IK_F8 = _ida_kernwin.IK_F8
IK_F9 = _ida_kernwin.IK_F9
IK_F10 = _ida_kernwin.IK_F10
IK_F11 = _ida_kernwin.IK_F11
IK_F12 = _ida_kernwin.IK_F12
IK_F13 = _ida_kernwin.IK_F13
IK_F14 = _ida_kernwin.IK_F14
IK_F15 = _ida_kernwin.IK_F15
IK_F16 = _ida_kernwin.IK_F16
IK_F17 = _ida_kernwin.IK_F17
IK_F18 = _ida_kernwin.IK_F18
IK_F19 = _ida_kernwin.IK_F19
IK_F20 = _ida_kernwin.IK_F20
IK_F21 = _ida_kernwin.IK_F21
IK_F22 = _ida_kernwin.IK_F22
IK_F23 = _ida_kernwin.IK_F23
IK_F24 = _ida_kernwin.IK_F24
IK_NUMLOCK = _ida_kernwin.IK_NUMLOCK
IK_SCROLL = _ida_kernwin.IK_SCROLL
IK_OEM_FJ_MASSHOU = _ida_kernwin.IK_OEM_FJ_MASSHOU
IK_OEM_FJ_TOUROKU = _ida_kernwin.IK_OEM_FJ_TOUROKU
IK_LSHIFT = _ida_kernwin.IK_LSHIFT
IK_RSHIFT = _ida_kernwin.IK_RSHIFT
IK_LCONTROL = _ida_kernwin.IK_LCONTROL
IK_RCONTROL = _ida_kernwin.IK_RCONTROL
IK_LMENU = _ida_kernwin.IK_LMENU
IK_RMENU = _ida_kernwin.IK_RMENU
IK_BROWSER_BACK = _ida_kernwin.IK_BROWSER_BACK
IK_BROWSER_FORWARD = _ida_kernwin.IK_BROWSER_FORWARD
IK_BROWSER_REFRESH = _ida_kernwin.IK_BROWSER_REFRESH
IK_BROWSER_STOP = _ida_kernwin.IK_BROWSER_STOP
IK_BROWSER_SEARCH = _ida_kernwin.IK_BROWSER_SEARCH
IK_BROWSER_FAVORITES = _ida_kernwin.IK_BROWSER_FAVORITES
IK_BROWSER_HOME = _ida_kernwin.IK_BROWSER_HOME
IK_VOLUME_MUTE = _ida_kernwin.IK_VOLUME_MUTE
IK_VOLUME_DOWN = _ida_kernwin.IK_VOLUME_DOWN
IK_VOLUME_UP = _ida_kernwin.IK_VOLUME_UP
IK_MEDIA_NEXT_TRACK = _ida_kernwin.IK_MEDIA_NEXT_TRACK
IK_MEDIA_PREV_TRACK = _ida_kernwin.IK_MEDIA_PREV_TRACK
IK_MEDIA_STOP = _ida_kernwin.IK_MEDIA_STOP
IK_MEDIA_PLAY_PAUSE = _ida_kernwin.IK_MEDIA_PLAY_PAUSE
IK_LAUNCH_MAIL = _ida_kernwin.IK_LAUNCH_MAIL
IK_LAUNCH_MEDIA_SELECT = _ida_kernwin.IK_LAUNCH_MEDIA_SELECT
IK_LAUNCH_APP1 = _ida_kernwin.IK_LAUNCH_APP1
IK_LAUNCH_APP2 = _ida_kernwin.IK_LAUNCH_APP2
IK_OEM_1 = _ida_kernwin.IK_OEM_1
IK_OEM_PLUS = _ida_kernwin.IK_OEM_PLUS
IK_OEM_COMMA = _ida_kernwin.IK_OEM_COMMA
IK_OEM_MINUS = _ida_kernwin.IK_OEM_MINUS
IK_OEM_PERIOD = _ida_kernwin.IK_OEM_PERIOD
IK_OEM_2 = _ida_kernwin.IK_OEM_2
IK_OEM_3 = _ida_kernwin.IK_OEM_3
IK_OEM_4 = _ida_kernwin.IK_OEM_4
IK_OEM_5 = _ida_kernwin.IK_OEM_5
IK_OEM_6 = _ida_kernwin.IK_OEM_6
IK_OEM_7 = _ida_kernwin.IK_OEM_7
IK_OEM_102 = _ida_kernwin.IK_OEM_102
IK_PLAY = _ida_kernwin.IK_PLAY
IK_ZOOM = _ida_kernwin.IK_ZOOM
IK_OEM_CLEAR = _ida_kernwin.IK_OEM_CLEAR
CB_INIT = _ida_kernwin.CB_INIT
CB_YES = _ida_kernwin.CB_YES
CB_CLOSE = _ida_kernwin.CB_CLOSE
CB_INVISIBLE = _ida_kernwin.CB_INVISIBLE
CB_DESTROYING = _ida_kernwin.CB_DESTROYING
CB_NO = _ida_kernwin.CB_NO
CB_CANCEL = _ida_kernwin.CB_CANCEL


def get_user_strlist_options(out: 'strwinsetup_t *') ->None:
    return _ida_kernwin.get_user_strlist_options(out)


def del_idc_hotkey(hotkey: str) ->bool:
    return _ida_kernwin.del_idc_hotkey(hotkey)


class disasm_text_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ida_kernwin.disasm_text_t_swiginit(self, _ida_kernwin.
            new_disasm_text_t(*args))
    __swig_destroy__ = _ida_kernwin.delete_disasm_text_t

    def push_back(self, *args) ->'disasm_line_t &':
        return _ida_kernwin.disasm_text_t_push_back(self, *args)

    def pop_back(self) ->None:
        return _ida_kernwin.disasm_text_t_pop_back(self)

    def size(self) ->'size_t':
        return _ida_kernwin.disasm_text_t_size(self)

    def empty(self) ->bool:
        return _ida_kernwin.disasm_text_t_empty(self)

    def at(self, _idx: 'size_t') ->'disasm_line_t const &':
        return _ida_kernwin.disasm_text_t_at(self, _idx)

    def qclear(self) ->None:
        return _ida_kernwin.disasm_text_t_qclear(self)

    def clear(self) ->None:
        return _ida_kernwin.disasm_text_t_clear(self)

    def resize(self, *args) ->None:
        return _ida_kernwin.disasm_text_t_resize(self, *args)

    def grow(self, *args) ->None:
        return _ida_kernwin.disasm_text_t_grow(self, *args)

    def capacity(self) ->'size_t':
        return _ida_kernwin.disasm_text_t_capacity(self)

    def reserve(self, cnt: 'size_t') ->None:
        return _ida_kernwin.disasm_text_t_reserve(self, cnt)

    def truncate(self) ->None:
        return _ida_kernwin.disasm_text_t_truncate(self)

    def swap(self, r: 'disasm_text_t') ->None:
        return _ida_kernwin.disasm_text_t_swap(self, r)

    def extract(self) ->'disasm_line_t *':
        return _ida_kernwin.disasm_text_t_extract(self)

    def inject(self, s: 'disasm_line_t', len: 'size_t') ->None:
        return _ida_kernwin.disasm_text_t_inject(self, s, len)

    def begin(self, *args) ->'qvector< disasm_line_t >::const_iterator':
        return _ida_kernwin.disasm_text_t_begin(self, *args)

    def end(self, *args) ->'qvector< disasm_line_t >::const_iterator':
        return _ida_kernwin.disasm_text_t_end(self, *args)

    def insert(self, it: 'disasm_line_t', x: 'disasm_line_t'
        ) ->'qvector< disasm_line_t >::iterator':
        return _ida_kernwin.disasm_text_t_insert(self, it, x)

    def erase(self, *args) ->'qvector< disasm_line_t >::iterator':
        return _ida_kernwin.disasm_text_t_erase(self, *args)

    def __len__(self) ->'size_t':
        return _ida_kernwin.disasm_text_t___len__(self)

    def __getitem__(self, i: 'size_t') ->'disasm_line_t const &':
        return _ida_kernwin.disasm_text_t___getitem__(self, i)

    def __setitem__(self, i: 'size_t', v: 'disasm_line_t') ->None:
        return _ida_kernwin.disasm_text_t___setitem__(self, i, v)

    def append(self, x: 'disasm_line_t') ->None:
        return _ida_kernwin.disasm_text_t_append(self, x)

    def extend(self, x: 'disasm_text_t') ->None:
        return _ida_kernwin.disasm_text_t_extend(self, x)
    front = ida_idaapi._qvector_front
    back = ida_idaapi._qvector_back
    __iter__ = ida_idaapi._bounded_getitem_iterator


_ida_kernwin.disasm_text_t_swigregister(disasm_text_t)


def load_custom_icon(file_name=None, data=None, format=None):
    """Load an icon from a file (ui_load_custom_icon_file). Also see load_custom_icon(const void *, unsigned int, const char *) 
        
@param file_name: path to file
@returns icon id"""
    if file_name is not None:
        return _ida_kernwin.py_load_custom_icon_fn(file_name)
    elif not (data is None and format is None):
        return _ida_kernwin.py_load_custom_icon_data(data, format)
    else:
        return 0


def ask_long(defval, format):
    """Display a dialog box and wait for the user to input an number (ui_ask_long). The number is represented in C-style. This function allows to enter any IDC expression and properly calculates it. 
        
@param format: printf() style format string with the question
@retval 0: if the user pressed Esc.
@retval 1: ok, the user entered a valid number."""
    res, val = _ida_kernwin._ask_long(defval, format)
    if res == 1:
        return val
    else:
        return None


def ask_addr(defval, format):
    """Output a formatted string to the output window (msg) preprended with "**DATABASE IS CORRUPTED: " Display a dialog box and wait for the user to input an address (ui_ask_addr). 
        
@param format: printf() style format string with the question
@retval 0: the user pressed Esc.
@retval 1: ok, the user entered an address"""
    res, ea = _ida_kernwin._ask_addr(defval, format)
    if res == 1:
        return ea
    else:
        return None


def ask_seg(defval, format):
    """Display a dialog box and wait for the user to input an segment name (ui_ask_seg). This function allows to enter segment register names, segment base paragraphs, segment names to denote a segment. 
        
@param format: printf() style format string with the question
@retval 0: if the user pressed Esc.
@retval 1: ok, the user entered an segment name"""
    res, sel = _ida_kernwin._ask_seg(defval, format)
    if res == 1:
        return sel
    else:
        return None


def ask_ident(defval, format):
    """Display a dialog box and wait for the user to input an identifier. If the user enters a non-valid identifier, this function displays a warning and allows the user to correct it. CPU register names are usually forbidden. 
        
@param format: printf() style format string with the question
@returns false if the user cancelled the dialog, otherwise returns true."""
    return ask_str(defval, HIST_IDENT, format)


class action_handler_t(object):

    def __init__(self):
        pass

    def activate(self, ctx):
        """Activate an action. This function implements the core behavior of an action. It is called when the action is triggered, from a menu, from a popup menu, from the toolbar, or programmatically. 
        
@returns non-zero: all IDA windows will be refreshed"""
        return 0

    def update(self, ctx):
        """Update an action. This is called when the context of the UI changed, and we need to let the action update some of its properties if needed (label, icon, ...)
In addition, this lets IDA know whether the action is enabled, and when it should be queried for availability again.
Note: This callback is not meant to change anything in the application's state, except by calling one (or many) of the "update_action_*()" functions on this very action. 
        """
        pass


class quick_widget_commands_t:


    class _cmd_t:

        def __init__(self, caption, flags, menu_index, icon, emb, shortcut):
            self.caption = caption
            self.flags = flags
            self.menu_index = menu_index
            self.icon = icon
            self.emb = emb
            self.shortcut = shortcut


    class _ah_t(action_handler_t):

        def __init__(self, parent, cmd_id):
            action_handler_t.__init__(self)
            self.parent = parent
            self.cmd_id = cmd_id

        def activate(self, ctx):
            self.parent.callback(ctx, self.cmd_id)

        def update(self, ctx):
            return AST_ENABLE_ALWAYS

    def __init__(self, callback):
        self.callback = callback
        self.cmds = []

    def add(self, caption, flags, menu_index, icon, emb, shortcut):
        for idx, cmd in enumerate(self.cmds):
            if cmd.caption == caption:
                return idx
        self.cmds.append(quick_widget_commands_t._cmd_t(caption, flags,
            menu_index, icon, emb, shortcut))
        return len(self.cmds) - 1

    def populate_popup(self, widget, popup):
        for idx, cmd in enumerate(self.cmds):
            if cmd.flags & CHOOSER_POPUP_MENU != 0:
                desc = action_desc_t(None, cmd.caption,
                    quick_widget_commands_t._ah_t(self, idx), cmd.shortcut,
                    None, cmd.icon)
                attach_dynamic_action_to_popup(None, popup, desc)


class disabled_script_timeout_t(object):

    def __enter__(self):
        import _ida_idaapi
        self.was_timeout = _ida_idaapi.set_script_timeout(0)

    def __exit__(self, type, value, tb):
        import _ida_idaapi
        _ida_idaapi.set_script_timeout(self.was_timeout)


import ida_ida
ida_ida.__wrap_hooks_callback(UI_Hooks, 'database_closed', 'term', lambda
    cb, *args: cb(*args))
from ida_pro import str2user
SETMENU_IF_ENABLED = 4
CH_NOIDB = CH_UNUSED
BWN_TILVIEW = BWN_TICSR
IWID_TILVIEW = IWID_TICSR
BWN_LOCTYPS = BWN_TILVIEW
IWID_LOCTYPS = IWID_TILVIEW
BWN_DISASMS = BWN_DISASM
IWID_DISASMS = IWID_DISASM
CHOOSER_NO_SELECTION = _ida_kernwin.CHOOSER_NO_SELECTION
CHOOSER_MULTI_SELECTION = _ida_kernwin.CHOOSER_MULTI_SELECTION
CHOOSER_POPUP_MENU = _ida_kernwin.CHOOSER_POPUP_MENU
CHOOSER_MENU_EDIT = _ida_kernwin.CHOOSER_MENU_EDIT
CHOOSER_MENU_JUMP = _ida_kernwin.CHOOSER_MENU_JUMP
CHOOSER_MENU_SEARCH = _ida_kernwin.CHOOSER_MENU_SEARCH


def choose_find(title: str) ->Union[object, None]:
    """Retrieve the chooser object by title

@param title the chooser title
@return the chooser, or None"""
    return _ida_kernwin.choose_find(title)


def choose_refresh(_self: 'PyObject *') ->None:
    return _ida_kernwin.choose_refresh(_self)


def choose_close(_self: 'PyObject *') ->None:
    return _ida_kernwin.choose_close(_self)


def choose_get_widget(_self: 'PyObject *') ->'TWidget *':
    return _ida_kernwin.choose_get_widget(_self)


def choose_choose(_self: 'PyObject *') ->'PyObject *':
    return _ida_kernwin.choose_choose(_self)


def choose_activate(_self: 'PyObject *') ->None:
    return _ida_kernwin.choose_activate(_self)


def choose_create_embedded_chobj(_self: 'PyObject *') ->'PyObject *':
    return _ida_kernwin.choose_create_embedded_chobj(_self)


def get_chooser_data(title: str, n: int) ->List[str]:
    """Get the text corresponding to the index N in the chooser data.
Use -1 to get the header.

@param title The chooser title
@return a list of strings, or None"""
    return _ida_kernwin.get_chooser_data(title, n)


CH_NOIDB = _ida_kernwin.CH_NOIDB
import _ida_kernwin


class Choose(object):
    """
    Chooser wrapper class.

    Some constants are defined in this class.
    Please refer to kernwin.hpp for more information.
    """
    CH_MODAL = _ida_kernwin.CH_MODAL
    """Modal chooser.
"""
    """Modal chooser"""
    CH_MULTI = _ida_kernwin.CH_MULTI
    """The chooser will allow multi-selection (only for GUI choosers). This bit is set when using the chooser_multi_t structure. 
        """
    """
    Allow multi selection.
    Refer the description of the OnInsertLine(), OnDeleteLine(),
    OnEditLine(), OnSelectLine(), OnRefresh(), OnSelectionChange() to
    see a difference between single and multi selection callbacks.
    """
    CH_NOBTNS = _ida_kernwin.CH_NOBTNS
    """do not display ok/cancel/help/search buttons. Meaningful only for gui modal windows because non-modal windows do not have any buttons anyway. Text mode does not have them neither. 
        """
    CH_ATTRS = _ida_kernwin.CH_ATTRS
    """generate ui_get_chooser_item_attrs (gui only)
"""
    CH_NOIDB = _ida_kernwin.CH_NOIDB
    """use the chooser even without an open database, same as x0=-2"""
    CH_FORCE_DEFAULT = _ida_kernwin.CH_FORCE_DEFAULT
    """if a non-modal chooser was already open, change selection to the default one 
        """
    """
    If a non-modal chooser was already open, change selection to the given
    default one
    """
    CH_CAN_INS = _ida_kernwin.CH_CAN_INS
    """allow to insert new items
"""
    """allow to insert new items"""
    CH_CAN_DEL = _ida_kernwin.CH_CAN_DEL
    """allow to delete existing item(s)
"""
    """allow to delete existing item(s)"""
    CH_CAN_EDIT = _ida_kernwin.CH_CAN_EDIT
    """allow to edit existing item(s)
"""
    """allow to edit existing item(s)"""
    CH_CAN_REFRESH = _ida_kernwin.CH_CAN_REFRESH
    """allow to refresh chooser
"""
    """allow to refresh chooser"""
    CH_QFLT = _ida_kernwin.CH_QFLT
    """open with quick filter enabled and focused
"""
    """open with quick filter enabled and focused"""
    CH_QFTYP_SHIFT = _ida_kernwin.CH_QFTYP_SHIFT
    CH_QFTYP_DEFAULT = _ida_kernwin.CH_QFTYP_DEFAULT
    """set quick filtering type to the possible existing default for this chooser
"""
    CH_QFTYP_NORMAL = _ida_kernwin.CH_QFTYP_NORMAL
    """normal (i.e., lexicographical) quick filter type
"""
    CH_QFTYP_WHOLE_WORDS = _ida_kernwin.CH_QFTYP_WHOLE_WORDS
    """whole words quick filter type
"""
    CH_QFTYP_REGEX = _ida_kernwin.CH_QFTYP_REGEX
    """regex quick filter type
"""
    CH_QFTYP_FUZZY = _ida_kernwin.CH_QFTYP_FUZZY
    """fuzzy search quick filter type
"""
    CH_QFTYP_MASK = _ida_kernwin.CH_QFTYP_MASK
    CH_NO_STATUS_BAR = _ida_kernwin.CH_NO_STATUS_BAR
    """don't show a status bar
"""
    """don't show a status bar"""
    CH_RESTORE = _ida_kernwin.CH_RESTORE
    """restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)
"""
    """restore floating position if present (equivalent of WOPN_RESTORE) (GUI version only)"""
    CH_RENAME_IS_EDIT = _ida_kernwin.CH_RENAME_IS_EDIT
    """triggering a 'edit/rename' (i.e., F2 shortcut) on a cell, should call the edit() callback for the corresponding row. 
        """
    """triggering a 'edit/rename' (i.e., F2 shortcut) on a cell,
       should call the edit() callback for the corresponding row."""
    CH_BUILTIN_SHIFT = _ida_kernwin.CH_BUILTIN_SHIFT
    CH_BUILTIN_MASK = _ida_kernwin.CH_BUILTIN_MASK
    """Mask for builtin chooser numbers. Plugins should not use them.
"""
    """The chooser can provide a dirtree_t, meaning a tree-like structure
       can be provided to the user (instead of a flat table)"""
    CH_HAS_DIRTREE = _ida_kernwin.CH_HAS_DIRTREE
    """The chooser can provide a dirtree_t, meaning a tree-like structure can be provided to the user (instead of a flat table) 
        """
    """The chooser can be used in a diffing/merging workflow"""
    CH_HAS_DIFF = _ida_kernwin.CH_HAS_DIFF
    """The chooser can be used in a diffing/merging workflow.
"""
    CHCOL_PLAIN = _ida_kernwin.CHCOL_PLAIN
    """plain string
"""
    CHCOL_PATH = _ida_kernwin.CHCOL_PATH
    """file path. TUI IDA will truncate excessive cell lengths starting at their beginning, and prepending the resulting text with "..." order to leave the filename visible 
        """
    CHCOL_HEX = _ida_kernwin.CHCOL_HEX
    """hexadecimal number
"""
    CHCOL_DEC = _ida_kernwin.CHCOL_DEC
    """decimal number
"""
    CHCOL_EA = _ida_kernwin.CHCOL_EA
    """address
"""
    CHCOL_FNAME = _ida_kernwin.CHCOL_FNAME
    """function name. If a chooser column has this flag set and implements chooser_base_t::get_ea(), rows background colors will be automatically set to match the navigator's "Library function", "Lumina function" and "External symbol" colors 
        """
    CHCOL_FORMAT = _ida_kernwin.CHCOL_FORMAT
    """column format mask
"""
    CHCOL_DEFHIDDEN = _ida_kernwin.CHCOL_DEFHIDDEN
    """column should be hidden by default
"""
    CHCOL_DRAGHINT = _ida_kernwin.CHCOL_DRAGHINT
    """the column number that will be used to build hints for the dragging undo label. This should be provided for at most one column for any given chooser. 
        """
    CHCOL_INODENAME = _ida_kernwin.CHCOL_INODENAME
    """if CH_HAS_DIRTREE has been specified, this instructs the chooser that this column shows the inode name. This should be provided for at most one column for any given chooser. 
        """
    NO_SELECTION = -1
    """there is no selected item"""
    EMPTY_CHOOSER = -2
    """the chooser is initialized"""
    ALREADY_EXISTS = -3
    """the non-modal chooser with the same data is already open"""
    NO_ATTR = -4
    """some mandatory attribute is missing"""
    NOTHING_CHANGED = 0
    ALL_CHANGED = 1
    SELECTION_CHANGED = 2


    class UI_Hooks_Trampoline(UI_Hooks):

        def __init__(self, v):
            UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, widget, popup_handle):
            chooser = self.v()
            if widget == chooser.GetWidget() and hasattr(chooser, 'OnPopup'
                ) and callable(getattr(chooser, 'OnPopup')):
                chooser.OnPopup(widget, popup_handle)

    def __init__(self, title, cols, flags=0, popup_names=None, icon=-1, x1=
        -1, y1=-1, x2=-1, y2=-1, deflt=None, embedded=False, width=None,
        height=None, forbidden_cb=0, flags2=0):
        """
        Constructs a chooser window.
        @param title: The chooser title
        @param cols: a list of colums; each list item is a list of two items
            example: [ ["Address", 10 | Choose.CHCOL_HEX],
                       ["Name",    30 | Choose.CHCOL_PLAIN] ]
        @param flags: One of CH_XXXX constants
        @param flags2: One of CH2_XXXX constants
        @param deflt: The index of the default item (0-based) for single
            selection choosers or the list of indexes for multi selection
            chooser
        @param popup_names: List of new captions to replace this list
            ["Insert", "Delete", "Edit", "Refresh"]
        @param icon: Icon index (the icon should exist in ida resources or
            an index to a custom loaded icon)
        @param x1, y1, x2, y2: The default location (for txt-version)
        @param embedded: Create as embedded chooser
        @param width: Embedded chooser width
        @param height: Embedded chooser height
        @param forbidden_cb: Explicitly forbidden callbacks
        """
        self.title = title
        self.flags = flags
        self.flags2 = flags2
        self.cols = cols
        if deflt == None:
            deflt = 0 if flags & Choose.CH_MULTI == 0 else [0]
        self.deflt = deflt
        self.popup_names = popup_names
        self.icon = icon
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.embedded = embedded
        self.width = width
        self.height = height
        self.forbidden_cb = forbidden_cb
        self.ui_hooks_trampoline = None

        def _qccb(ctx, cmd_id):
            for idx in ctx.chooser_selection:
                self.OnCommand(idx, cmd_id)
        self._quick_commands = quick_widget_commands_t(_qccb)

    def Embedded(self, create_chobj=False):
        """
        Creates an embedded chooser (as opposed to Show())
        @return: Returns 0 on success or NO_ATTR
        """
        if not self.embedded:
            return Choose.NO_ATTR
        if create_chobj:
            return _ida_kernwin.choose_create_embedded_chobj(self)
        else:
            return _ida_kernwin.choose_choose(self)

    def GetEmbSelection(self):
        """
        Deprecated. For embedded choosers, the selection is
        available through 'Form.EmbeddedChooserControl.selection'
        """
        return None

    def Show(self, modal=False):
        """
        Activates or creates a chooser window
        @param modal: Display as modal dialog
        @return: For all choosers it will return NO_ATTR if some mandatory
                 attribute is missing. The mandatory attributes are: flags,
                 title, cols, OnGetSize(), OnGetLine();
                 For modal choosers it will return the selected item index (0-based),
                 or NO_SELECTION if no selection,
                 or EMPTY_CHOOSER if the OnRefresh() callback returns EMPTY_CHOOSER;
                 For non-modal choosers it will return 0
                 or ALREADY_EXISTS if the chooser was already open and is active now;
        """
        if self.embedded:
            return Choose.NO_ATTR
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)
        if modal:
            self.flags |= Choose.CH_MODAL
            with disabled_script_timeout_t():
                n = _ida_kernwin.choose_choose(self)
            self.Close()
            return n
        else:
            self.flags &= ~Choose.CH_MODAL
            return _ida_kernwin.choose_choose(self)

    def Activate(self):
        """Activates a visible chooser"""
        return _ida_kernwin.choose_activate(self)

    def Refresh(self):
        """Causes the refresh callback to trigger"""
        return _ida_kernwin.choose_refresh(self)

    def Close(self):
        """Closes the chooser"""
        if not self.embedded:
            _ida_kernwin.choose_close(self)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.choose_get_widget(self)

    def adjust_last_item(self, n):
        """
        Helper for OnDeleteLine() and OnRefresh() callbacks.
        They can be finished by the following line:
        return [Choose.ALL_CHANGED] + self.adjust_last_item(n)
        @param: line number of the remaining select item
        @return: list of selected lines numbers (one element or empty)
        """
        cnt = self.OnGetSize()
        if cnt == 0:
            return []
        if n >= cnt:
            n = cnt - 1
        return [n]

    def AddCommand(self, caption, flags=_ida_kernwin.CHOOSER_POPUP_MENU,
        menu_index=-1, icon=-1, emb=None, shortcut=None):
        return self._quick_commands.add(caption=caption, flags=flags,
            menu_index=menu_index, icon=icon, emb=emb, shortcut=shortcut)

    def OnPopup(self, widget, popup_handle):
        self._quick_commands.populate_popup(widget, popup_handle)

    def OnInit(self):
        """
        Initialize the chooser and populate it.

        This callback is optional
        """
        pass

    def OnGetSize(self):
        """
        Get the number of elements in the chooser.

        This callback is mandatory

        @return the number of elements
        """
        pass

    def OnGetLine(self, n):
        """
        Get data for an element

        This callback is mandatory

        @param n the index to fetch data for
        @return a list of strings
        """
        pass

    def OnGetIcon(self, n):
        """
        Get an icon to associate with the first cell of an element

        @param n index of the element
        @return an icon ID
        """
        pass

    def OnGetLineAttr(self, n):
        """
        Get attributes for an element

        @param n index of the element
        @return a tuple (color, flags)
        """
        pass

    def OnInsertLine(self, sel):
        """
        User asked to insert an element

        @param sel the current selection
        @return a tuple (changed, selection)
        """
        pass

    def OnDeleteLine(self, sel):
        """
        User deleted an element

        @param sel the current selection
        @return a tuple (changed, selection)
        """
        pass

    def OnEditLine(self, sel):
        """
        User asked to edit an element.

        @param sel the current selection
        @return a tuple (changed, selection)
        """
        pass

    def OnSelectLine(self, sel):
        """
        User pressed the enter key, or double-clicked a selection

        @param sel the current selection
        @return a tuple (changed, selection)
        """
        pass

    def OnSelectionChange(self, sel):
        """
        Selection changed

        @param sel the new selection
        """
        pass

    def OnRefresh(self, sel):
        """
        The chooser needs to be refreshed.
        It returns the new positions of the selected items.

        @param sel the current selection
        @return a tuple (changed, selection)
        """
        pass

    def OnClose(self):
        """
        The chooser window is closed.
        """
        pass

    def OnGetEA(self, n):
        """
        Get the address of an element

        When this function returns valid addresses:
          * If any column has the `CHCOL_FNAME` flag, rows will
            be colored according to the attributes of the functions
            who own those addresses (extern, library function,
            Lumina, ... - similar to what the "Functions" widget does)
          * When a selection is present and the user presses `<Enter>`
            (`<Shift+Enter>` if the chooser is modal), IDA will jump
            to that address (through jumpto())
        @param n element number (0-based)
        @return the effective address, ida_idaapi.BADADDR if the element has no address
        """
        pass

    def OnGetDirTree(self):
        """
        Get the dirtree_t that will be used to present a tree-like
        structure to the user (see CH_HAS_DIRTREE)

        @return the dirtree_t, or None
        """
        pass

    def OnIndexToInode(self, n):
        """
        Map an element index to a dirtree_t inode

        This callback is mandatory if CH_HAS_DIRTREE is specified

        @param n index of the element
        @return the inode number
        """
        pass

    def OnIndexToDiffpos(self, n):
        """
        Map an element index to a diffpos_t

        This callback is mandatory if CH_HAS_DIFF is specified

        @param n index of the element
        @return the diffpos
        """
        pass

    def OnLazyLoadDir(self, path):
        """
        Callback for lazy-loaded, dirtree-based choosers;
        the function will be called when a folder is expanded and it has
        not been loaded before. The implementation should use the
        given dirtree's link() or mkdir() methods to add the folder contents.

        @param path an absolute dirtree path to the directory that is being expanded
        @return success
        """
        pass


def textctrl_info_t_assign(_self: 'PyObject *', other: 'PyObject *') ->bool:
    return _ida_kernwin.textctrl_info_t_assign(_self, other)


def textctrl_info_t_set_text(_self: 'PyObject *', s: str) ->bool:
    return _ida_kernwin.textctrl_info_t_set_text(_self, s)


def textctrl_info_t_get_text(_self: 'PyObject *') ->str:
    return _ida_kernwin.textctrl_info_t_get_text(_self)


def textctrl_info_t_set_flags(_self: 'PyObject *', flags: 'unsigned int'
    ) ->bool:
    return _ida_kernwin.textctrl_info_t_set_flags(_self, flags)


def textctrl_info_t_get_flags(_self: 'PyObject *') ->'unsigned int':
    return _ida_kernwin.textctrl_info_t_get_flags(_self)


def textctrl_info_t_set_tabsize(_self: 'PyObject *', tabsize: 'unsigned int'
    ) ->bool:
    return _ida_kernwin.textctrl_info_t_set_tabsize(_self, tabsize)


def textctrl_info_t_get_tabsize(_self: 'PyObject *') ->'unsigned int':
    return _ida_kernwin.textctrl_info_t_get_tabsize(_self)


def formchgcbfa_enable_field(p_fa: 'size_t', fid: int, enable: bool) ->bool:
    return _ida_kernwin.formchgcbfa_enable_field(p_fa, fid, enable)


def formchgcbfa_show_field(p_fa: 'size_t', fid: int, show: bool) ->bool:
    return _ida_kernwin.formchgcbfa_show_field(p_fa, fid, show)


def formchgcbfa_move_field(p_fa: 'size_t', fid: int, x: int, y: int, w: int,
    h: int) ->bool:
    return _ida_kernwin.formchgcbfa_move_field(p_fa, fid, x, y, w, h)


def formchgcbfa_get_focused_field(p_fa: 'size_t') ->int:
    return _ida_kernwin.formchgcbfa_get_focused_field(p_fa)


def formchgcbfa_set_focused_field(p_fa: 'size_t', fid: int) ->bool:
    return _ida_kernwin.formchgcbfa_set_focused_field(p_fa, fid)


def formchgcbfa_refresh_field(p_fa: 'size_t', fid: int) ->None:
    return _ida_kernwin.formchgcbfa_refresh_field(p_fa, fid)


def formchgcbfa_close(p_fa: 'size_t', close_normally: int) ->None:
    return _ida_kernwin.formchgcbfa_close(p_fa, close_normally)


def formchgcbfa_get_field_value(p_fa: 'size_t', fid: int, ft: int, sz: 'size_t'
    ) ->'PyObject *':
    return _ida_kernwin.formchgcbfa_get_field_value(p_fa, fid, ft, sz)


def formchgcbfa_set_field_value(p_fa: 'size_t', fid: int, ft: int, py_val:
    'PyObject *') ->bool:
    return _ida_kernwin.formchgcbfa_set_field_value(p_fa, fid, ft, py_val)


def py_get_ask_form() ->'size_t':
    return _ida_kernwin.py_get_ask_form()


def py_get_open_form() ->'size_t':
    return _ida_kernwin.py_get_open_form()


def py_register_compiled_form(py_form: 'PyObject *') ->None:
    return _ida_kernwin.py_register_compiled_form(py_form)


def py_unregister_compiled_form(py_form: 'PyObject *') ->None:
    return _ida_kernwin.py_unregister_compiled_form(py_form)


import sys
import ida_idaapi, _ida_idaapi
import ida_pro
try:
    import types
    import ctypes
    _BUTTONCB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.
        c_void_p)
    _FORMCHGCB_T = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.
        c_void_p)
except:
    try:
        _BUTTONCB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.
            c_void_p)
        _FORMCHGCB_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, ctypes.
            c_void_p)
    except:
        _BUTTONCB_T = _FORMCHGCB_T = None


class textctrl_info_t(ida_idaapi.py_clinked_object_t):
    """Class representing textctrl_info_t"""
    TXTF_AUTOINDENT = 1
    """Auto-indent on new line"""
    TXTF_ACCEPTTABS = 2
    """Tab key inserts 'tabsize' spaces"""
    TXTF_READONLY = 4
    """Text cannot be edited (but can be selected and copied)"""
    TXTF_SELECTED = 8
    """Shows the field with its text selected"""
    TXTF_MODIFIED = 16
    """Gets/sets the modified status"""
    TXTF_FIXEDFONT = 32
    """The control uses IDA's fixed font"""

    def __init__(self, text='', flags=0, tabsize=0):
        ida_idaapi.py_clinked_object_t.__init__(self)
        if text:
            self.text = text
        if flags:
            self.flags = flags
        if tabsize:
            self.tabsize = tabsize

    def _create_clink(self):
        return _ida_kernwin.textctrl_info_t_create()

    def _del_clink(self, lnk):
        return _ida_kernwin.textctrl_info_t_destroy(lnk)

    def _get_clink_ptr(self):
        return _ida_kernwin.textctrl_info_t_get_clink_ptr(self)

    def assign(self, other):
        """Copies the contents of 'other' to 'self'"""
        return _ida_kernwin.textctrl_info_t_assign(self, other)

    def __set_text(self, s):
        """Sets the text value"""
        return _ida_kernwin.textctrl_info_t_set_text(self, s)

    def __get_text(self):
        """Sets the text value"""
        return _ida_kernwin.textctrl_info_t_get_text(self)

    def __set_flags__(self, flags):
        """Sets the flags value"""
        return _ida_kernwin.textctrl_info_t_set_flags(self, flags)

    def __get_flags__(self):
        """Returns the flags value"""
        return _ida_kernwin.textctrl_info_t_get_flags(self)

    def __set_tabsize__(self, tabsize):
        """Sets the tabsize value"""
        return _ida_kernwin.textctrl_info_t_set_tabsize(self, tabsize)

    def __get_tabsize__(self):
        """Returns the tabsize value"""
        return _ida_kernwin.textctrl_info_t_get_tabsize(self)
    value = property(__get_text, __set_text)
    """Alias for the text property"""
    text = property(__get_text, __set_text)
    """in, out: text control value
"""
    """Text value"""
    flags = property(__get_flags__, __set_flags__)
    """Text control property bits 
        """
    """Flags value"""
    tabsize = property(__get_tabsize__, __set_tabsize__)
    """how many spaces a single tab will indent
"""


class Form(object):
    FT_ASCII = 'A'
    """Ascii string - char *"""
    FT_SEG = 'S'
    """Segment - sel_t *"""
    FT_HEX = 'N'
    """Hex number - uval_t *"""
    FT_SHEX = 'n'
    """Signed hex number - sval_t *"""
    FT_COLOR = 'K'
    """Color button - bgcolor_t *"""
    FT_ADDR = '$'
    """Address - ea_t *"""
    FT_UINT64 = 'L'
    """default base uint64 - uint64"""
    FT_INT64 = 'l'
    """default base int64 - int64"""
    FT_RAWHEX = 'M'
    """Hex number, no 0x prefix - uval_t *"""
    FT_FILE = 'f'
    """File browse - char * at least QMAXPATH"""
    FT_DEC = 'D'
    """Decimal number - sval_t *"""
    FT_OCT = 'O'
    """Octal number, C notation - sval_t *"""
    FT_BIN = 'Y'
    """Binary number, 0b prefix - sval_t *"""
    FT_CHAR = 'H'
    """Char value -- sval_t *"""
    FT_IDENT = 'I'
    """Identifier - char * at least MAXNAMELEN"""
    FT_BUTTON = 'B'
    """Button - def handler(code)"""
    FT_DIR = 'F'
    """Path to directory - char * at least QMAXPATH"""
    FT_TYPE = 'T'
    """Type declaration - char * at least MAXSTR"""
    _FT_USHORT = '_US'
    """Unsigned short"""
    FT_FORMCHG = '%/'
    """Form change callback - formchgcb_t"""
    FT_ECHOOSER = 'E'
    """Embedded chooser - idaapi.Choose"""
    FT_MULTI_LINE_TEXT = 't'
    """Multi text control - textctrl_info_t"""
    FT_DROPDOWN_LIST = 'b'
    """Dropdown list control - Form.DropdownControl"""
    FT_HTML_LABEL = 'h'
    """HTML label to display (only for GUI version, and for dynamic labels; no input)"""
    FT_CHKGRP = 'C'
    FT_CHKGRP2 = 'c'
    FT_RADGRP = 'R'
    FT_RADGRP2 = 'r'

    @staticmethod
    def create_string_buffer(value, size=None):
        if value is None:
            assert size is not None
            return ctypes.create_string_buffer(size)
        elif sys.version_info.major >= 3:
            return ctypes.create_string_buffer(value.encode('UTF-8'), size)
        else:
            return ctypes.create_string_buffer(value, size)

    @staticmethod
    def fieldtype_to_ctype(tp, i64=False):
        """
        Factory method returning a ctype class corresponding to the field type string
        """
        if tp in (Form.FT_SEG, Form.FT_HEX, Form.FT_RAWHEX, Form.FT_ADDR):
            return ctypes.c_uint64 if i64 else ctypes.c_ulong
        elif tp in (Form.FT_SHEX, Form.FT_DEC, Form.FT_OCT, Form.FT_BIN,
            Form.FT_CHAR):
            return ctypes.c_int64 if i64 else ctypes.c_long
        elif tp == Form.FT_UINT64:
            return ctypes.c_uint64
        elif tp == Form.FT_INT64:
            return ctypes.c_int64
        elif tp == Form.FT_COLOR:
            return ctypes.c_ulong
        elif tp == Form._FT_USHORT:
            return ctypes.c_ushort
        elif tp in (Form.FT_FORMCHG, Form.FT_ECHOOSER):
            return ctypes.c_void_p
        else:
            return None


    class NumericArgument(object):
        """
        Argument representing various integer arguments (ushort, uint32, uint64, etc...)
        @param tp: One of Form.FT_XXX
        """
        DefI64 = False

        def __init__(self, tp, value, i64=None):
            cls = Form.fieldtype_to_ctype(tp, i64 if i64 is not None else
                self.DefI64)
            if cls is None:
                raise TypeError('Invalid numeric field type: %s' % tp)
            self.arg = ctypes.pointer(cls(value))

        def __set_value(self, v):
            self.arg.contents.value = v
        value = property(lambda self: self.arg.contents.value, __set_value)


    class StringArgument(object):
        """
        Argument representing a character buffer
        """

        def __init__(self, size=None, value=None):
            if size is None:
                raise SyntaxError('The string size must be passed')
            if isinstance(size, str):
                value, size = size, None
            self.size = size
            self.arg = Form.create_string_buffer(value, size)

        def __get_value(self):
            return self.arg.value.decode('UTF-8')

        def __set_value(self, v):
            self.arg.value = v.encode('UTF-8')
        value = property(__get_value, __set_value)


    class Control(object):

        def __init__(self):
            self.id = 0
            """Automatically assigned control ID"""
            self.input_field_index = None
            """If this control is an input field, once Compile() returns this will hold its index. This is used only to compute the possible STARTITEM index"""
            self.arg = None
            """Control argument value. This could be one element or a list/tuple (for multiple args per control)"""
            self.form = None
            """Reference to the parent form. It is filled by Form.Add()"""
            self.form_hasattr = False

        def get_tag(self):
            """
            Control tag character. One of Form.FT_XXXX.
            The form class will expand the {} notation and replace them with the tags
            """
            pass

        def get_arg(self):
            """
            Control returns the parameter to be pushed on the stack
            (Of ask_form())
            """
            return self.arg

        def free(self):
            """
            Free the control
            """
            self.form = None

        def is_input_field(self):
            """
            Return True if this field acts as an input
            """
            return False


    class LabelControl(Control):
        """
        Base class for static label control
        """

        def __init__(self, tp):
            Form.Control.__init__(self)
            self.tp = tp

        def get_tag(self):
            return '%%%d%s' % (self.id, self.tp)


    class StringLabel(LabelControl):
        """
        String label control
        """

        def __init__(self, value, tp=None, size=ida_pro.MAXSTR):
            """
            Type field can be one of:
            A - ascii string
            T - type declaration
            I - ident
            F - folder
            f - file
            X - command
            """
            if tp is None:
                tp = Form.FT_ASCII
            Form.LabelControl.__init__(self, tp)
            self.size = size
            self.arg = Form.create_string_buffer(value, size)


    class NumericLabel(LabelControl, NumericArgument):
        """
        Numeric label control
        """

        def __init__(self, value, tp=None):
            if tp is None:
                tp = Form.FT_HEX
            Form.LabelControl.__init__(self, tp)
            Form.NumericArgument.__init__(self, tp, value)


    class GroupItemControl(Control):
        """
        Base class for group control items
        """

        def __init__(self, tag, parent):
            Form.Control.__init__(self)
            self.tag = tag
            self.parent = parent
            self.pos = 0

        def assign_pos(self):
            self.pos = self.parent.next_child_pos()

        def get_tag(self):
            return '%s%d' % (self.tag, self.id)

        def is_input_field(self):
            return True


    class ChkGroupItemControl(GroupItemControl):
        """
        Checkbox group item control
        """

        def __init__(self, tag, parent):
            Form.GroupItemControl.__init__(self, tag, parent)

        def __get_value(self):
            return self.parent.value & 1 << self.pos != 0

        def __set_value(self, v):
            pv = self.parent.value
            if v:
                pv = pv | 1 << self.pos
            else:
                pv = pv & ~(1 << self.pos)
            self.parent.value = pv
        checked = property(__get_value, __set_value)
        """Get/Sets checkbox item check status"""


    class RadGroupItemControl(GroupItemControl):
        """
        Radiobox group item control
        """

        def __init__(self, tag, parent):
            Form.GroupItemControl.__init__(self, tag, parent)

        def __get_value(self):
            return self.parent.value == self.pos

        def __set_value(self, v):
            self.parent.value = self.pos
        selected = property(__get_value, __set_value)
        """Get/Sets radiobox item selection status"""


    class GroupControl(Control, NumericArgument):
        """
        Base class for group controls
        """

        def __init__(self, children_names, tag, value=0):
            Form.Control.__init__(self)
            self.children_names = children_names
            self.tag = tag
            self._reset()
            Form.NumericArgument.__init__(self, Form._FT_USHORT, value)

        def _reset(self):
            self.childpos = 0

        def next_child_pos(self):
            v = self.childpos
            self.childpos += 1
            return v

        def get_tag(self):
            return '%d' % self.id


    class ChkGroupControl(GroupControl):
        """
        Checkbox group control class.
        It holds a set of checkbox controls
        """
        ItemClass = None
        """
        Group control item factory class instance
        We need this because later we won't be treating ChkGroupControl or RadGroupControl
        individually, instead we will be working with GroupControl in general.
        """

        def __init__(self, children_names, value=0, secondary=False):
            if Form.ChkGroupControl.ItemClass is None:
                Form.ChkGroupControl.ItemClass = Form.ChkGroupItemControl
            Form.GroupControl.__init__(self, children_names, Form.
                FT_CHKGRP2 if secondary else Form.FT_CHKGRP, value)


    class RadGroupControl(GroupControl):
        """
        Radiobox group control class.
        It holds a set of radiobox controls
        """
        ItemClass = None

        def __init__(self, children_names, value=0, secondary=False):
            """
            Creates a radiogroup control.
            @param children_names: A tuple containing group item names
            @param value: Initial selected radio item
            @param secondory: Allows rendering one the same line as the previous group control.
                              Use this if you have another group control on the same line.
            """
            if Form.RadGroupControl.ItemClass is None:
                Form.RadGroupControl.ItemClass = Form.RadGroupItemControl
            Form.GroupControl.__init__(self, children_names, Form.
                FT_RADGRP2 if secondary else Form.FT_RADGRP, value)


    class InputControl(Control):
        """
        Generic form input control.
        It could be numeric control, string control, directory/file browsing, etc...
        """

        def __init__(self, tp, width, swidth, hlp=None, is_relative_offset=
            False):
            """
            @param width:  The maximum possible number of characters that
                           can be entered into the input field
            @param swidth: The width of visible part of the input field
            """
            Form.Control.__init__(self)
            self.tp = tp
            self.width = width
            self.swidth = swidth
            self.hlp = hlp
            self.is_relative_offset = is_relative_offset

        def get_tag(self):
            return '%s%d:%s%s:%s:%s' % (self.tp, self.id, '+' if self.
                is_relative_offset else '', self.width, self.swidth, ':' if
                self.hlp is None else self.hlp)

        def is_input_field(self):
            return True


    class NumericInput(InputControl, NumericArgument):
        """
        A composite class serving as a base numeric input control class
        """

        def __init__(self, tp=None, value=0, width=50, swidth=10, hlp=None,
            is_relative_offset=False, i64=None):
            if tp is None:
                tp = Form.FT_HEX
            Form.InputControl.__init__(self, tp, width, swidth, hlp,
                is_relative_offset)
            Form.NumericArgument.__init__(self, self.tp, value, i64=i64)


    class ColorInput(NumericInput):
        """
        Color button input control
        """

        def __init__(self, value=0):
            """
            @param value: Initial color value in RGB
            """
            Form.NumericInput.__init__(self, tp=Form.FT_COLOR, value=value,
                i64=False)


    class StringInput(InputControl, StringArgument):
        """
        Base string input control class.
        This class also constructs a StringArgument
        """

        def __init__(self, tp=None, width=ida_pro.MAXSTR, swidth=40, hlp=
            None, value=None, size=None):
            """
            @param width: String size. But in some cases it has special meaning. For example in FileInput control.
                          If you want to define the string buffer size then pass the 'size' argument
            @param swidth: Control width
            @param value: Initial value
            @param size: String size
            """
            if tp is None:
                tp = Form.FT_ASCII
            if not size:
                size = width
            Form.InputControl.__init__(self, tp, width, swidth, hlp)
            Form.StringArgument.__init__(self, size=size, value=value)


    class FileInput(StringInput):
        """
        File Open/Save input control
        """

        def __init__(self, width=512, swidth=80, save=False, open=False,
            hlp=None, value=None):
            if save == open:
                raise ValueError('Invalid mode. Choose either open or save')
            if width < 512:
                raise ValueError('Invalid width. Must be greater than 512.')
            Form.StringInput.__init__(self, tp=Form.FT_FILE, width='1' if
                save else '0', swidth=swidth, hlp=hlp, size=width, value=value)


    class DirInput(StringInput):
        """
        Directory browsing control
        """

        def __init__(self, width=512, swidth=80, hlp=None, value=None):
            if width < 512:
                raise ValueError('Invalid width. Must be greater than 512.')
            Form.StringInput.__init__(self, tp=Form.FT_DIR, width=width,
                swidth=swidth, hlp=hlp, size=width, value=value)


    class ButtonInput(InputControl):
        """
        Button control.
        A handler along with a 'code' (numeric value) can be associated with the button.
        This way one handler can handle many buttons based on the button code (or in other terms id or tag)
        """

        def __init__(self, handler, code='', swidth='', hlp=None):
            """
            @param handler: Button handler. A callback taking one argument which is the code.
            @param code: A code associated with the button and that is later passed to the handler.
            """
            Form.InputControl.__init__(self, Form.FT_BUTTON, code, swidth, hlp)
            self.handler = handler
            self.arg = _BUTTONCB_T(self.helper_cb)

        def helper_cb(self, button_code, p_fa):
            self.form.p_fa = p_fa
            r = self.handler(button_code)
            return 0 if r is None else r

        def is_input_field(self):
            return False


    class FormChangeCb(Control):
        """
        Form change handler.
        This can be thought of like a dialog procedure.
        Everytime a form action occurs, this handler will be called along with the control id.
        The programmer can then call various form actions accordingly:
          - EnableField
          - ShowField
          - MoveField
          - GetFieldValue
          - etc...

        Special control IDs: -1 (The form is initialized) and -2 (Ok has been clicked)

        """

        def __init__(self, handler):
            """
            Constructs the handler.
            @param handler: The handler (preferrably a member function of a class derived from the Form class).
            """
            Form.Control.__init__(self)
            self.handler = handler
            self.arg = _FORMCHGCB_T(self.helper_cb)

        def helper_cb(self, fid, p_fa):
            self.form.p_fa = p_fa
            r = self.handler(fid)
            return 0 if r is None else r

        def get_tag(self):
            return Form.FT_FORMCHG

        def free(self):
            Form.Control.free(self)
            self.handler = None


    class EmbeddedChooserControl(InputControl):
        """
        Embedded chooser control.
        This control links to a Chooser2 control created with the 'embedded=True'
        """

        def __init__(self, chooser=None, swidth=40, hlp=None):
            """
            Embedded chooser control

            @param chooser: A chooser2 instance (must be constructed with 'embedded=True')
            """
            if chooser is None or not isinstance(chooser, Choose):
                raise ValueError('Invalid chooser passed.')
            emb = chooser.Embedded(create_chobj=True)
            if emb is None:
                raise ValueError('Failed to create embedded chooser instance.')
            Form.InputControl.__init__(self, Form.FT_ECHOOSER, '', swidth)
            self.selobj = ida_pro.sizevec_t()
            if sys.version_info.major >= 3:
                sel = self.selobj.this.__int__()
            else:
                sel = self.selobj.this.__long__()
            p_embedded = ctypes.pointer(ctypes.c_void_p.from_address(emb))
            p_sel = ctypes.pointer(ctypes.c_void_p.from_address(sel))
            self.arg = p_embedded, p_sel
            self.chooser = chooser
            self.size = 0
        value = property(lambda self: self.chooser)
        """Returns the embedded chooser instance"""

        def __get_selection__(self):
            if len(self.selobj):
                out = []
                for item in self.selobj:
                    out.append(int(item))
                return out
        selection = property(__get_selection__)
        """Returns the selection"""

        def free(self):
            """
            Frees the embedded chooser data
            """
            self.chooser.Close()
            self.chooser = None
            Form.Control.free(self)


    class DropdownListControl(InputControl, ida_pro._qstrvec_t):
        """
        Dropdown control
        This control allows manipulating a dropdown control
        """

        def __init__(self, items=[], readonly=True, selval=0, width=50,
            swidth=50, hlp=None):
            """
            @param items: A string list of items used to prepopulate the control
            @param readonly: Specifies whether the dropdown list is editable or not
            @param selval: The preselected item index (when readonly) or text value (when editable)
            @param width: the control width (n/a if the dropdown list is readonly)
            @param swidth: string width
            """
            if readonly:
                width = 0
            Form.InputControl.__init__(self, Form.FT_DROPDOWN_LIST, width,
                swidth, hlp)
            ida_pro._qstrvec_t.__init__(self, items)
            self.readonly = readonly
            if readonly:
                self.__selval = ctypes.c_int(selval)
                val_addr = ctypes.addressof(self.__selval)
            else:
                self.__selval = ida_pro._qstrvec_t([selval])
                val_addr = self.__selval.addressof(0)
            self.arg = ctypes.pointer(ctypes.c_void_p.from_address(self.
                clink_ptr)), ctypes.pointer(ctypes.c_void_p.from_address(
                val_addr))

        def __set_selval(self, val):
            if self.readonly:
                self.__selval.value = val
            else:
                self.__selval[0] = val

        def __get_selval(self):
            return self.__selval.value if self.readonly else self.__selval[0]
        value = property(__get_selval, __set_selval)
        selval = property(__get_selval, __set_selval)
        """
        Read/write the selection value.
        The value is used as an item index in readonly mode or text value in editable mode
        This value can be used only after the form has been closed.
        """

        def free(self):
            self._free()

        def set_items(self, items):
            """Sets the dropdown list items"""
            self.from_list(items)


    class MultiLineTextControl(InputControl, textctrl_info_t):
        """
        Multi line text control.
        This class inherits from textctrl_info_t. Thus the attributes are also inherited
        This control allows manipulating a multilinetext control
        """

        def __init__(self, text='', flags=0, tabsize=0, width=50, swidth=50,
            hlp=None):
            """
            @param text: Initial text value
            @param flags: One of textctrl_info_t.TXTF_.... values
            @param tabsize: Tab size
            @param width: Display width
            @param swidth: String width
            """
            Form.InputControl.__init__(self, Form.FT_MULTI_LINE_TEXT, width,
                swidth, hlp)
            textctrl_info_t.__init__(self, text=text, flags=flags, tabsize=
                tabsize)
            self.arg = ctypes.pointer(ctypes.c_void_p.from_address(self.
                clink_ptr))

        def free(self):
            self._free()

    def __init__(self, form, controls):
        """
        Contruct a Form class.
        This class wraps around ask_form() or open_form() and provides an easier / alternative syntax for describing forms.
        The form control names are wrapped inside the opening and closing curly braces and the control themselves are
        defined and instantiated via various form controls (subclasses of Form).

        @param form: The form string
        @param controls: A dictionary containing the control name as a _key_ and control object as _value_
        """
        self._reset()
        self.form = form
        """Form string"""
        self.controls = controls
        """Dictionary of controls"""
        self.__args = None
        self.title = None
        """The Form title. It will be filled when the form is compiled"""
        self.modal = True
        """By default, forms are modal"""
        self.openform_flags = 0
        """
        If non-modal, these flags will be passed to open_form.
        This is an OR'ed combination of the PluginForm.FORM_* values.
        """

    def Free(self):
        """
        Frees all resources associated with a compiled form.
        Make sure you call this function when you finish using the form.
        """
        for name, ctrl in self.__controls.items():
            if ctrl.parent_hasattr:
                delattr(self, name)
                ctrl.parent_hasattr = False
            ctrl.free()
        self._reset()
        _ida_kernwin.py_unregister_compiled_form(self)

    def _reset(self):
        """
        Resets the Form class state variables
        """
        self.__controls = {}
        self.__ctrl_id = 1

    def __getitem__(self, name):
        """Returns a control object by name"""
        return self.__controls[name]

    def Add(self, name, ctrl, mkattr=True):
        """
        Low level function. Prefer AddControls() to this function.
        This function adds one control to the form.

        @param name: Control name
        @param ctrl: Control object
        @param mkattr: Create control name / control object as a form attribute
        """
        ctrl.id = self.__ctrl_id
        self.__ctrl_id += 1
        if mkattr:
            setattr(self, name, ctrl)
            ctrl.parent_hasattr = True
        self.__controls[name] = ctrl
        ctrl.form = self
        if isinstance(ctrl, Form.GroupControl):
            self._AddGroup(ctrl, mkattr)

    def FindControlById(self, id):
        """
        Finds a control instance given its id
        """
        for ctrl in self.__controls.values():
            if ctrl.id == id:
                return ctrl
        return None

    @staticmethod
    def _ParseFormTitle(form):
        """
        Parses the form's title from the form text
        """
        help_state = 0
        for i, line in enumerate(form.split('\n')):
            if line.startswith('STARTITEM ') or line.startswith('BUTTON '):
                continue
            elif help_state == 0 and line == 'HELP':
                help_state = 1
                continue
            elif help_state == 1 and line == 'ENDHELP':
                help_state = 2
                continue
            return line.strip()
        return None

    def _AddGroup(self, Group, mkattr=True):
        """
        Internal function.
        This function expands the group item names and creates individual group item controls

        @param Group: The group class (checkbox or radio group class)
        """
        for child_name in sorted(Group.children_names):
            self.Add(child_name, Group.ItemClass(Group.tag, Group), mkattr)

    def AddControls(self, controls, mkattr=True):
        """
        Adds controls from a dictionary.
        The dictionary key is the control name and the value is a Form.Control object
        @param controls: The control dictionary
        """
        for name in sorted(controls.keys()):
            self.Add(name, controls[name], mkattr)

    def CompileEx(self, form):
        """
        Low level function.
        Compiles (parses the form syntax and adds the control) the form string and
        returns the argument list to be passed the argument list to ask_form().

        The form controls are wrapped inside curly braces: {ControlName}.

        A special operator can be used to return the index of a given control by its name: {id:ControlName}.
        This is useful when you use the STARTITEM form keyword to set the initially focused control.
        (note that, technically, the index is not the same as the ID; that's because STARTITEM
        uses raw, 0-based indexes rather than control IDs to determine the focused widget.)

        @param form: Compiles the form and returns the arguments needed to be passed to ask_form()
        """
        args = [None]
        if not self.modal:
            args.append(self.openform_flags | 128)
        ctrlcnt = 1
        for ctrl in self.__controls.values():
            if isinstance(ctrl, Form.GroupControl):
                ctrl._reset()

        def next_control(form, p, first_pass):
            i1 = form.find('{', p)
            if i1 < 0:
                return form, None, None, None
            if form[i1 - 1] == '\\' and i1 > 0:
                if first_pass:
                    return next_control(form, i1 + 1, first_pass)
                else:
                    form = form[:i1 - 1] + form[i1:]
                    return next_control(form, i1, first_pass)
            i2 = form.find('}', i1)
            if i2 < 0:
                raise SyntaxError("No matching closing brace '}'")
            ctrlname = form[i1 + 1:i2]
            if not ctrlname:
                raise ValueError('Control %d has an invalid name!' % ctrlcnt)
            return form, i1, i2, ctrlname
        control_count = 0
        last_input_field_index = 0
        p = 0
        while True:
            form, i1, i2, ctrlname = next_control(form, p, first_pass=True)
            if ctrlname is None:
                break
            p = i2
            if ctrlname.startswith('id:'):
                continue
            ctrl = self.__controls.get(ctrlname, None)
            if ctrl is None:
                raise ValueError("No matching control '%s'" % ctrlname)
            if isinstance(ctrl, Form.FormChangeCb) and control_count > 0:
                raise SyntaxError(
                    "Control '%s' should be the first control in the form" %
                    ctrlname)
            if ctrl.is_input_field():
                ctrl.input_field_index = last_input_field_index
                last_input_field_index += 1
            control_count += 1
        p = 0
        while True:
            form, i1, i2, ctrlname = next_control(form, p, first_pass=False)
            if ctrlname is None:
                break
            if ctrlname.startswith('id:'):
                idfunc = True
                ctrlname = ctrlname[3:]
            else:
                idfunc = False
            ctrl = self.__controls.get(ctrlname, None)
            if ctrl is None:
                raise ValueError("No matching control '%s'" % ctrlname)
            if idfunc:
                tag = str(ctrl.input_field_index if ctrl.input_field_index
                     is not None else ctrl.id)
            else:
                tag = ctrl.get_tag()
            taglen = len(tag)
            form = form[:i1] + tag + form[i2 + 1:]
            p = i1 + taglen
            if idfunc:
                continue
            if isinstance(ctrl, Form.GroupItemControl):
                ctrl.assign_pos()
            else:
                arg = ctrl.get_arg()
                if isinstance(arg, (list, tuple)):
                    args.extend(arg)
                else:
                    args.append(arg)
            ctrlcnt += 1
        if form.find(Form.FT_FORMCHG) < 0:
            form = form + Form.FT_FORMCHG
            fccb = Form.FormChangeCb(lambda *args: 1)
            self.Add('___dummyfchgcb', fccb)
            if self.modal:
                inspos = 1
            else:
                inspos = 2
            args.insert(inspos, fccb.get_arg())
        if sys.version_info.major >= 3:
            args[0] = form.encode('UTF-8')
        else:
            args[0] = form
        self.title = self._ParseFormTitle(form)
        return args

    def Compile(self):
        """
        Compiles a form and returns the form object (self) and the argument list.
        The form object will contain object names corresponding to the form elements

        @return: It will raise an exception on failure. Otherwise the return value is ignored
        """
        self._reset()
        self.AddControls(self.controls)
        self.__args = self.CompileEx(self.form)
        _ida_kernwin.py_register_compiled_form(self)
        return self, self.__args

    def Compiled(self):
        """
        Checks if the form has already been compiled

        @return: Boolean
        """
        return self.__args is not None

    def _ChkCompiled(self):
        if not self.Compiled():
            raise SyntaxError('Form is not compiled')

    def Execute(self):
        """
        Displays a modal dialog containing the compiled form.
        @return: 1 - ok ; 0 - cancel
        """
        self._ChkCompiled()
        if not self.modal:
            raise SyntaxError('Form is not modal. Open() should be instead')
        return ask_form(*self.__args)

    def Open(self):
        """
        Opens a widget containing the compiled form.
        """
        self._ChkCompiled()
        if self.modal:
            raise SyntaxError('Form is modal. Execute() should be instead')
        open_form(*self.__args)

    def EnableField(self, ctrl, enable):
        """
        Enable or disable an input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_enable_field(self.p_fa, ctrl.id, enable
            )

    def ShowField(self, ctrl, show):
        """
        Show or hide an input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_show_field(self.p_fa, ctrl.id, show)

    def MoveField(self, ctrl, x, y, w, h):
        """
        Move/resize an input field

        @return: False - no such fiel
        """
        return _ida_kernwin.formchgcbfa_move_field(self.p_fa, ctrl.id, x, y,
            w, h)

    def GetFocusedField(self):
        """
        Get currently focused input field.
        @return: None if no field is selected otherwise the control ID
        """
        id = _ida_kernwin.formchgcbfa_get_focused_field(self.p_fa)
        return self.FindControlById(id)

    def SetFocusedField(self, ctrl):
        """
        Set currently focused input field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_set_focused_field(self.p_fa, ctrl.id)

    def RefreshField(self, ctrl):
        """
        Refresh a field
        @return: False - no such control
        """
        return _ida_kernwin.formchgcbfa_refresh_field(self.p_fa, ctrl.id)

    def Close(self, close_normally):
        """
        Close the form
        @param close_normally:
                   1: form is closed normally as if the user pressed Enter
                   0: form is closed abnormally as if the user pressed Esc
        @return: None
        """
        return _ida_kernwin.formchgcbfa_close(self.p_fa, close_normally)

    def GetControlValue(self, ctrl):
        """
        Returns the control's value depending on its type
        @param ctrl: Form control instance
        @return:
            - color button, radio controls: integer
            - file/dir input, string input and string label: string
            - embedded chooser control (0-based indices of selected items): integer list
            - for multilinetext control: textctrl_info_t
            - dropdown list controls: string (when editable) or index (when readonly)
            - None: on failure
        """
        tid, size = self.ControlToFieldTypeIdAndSize(ctrl)
        r = _ida_kernwin.formchgcbfa_get_field_value(self.p_fa, ctrl.id,
            tid, size)
        if r is not None and tid == 7:
            return textctrl_info_t(text=r[0], flags=r[1], tabsize=r[2])
        else:
            return r

    def SetControlValue(self, ctrl, value):
        """
        Set the control's value depending on its type
        @param ctrl: Form control instance
        @param value:
            - embedded chooser: a 0-base indices list to select embedded chooser items
            - multilinetext: a textctrl_info_t
            - dropdown list: an integer designating the selection index if readonly
                             a string designating the edit control value if not readonly
        @return: Boolean true on success
        """
        tid, _ = self.ControlToFieldTypeIdAndSize(ctrl)
        return _ida_kernwin.formchgcbfa_set_field_value(self.p_fa, ctrl.id,
            tid, value)

    @staticmethod
    def ControlToFieldTypeIdAndSize(ctrl):
        """
        Converts a control object to a tuple containing the field id
        and the associated buffer size
        """
        if isinstance(ctrl, Form.DropdownListControl):
            return 8, 1 if ctrl.readonly else 0
        elif isinstance(ctrl, Form.MultiLineTextControl):
            return 7, 0
        elif isinstance(ctrl, Form.EmbeddedChooserControl):
            return 5, 0
        elif isinstance(ctrl, (Form.GroupItemControl, Form.GroupControl)):
            return 2, 0
        elif isinstance(ctrl, Form.StringLabel):
            return 3, min(ida_pro.MAXSTR, ctrl.size)
        elif isinstance(ctrl, Form.ColorInput):
            return 4, 0
        elif isinstance(ctrl, Form.NumericInput):
            return 6, ord(ctrl.tp[0])
        elif isinstance(ctrl, Form.InputControl):
            return 1, ctrl.size
        else:
            raise NotImplementedError('Not yet implemented')


try:
    import ctypes
    Form.NumericArgument.DefI64 = _ida_idaapi.BADADDR == 18446744073709551615
    __ask_form_callable = ctypes.CFUNCTYPE(ctypes.c_int)(_ida_kernwin.
        py_get_ask_form())
    __ask_form_callable.argtypes = [ctypes.c_char_p]
    __open_form_callable = ctypes.CFUNCTYPE(ctypes.c_void_p)(_ida_kernwin.
        py_get_open_form())
    __open_form_callable.argtypes = [ctypes.c_char_p, ctypes.c_uint32]
except:

    def __ask_form_callable(*args):
        warning('ask_form() needs ctypes library in order to work')
        return 0

    def __open_form_callable(*args):
        warning('open_form() needs ctypes library in order to work')


def __call_form_callable(call, *args):
    assert len(args)
    with disabled_script_timeout_t():
        if sys.version_info.major >= 3 and isinstance(args[0], str):
            largs = list(args)
            largs[0] = largs[0].encode('UTF-8')
            args = tuple(largs)
        r = call(*args)
    return r


def ask_form(*args):
    """Display a dialog box and wait for the user. If the form contains the "BUTTON NO <title>" keyword, then the return values are the same as in the ask_yn() function (Button IDs) 
        
@param form: dialog box as a string. see ask_form()/open_form()
@retval 0: no memory to display or form syntax error (a warning is displayed in this case). the user pressed the 'No' button (if the form has it) or the user cancelled the dialog otherwise. all variables retain their original values.
@retval 1: ok, all input fields are filled and validated.
@retval -1: the form has the 'No' button and the user cancelled the dialog"""
    return __call_form_callable(__ask_form_callable, *args)


def open_form(*args):
    """Display a dockable modeless dialog box and return a handle to it. The modeless form can be closed in the following ways:
* by pressing the small 'x' in the window title
* by calling form_actions_t::close() from the form callback (form_actions_t)



@param form: dialog box as a string. see ask_form()/open_form()
@param flags: Widget open flags
@returns handle to the form or nullptr. the handle can be used with TWidget functions: close_widget()/activate_widget()/etc"""
    if len(args) == 1:
        args = args[0], 0
    return __call_form_callable(__open_form_callable, *args)


def install_command_interpreter(py_obj: 'PyObject *') ->int:
    """Install command line interpreter (ui_install_cli)
"""
    return _ida_kernwin.install_command_interpreter(py_obj)


def remove_command_interpreter(cli_idx: int) ->None:
    """Remove command line interpreter (ui_install_cli)
"""
    return _ida_kernwin.remove_command_interpreter(cli_idx)


import ida_idaapi


class cli_t(ida_idaapi.pyidc_opaque_object_t):
    """
    cli_t wrapper class.

    This class allows you to implement your own command line interface handlers.
    """

    def __init__(self):
        self.__cli_idx = -1
        self.__clink__ = None

    def __del__(self):
        self.unregister()

    def register(self, flags=0, sname=None, lname=None, hint=None):
        """
        Registers the CLI.

        @param flags: Feature bits. No bits are defined yet, must be 0
        @param sname: Short name (displayed on the button)
        @param lname: Long name (displayed in the menu)
        @param hint:  Hint for the input line

        @return Boolean: True-Success, False-Failed
        """
        if self.__cli_idx >= 0:
            return True
        if sname is not None:
            self.sname = sname
        if lname is not None:
            self.lname = lname
        if hint is not None:
            self.hint = hint
        self.__cli_idx = _ida_kernwin.install_command_interpreter(self)
        return False if self.__cli_idx < 0 else True

    def unregister(self):
        """
        Unregisters the CLI (if it was registered)
        """
        if self.__cli_idx < 0:
            return False
        _ida_kernwin.remove_command_interpreter(self.__cli_idx)
        self.__cli_idx = -1
        return True

    def OnExecuteLine(self, line):
        """
        The user pressed Enter. The CLI is free to execute the line immediately or ask for more lines.

        This callback is mandatory.

        @param line: typed line(s)
        @return Boolean: True-executed line, False-ask for more lines
        """
        return True

    def OnKeydown(self, line, x, sellen, vkey, shift):
        """
        A keyboard key has been pressed
        This is a generic callback and the CLI is free to do whatever it wants.

        This callback is optional.

        @param line: current input line
        @param x: current x coordinate of the cursor
        @param sellen: current selection length (usually 0)
        @param vkey: virtual key code. if the key has been handled, it should be returned as zero
        @param shift: shift state

        @return:
            None - Nothing was changed
            tuple(line, x, sellen, vkey): if either of the input line or the x coordinate or the selection length has been modified.
            It is possible to return a tuple with None elements to preserve old values. Example: tuple(new_line, None, None, None) or tuple(new_line)
        """
        return None

    def OnFindCompletions(self, line, x):
        """
        The user pressed Tab. Return a list of completions

        This callback is optional.

        @param line: the current line (string)
        @param x: the index where the cursor is (int)

        @return: None if no completion could be generated, otherwise a tuple:
            (completions : Sequence[str], hints : Sequence[str], docs: Sequence[str],
              match_start: int, match_end: int)
        """
        return None


class View_Hooks(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v),
        doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, _flags: int=0, _hkcb_flags: int=1):
        if self.__class__ == View_Hooks:
            _self = None
        else:
            _self = self
        _ida_kernwin.View_Hooks_swiginit(self, _ida_kernwin.new_View_Hooks(
            _self, _flags, _hkcb_flags))

    def hook(self) ->bool:
        return _ida_kernwin.View_Hooks_hook(self)

    def unhook(self) ->bool:
        return _ida_kernwin.View_Hooks_unhook(self)

    def view_activated(self, view: 'TWidget *') ->None:
        """A view is activated 
          
@param view: (TWidget *)"""
        return _ida_kernwin.View_Hooks_view_activated(self, view)

    def view_deactivated(self, view: 'TWidget *') ->None:
        """A view is deactivated 
          
@param view: (TWidget *)"""
        return _ida_kernwin.View_Hooks_view_deactivated(self, view)

    def view_keydown(self, view: 'TWidget *', key: int, state:
        'view_event_state_t') ->None:
        """Key down event 
          
@param view: (TWidget *)
@param key: (int)
@param state: (::view_event_state_t)"""
        return _ida_kernwin.View_Hooks_view_keydown(self, view, key, state)

    def view_click(self, view: 'TWidget *', event: 'view_mouse_event_t'
        ) ->None:
        """Click event 
          
@param view: (TWidget *)
@param event: (const view_mouse_event_t *)"""
        return _ida_kernwin.View_Hooks_view_click(self, view, event)

    def view_dblclick(self, view: 'TWidget *', event: 'view_mouse_event_t'
        ) ->None:
        """Double click event 
          
@param view: (TWidget *)
@param event: (const view_mouse_event_t *)"""
        return _ida_kernwin.View_Hooks_view_dblclick(self, view, event)

    def view_curpos(self, view: 'TWidget *') ->None:
        """Cursor position changed 
          
@param view: (TWidget *)"""
        return _ida_kernwin.View_Hooks_view_curpos(self, view)

    def view_created(self, view: 'TWidget *') ->None:
        """A view is being created. 
          
@param view: (TWidget *)"""
        return _ida_kernwin.View_Hooks_view_created(self, view)

    def view_close(self, view: 'TWidget *') ->None:
        """View closed 
          
@param view: (TWidget *)"""
        return _ida_kernwin.View_Hooks_view_close(self, view)

    def view_switched(self, view: 'TWidget *', rt: 'tcc_renderer_type_t'
        ) ->None:
        """A view's renderer has changed. 
          
@param view: (TWidget *)
@param rt: (tcc_renderer_type_t)"""
        return _ida_kernwin.View_Hooks_view_switched(self, view, rt)

    def view_mouse_over(self, view: 'TWidget *', event: 'view_mouse_event_t'
        ) ->None:
        """The user moved the mouse over (or out of) a node or an edge. This is only relevant in a graph view. 
          
@param view: (TWidget *)
@param event: (const view_mouse_event_t *)"""
        return _ida_kernwin.View_Hooks_view_mouse_over(self, view, event)

    def view_loc_changed(self, view: 'TWidget *', now:
        'lochist_entry_t const *', was: 'lochist_entry_t const *') ->None:
        """The location for the view has changed (can be either the place_t, the renderer_info_t, or both.) 
          
@param view: (TWidget *)
@param now: (const lochist_entry_t *)
@param was: (const lochist_entry_t *)"""
        return _ida_kernwin.View_Hooks_view_loc_changed(self, view, now, was)

    def view_mouse_moved(self, view: 'TWidget *', event: 'view_mouse_event_t'
        ) ->None:
        """The mouse moved on the view 
          
@param view: (TWidget *)
@param event: (const view_mouse_event_t *)"""
        return _ida_kernwin.View_Hooks_view_mouse_moved(self, view, event)
    __swig_destroy__ = _ida_kernwin.delete_View_Hooks

    def __disown__(self):
        self.this.disown()
        _ida_kernwin.disown_View_Hooks(self)
        return weakref.proxy(self)


_ida_kernwin.View_Hooks_swigregister(View_Hooks)


class CustomIDAMemo(View_Hooks):

    def __init__(self):
        View_Hooks.__init__(self)

    def _graph_item_tuple(self, ve):
        item = None
        if ve.rtype in [TCCRT_GRAPH, TCCRT_PROXIMITY]:
            item = ve.location.item
        if item is not None:
            if item.is_node:
                return item.node,
            else:
                return item.elp.e.src, item.elp.e.dst
        else:
            return ()

    @staticmethod
    def _dummy_cb(*args):
        pass

    def _get_cb(self, view, cb_name):
        cb = CustomIDAMemo._dummy_cb
        if view == self.GetWidget():
            cb = getattr(self, cb_name, cb)
        return cb

    def _get_cb_arity(self, cb):
        import sys
        import inspect
        if sys.version_info.major >= 3:
            return len(inspect.getfullargspec(cb).args)
        else:
            return len(inspect.getargspec(cb).args)

    def view_activated(self, view):
        return self._get_cb(view, 'OnViewActivated')()

    def view_deactivated(self, view):
        return self._get_cb(view, 'OnViewDeactivated')()

    def view_keydown(self, view, key, state):
        return self._get_cb(view, 'OnViewKeydown')(key, state)

    def view_click(self, view, ve):
        cb = self._get_cb(view, 'OnViewClick')
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            args = [ve.x, ve.y, ve.state]
            if arity >= 5:
                args.append(ve.button)
                if arity >= 6:
                    args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_dblclick(self, view, ve):
        cb = self._get_cb(view, 'OnViewDblclick')
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            args = [ve.x, ve.y, ve.state]
            if arity >= 5:
                args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_curpos(self, view, *args):
        return self._get_cb(view, 'OnViewCurpos')()

    def view_close(self, view, *args):
        rc = self._get_cb(view, 'OnClose')()
        if view == self.GetWidget():
            ida_idaapi.pycim_view_close(self)
        return rc

    def view_switched(self, view, rt):
        return self._get_cb(view, 'OnViewSwitched')(rt)

    def view_mouse_over(self, view, ve):
        cb = self._get_cb(view, 'OnViewMouseOver')
        if cb != CustomIDAMemo._dummy_cb:
            arity = self._get_cb_arity(cb)
            gitpl = self._graph_item_tuple(ve)
            args = [ve.x, ve.y, ve.state, len(gitpl), gitpl]
            if arity >= 7:
                args.append(ve.renderer_pos)
            return cb(*tuple(args))

    def view_loc_changed(self, view, now, was):
        return self._get_cb(view, 'OnViewLocationChanged')(now, was)

    def view_mouse_moved(self, view, ve):
        cb = self._get_cb(view, 'OnViewMouseMoved')
        if cb != CustomIDAMemo._dummy_cb:
            gitpl = self._graph_item_tuple(ve)
            return cb(ve.x, ve.y, ve.state, len(gitpl), gitpl, ve.renderer_pos)

    def _OnBind(self, hook):
        if hook:
            self.hook()
        else:
            self.unhook()

    def Refresh(self):
        """
        Refreshes the view. This causes the OnRefresh() to be called
        """
        ida_idaapi.pygc_refresh(self)

    def GetCurrentRendererType(self):
        return get_view_renderer_type(self.GetWidget())

    def SetCurrentRendererType(self, rtype):
        """
        Set the current view's renderer.

        @param rtype: The renderer type. Should be one of the idaapi.TCCRT_* values.
        """
        return set_view_renderer_type(self.GetWidget(), rtype)

    def SetNodeInfo(self, node_index, node_info, flags):
        """
        Set the properties for the given node.

        Example usage (set second nodes's bg color to red):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff0000
          inst.SetNodeInfo(1, p, idaapi.NIF_BG_COLOR)

        @param node_index: The node index.
        @param node_info: An idaapi.node_info_t instance.
        @param flags: An OR'ed value of NIF_* values.
        """
        import ida_graph
        return ida_graph.viewer_set_node_info(self.GetWidget(), node_index,
            node_info, flags)

    def SetNodesInfos(self, values):
        """
        Set the properties for the given nodes.

        Example usage (set first three nodes's bg color to purple):
          inst = ...
          p = idaapi.node_info_t()
          p.bg_color = 0x00ff00ff
          inst.SetNodesInfos({0 : p, 1 : p, 2 : p})

        @param values: A dictionary of 'int -> node_info_t' objects.
        """
        import ida_graph
        for node_index, node_info in values.items():
            ida_graph.viewer_set_node_info(self.GetWidget(), node_index,
                node_info, ida_graph.NIF_ALL)

    def GetNodeInfo(self, *args):
        """
        Get the properties for the given node.

        @param ni: A node_info_t instance
        @param node: The index of the node.
        @return: success
        """
        import ida_graph
        if len(args) < 2:
            ni, node = ida_graph.node_info_t(), args[0]
            if ida_graph.viewer_get_node_info(self.GetWidget(), ni, node):
                return ni.bg_color, ni.frame_color, ni.ea, ni.text
            else:
                return None
        else:
            ni, node = args[0], args[1]
            return ida_graph.viewer_get_node_info(self.GetWidget(), ni, node)

    def DelNodesInfos(self, *nodes):
        """
        Delete the properties for the given node(s).

        @param nodes: A list of node IDs
        """
        import ida_graph
        for n in nodes:
            ida_graph.viewer_del_node_info(self.GetWidget(), n)

    def CreateGroups(self, groups_infos):
        """
        Send a request to modify the graph by creating a
        (set of) group(s), and perform an animation.

        Each object in the 'groups_infos' list must be of the format:
        {
          "nodes" : [<int>, <int>, <int>, ...] # The list of nodes to group
          "text" : <string>                    # The synthetic text for that group
        }

        @param groups_infos: A list of objects that describe those groups.
        @return: A [<int>, <int>, ...] list of group nodes, or None (failure).
        """
        return ida_idaapi.pygc_create_groups(self, groups_infos)

    def DeleteGroups(self, groups, new_current=-1):
        """
        Send a request to delete the specified groups in the graph,
        and perform an animation.

        @param groups: A list of group node numbers.
        @param new_current: A node to focus on after the groups have been deleted
        @return: True on success, False otherwise.
        """
        return ida_idaapi.pygc_delete_groups(self, groups, new_current)

    def SetGroupsVisibility(self, groups, expand, new_current=-1):
        """
        Send a request to expand/collapse the specified groups in the graph,
        and perform an animation.

        @param groups: A list of group node numbers.
        @param expand: True to expand the group, False otherwise.
        @param new_current: A node to focus on after the groups have been expanded/collapsed.
        @return: True on success, False otherwise.
        """
        return ida_idaapi.pygc_set_groups_visibility(self, groups, expand,
            new_current)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return ida_idaapi.pycim_get_widget(self)

    def GetWidgetAsGraphViewer(self):
        """
        Return the graph_viewer_t underlying this view.

        @return: The graph_viewer_t underlying this view, or None.
        """
        return ida_idaapi.pycim_get_widget_as_graph_viewer(self)


import ida_idaapi
ida_idaapi.CustomIDAMemo = CustomIDAMemo


def pyidag_bind(_self: 'PyObject *') ->bool:
    return _ida_kernwin.pyidag_bind(_self)


def pyidag_unbind(_self: 'PyObject *') ->bool:
    return _ida_kernwin.pyidag_unbind(_self)


import _ida_kernwin


class IDAViewWrapper(CustomIDAMemo):
    """
    Deprecated. Use View_Hooks instead.

    Because the lifecycle of an IDAView is not trivial to track (e.g., a user
    might close, then re-open the same disassembly view), this wrapper doesn't
    bring anything superior to the View_Hooks: quite the contrary, as the
    latter is much more generic (and better maps IDA's internal model.)
    """

    def __init__(self, title):
        CustomIDAMemo.__init__(self)
        self._title = title

    def Bind(self):
        rc = _ida_kernwin.pyidag_bind(self)
        if rc:
            self.hook()
        return rc

    def Unbind(self):
        rc = _ida_kernwin.pyidag_unbind(self)
        if rc:
            self.unhook()
        return rc


def pyscv_init(py_link: 'PyObject *', title: str) ->'PyObject *':
    return _ida_kernwin.pyscv_init(py_link, title)


def pyscv_refresh(py_this: 'PyObject *') ->bool:
    return _ida_kernwin.pyscv_refresh(py_this)


def pyscv_get_current_line(py_this: 'PyObject *', mouse: bool, notags: bool
    ) ->'PyObject *':
    return _ida_kernwin.pyscv_get_current_line(py_this, mouse, notags)


def pyscv_is_focused(py_this: 'PyObject *') ->bool:
    return _ida_kernwin.pyscv_is_focused(py_this)


def pyscv_count(py_this: 'PyObject *') ->'size_t':
    return _ida_kernwin.pyscv_count(py_this)


def pyscv_show(py_this: 'PyObject *') ->bool:
    return _ida_kernwin.pyscv_show(py_this)


def pyscv_close(py_this: 'PyObject *') ->None:
    return _ida_kernwin.pyscv_close(py_this)


def pyscv_jumpto(py_this: 'PyObject *', ln: 'size_t', x: int, y: int) ->bool:
    return _ida_kernwin.pyscv_jumpto(py_this, ln, x, y)


def pyscv_get_line(py_this: 'PyObject *', nline: 'size_t') ->'PyObject *':
    return _ida_kernwin.pyscv_get_line(py_this, nline)


def pyscv_get_pos(py_this: 'PyObject *', mouse: bool) ->'PyObject *':
    return _ida_kernwin.pyscv_get_pos(py_this, mouse)


def pyscv_clear_lines(py_this: 'PyObject *') ->'PyObject *':
    return _ida_kernwin.pyscv_clear_lines(py_this)


def pyscv_add_line(py_this: 'PyObject *', py_sl: 'PyObject *') ->bool:
    return _ida_kernwin.pyscv_add_line(py_this, py_sl)


def pyscv_insert_line(py_this: 'PyObject *', nline: 'size_t', py_sl:
    'PyObject *') ->bool:
    return _ida_kernwin.pyscv_insert_line(py_this, nline, py_sl)


def pyscv_patch_line(py_this: 'PyObject *', nline: 'size_t', offs: 'size_t',
    value: int) ->bool:
    return _ida_kernwin.pyscv_patch_line(py_this, nline, offs, value)


def pyscv_del_line(py_this: 'PyObject *', nline: 'size_t') ->bool:
    return _ida_kernwin.pyscv_del_line(py_this, nline)


def pyscv_get_selection(py_this: 'PyObject *') ->'PyObject *':
    return _ida_kernwin.pyscv_get_selection(py_this)


def pyscv_get_current_word(py_this: 'PyObject *', mouse: bool) ->'PyObject *':
    return _ida_kernwin.pyscv_get_current_word(py_this, mouse)


def pyscv_edit_line(py_this: 'PyObject *', nline: 'size_t', py_sl: 'PyObject *'
    ) ->bool:
    return _ida_kernwin.pyscv_edit_line(py_this, nline, py_sl)


def pyscv_get_widget(py_this: 'PyObject *') ->'TWidget *':
    return _ida_kernwin.pyscv_get_widget(py_this)


class simplecustviewer_t(object):
    """The base class for implementing simple custom viewers"""


    class UI_Hooks_Trampoline(UI_Hooks):

        def __init__(self, v):
            UI_Hooks.__init__(self)
            self.hook()
            import weakref
            self.v = weakref.ref(v)

        def populating_widget_popup(self, form, popup_handle):
            my_form = self.v().GetWidget()
            if form == my_form:
                cb = self.v().OnPopup
                import sys
                import inspect
                handled = False
                if sys.version_info.major >= 3:
                    if len(inspect.getfullargspec(cb).args) == 3:
                        cb(my_form, popup_handle)
                        handled = True
                elif len(inspect.getargspec(cb).args) == 3:
                    cb(my_form, popup_handle)
                    handled = True
                if not handled:
                    cb()

    def __init__(self):
        self.__this = None
        self.ui_hooks_trampoline = self.UI_Hooks_Trampoline(self)

    @staticmethod
    def __make_sl_arg(line, fgcolor=None, bgcolor=None):
        return line if fgcolor is None and bgcolor is None else (line,
            fgcolor, bgcolor)

    def OnPopup(self, form, popup_handle):
        """
        Context menu popup is about to be shown. Create items dynamically if you wish
        @return: Boolean. True if you handled the event
        """
        pass

    def Create(self, title):
        """
        Creates the custom view. This should be the first method called after instantiation

        @param title: The title of the view
        @return: Boolean whether it succeeds or fails. It may fail if a window with the same title is already open.
                 In this case better close existing windows
        """
        self.title = title
        self.__this = _ida_kernwin.pyscv_init(self, title)
        return True if self.__this else False

    def Close(self):
        """
        Destroys the view.
        One has to call Create() afterwards.
        Show() can be called and it will call Create() internally.
        @return: Boolean
        """
        return _ida_kernwin.pyscv_close(self.__this)

    def Show(self):
        """
        Shows an already created view. It the view was closed, then it will call Create() for you
        @return: Boolean
        """
        return _ida_kernwin.pyscv_show(self.__this)

    def Refresh(self):
        return _ida_kernwin.pyscv_refresh(self.__this)

    def RefreshCurrent(self):
        """Refreshes the current line only"""
        return _ida_kernwin.pyscv_refresh(self.__this)

    def Count(self):
        """Returns the number of lines in the view"""
        return _ida_kernwin.pyscv_count(self.__this)

    def GetSelection(self):
        """
        Returns the selected range or None
        @return:
            - tuple(x1, y1, x2, y2)
            - None if no selection
        """
        return _ida_kernwin.pyscv_get_selection(self.__this)

    def ClearLines(self):
        """Clears all the lines"""
        _ida_kernwin.pyscv_clear_lines(self.__this)

    def AddLine(self, line, fgcolor=None, bgcolor=None):
        """
        Adds a colored line to the view
        @return: Boolean
        """
        return _ida_kernwin.pyscv_add_line(self.__this, self.__make_sl_arg(
            line, fgcolor, bgcolor))

    def InsertLine(self, lineno, line, fgcolor=None, bgcolor=None):
        """
        Inserts a line in the given position
        @return: Boolean
        """
        return _ida_kernwin.pyscv_insert_line(self.__this, lineno, self.
            __make_sl_arg(line, fgcolor, bgcolor))

    def EditLine(self, lineno, line, fgcolor=None, bgcolor=None):
        """
        Edits an existing line.
        @return: Boolean
        """
        return _ida_kernwin.pyscv_edit_line(self.__this, lineno, self.
            __make_sl_arg(line, fgcolor, bgcolor))

    def PatchLine(self, lineno, offs, value):
        """Patches an existing line character at the given offset. This is a low level function. You must know what you're doing"""
        return _ida_kernwin.pyscv_patch_line(self.__this, lineno, offs, value)

    def DelLine(self, lineno):
        """
        Deletes an existing line
        @return: Boolean
        """
        return _ida_kernwin.pyscv_del_line(self.__this, lineno)

    def GetLine(self, lineno):
        """
        Returns a line
        @param lineno: The line number
        @return:
            Returns a tuple (colored_line, fgcolor, bgcolor) or None
        """
        return _ida_kernwin.pyscv_get_line(self.__this, lineno)

    def GetCurrentWord(self, mouse=0):
        """
        Returns the current word
        @param mouse: Use mouse position or cursor position
        @return: None if failed or a String containing the current word at mouse or cursor
        """
        return _ida_kernwin.pyscv_get_current_word(self.__this, mouse)

    def GetCurrentLine(self, mouse=0, notags=0):
        """
        Returns the current line.
        @param mouse: Current line at mouse pos
        @param notags: If True then tag_remove() will be called before returning the line
        @return: Returns the current line (colored or uncolored) or None on failure
        """
        return _ida_kernwin.pyscv_get_current_line(self.__this, mouse, notags)

    def GetPos(self, mouse=0):
        """
        Returns the current cursor or mouse position.
        @param mouse: return mouse position
        @return: Returns a tuple (lineno, x, y)
        """
        return _ida_kernwin.pyscv_get_pos(self.__this, mouse)

    def GetLineNo(self, mouse=0):
        """Calls GetPos() and returns the current line number or -1 on failure"""
        r = self.GetPos(mouse)
        return -1 if not r else r[0]

    def Jump(self, lineno, x=0, y=0):
        return _ida_kernwin.pyscv_jumpto(self.__this, lineno, x, y)

    def IsFocused(self):
        """Returns True if the current view is the focused view"""
        return _ida_kernwin.pyscv_is_focused(self.__this)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.pyscv_get_widget(self.__this)


def plgform_new() ->'PyObject *':
    return _ida_kernwin.plgform_new()


def plgform_show(*args) ->bool:
    return _ida_kernwin.plgform_show(*args)


def plgform_close(py_link: 'PyObject *', options: int) ->None:
    return _ida_kernwin.plgform_close(py_link, options)


def plgform_get_widget(py_link: 'PyObject *') ->'TWidget *':
    return _ida_kernwin.plgform_get_widget(py_link)


import sys
import ida_idaapi


class PluginForm(object):
    """
    PluginForm class.

    This form can be used to host additional controls. Please check the PyQt example.
    """
    WOPN_MDI = 1
    WOPN_TAB = 2
    WOPN_RESTORE = _ida_kernwin.WOPN_RESTORE
    """if the widget was the only widget in a floating area the last time it was closed, it will be restored as floating, with the same position+size as before 
        """
    """
    if the widget is the only widget in a floating area when
    it is closed, remember that area's geometry. The next
    time that widget is created as floating (i.e., WOPN_DP_FLOATING)
    its geometry will be restored (e.g., "Execute script"
    """
    WOPN_ONTOP = 8
    WOPN_MENU = 16
    WOPN_CENTERED = 32
    WOPN_PERSIST = _ida_kernwin.WOPN_PERSIST
    """widget will remain available when starting or stopping debugger sessions
"""
    """form will persist until explicitly closed with Close()"""
    WOPN_DP_LEFT = _ida_kernwin.WOPN_DP_LEFT
    """Dock widget to the left of dest_ctrl.
"""
    """ Dock widget to the left of dest_ctrl"""
    WOPN_DP_TOP = _ida_kernwin.WOPN_DP_TOP
    """Dock widget above dest_ctrl.
"""
    """ Dock widget above dest_ctrl"""
    WOPN_DP_RIGHT = _ida_kernwin.WOPN_DP_RIGHT
    """Dock widget to the right of dest_ctrl.
"""
    """ Dock widget to the right of dest_ctrl"""
    WOPN_DP_BOTTOM = _ida_kernwin.WOPN_DP_BOTTOM
    """Dock widget below dest_ctrl.
"""
    """ Dock widget below dest_ctrl"""
    WOPN_DP_INSIDE = _ida_kernwin.WOPN_DP_INSIDE
    """Create a new tab bar with both widget and dest_ctrl.
"""
    """ Create a new tab bar with both widget and dest_ctrl"""
    WOPN_DP_TAB = _ida_kernwin.WOPN_DP_TAB
    """Place widget into a tab next to dest_ctrl, if dest_ctrl is in a tab bar (otherwise the same as WOPN_DP_INSIDE) 
        """
    """
    Place widget into a tab next to dest_ctrl,
    if dest_ctrl is in a tab bar
    (otherwise the same as #WOPN_DP_INSIDE)
    """
    WOPN_DP_BEFORE = _ida_kernwin.WOPN_DP_BEFORE
    """Place widget before dst_form in the tab bar instead of after; used with WOPN_DP_INSIDE and WOPN_DP_TAB 
        """
    """
    place widget before dst_form in the tab bar instead of after
    used with #WOPN_DP_INSIDE and #WOPN_DP_TAB
    """
    WOPN_DP_FLOATING = _ida_kernwin.WOPN_DP_FLOATING
    """Make widget floating.
"""
    """
    When floating or in a splitter (i.e., not tabbed),
    use the widget's size hint to determine the best
    geometry (Qt only)
    """
    WOPN_DP_SZHINT = _ida_kernwin.WOPN_DP_SZHINT
    """when floating or in a splitter (i.e., not tabbed), use the widget's size hint to determine the best geometry (Qt only) 
        """
    """ Make widget floating"""
    WOPN_DP_INSIDE_BEFORE = _ida_kernwin.WOPN_DP_INSIDE_BEFORE
    WOPN_DP_TAB_BEFORE = _ida_kernwin.WOPN_DP_TAB_BEFORE
    WOPN_CREATE_ONLY = {}

    def __init__(self):
        """
        """
        self.__clink__ = _ida_kernwin.plgform_new()

    def Show(self, caption, options=0):
        """
        Creates the form if not was not created or brings to front if it was already created

        @param caption: The form caption
        @param options: One of PluginForm.WOPN_ constants
        """
        if options == self.WOPN_CREATE_ONLY:
            options = -1
        else:
            options |= PluginForm.WOPN_DP_TAB | PluginForm.WOPN_RESTORE
        return _ida_kernwin.plgform_show(self.__clink__, self, caption, options
            )

    @staticmethod
    def _ensure_widget_deps(ctx):
        for modname in ['sip', 'QtWidgets']:
            if not hasattr(ctx, modname):
                import importlib
                setattr(ctx, modname, importlib.import_module('PyQt5.' +
                    modname))
    VALID_CAPSULE_NAME = b'$valid$'

    @staticmethod
    def TWidgetToQtPythonWidget(tw, ctx=sys.modules['__main__']):
        """
        Convert a TWidget* to a QWidget to be used by the Qt Python bindings
        """
        if type(tw).__name__ == 'SwigPyObject':
            ptr_l = int(tw)
        else:
            import ctypes
            ctypes.pythonapi.PyCapsule_GetPointer.restype = ctypes.c_void_p
            ctypes.pythonapi.PyCapsule_GetPointer.argtypes = [ctypes.
                py_object, ctypes.c_char_p]
            ptr_l = ctypes.pythonapi.PyCapsule_GetPointer(tw, PluginForm.
                VALID_CAPSULE_NAME)
        try:
            import shiboken6.Shiboken
            import PySide6.QtWidgets
            return shiboken6.Shiboken.wrapInstance(ptr_l, PySide6.QtWidgets
                .QWidget)
        except ImportError:
            PluginForm._ensure_widget_deps(ctx)
            vptr = ctx.sip.voidptr(ptr_l)
            return ctx.sip.wrapinstance(vptr.__int__(), ctx.QtWidgets.QWidget)
    TWidgetToPyQtWidget = TWidgetToQtPythonWidget
    FormToPyQtWidget = TWidgetToQtPythonWidget

    @staticmethod
    def QtWidgetToTWidget(w, ctx=sys.modules['__main__']):
        """
        Convert a QWidget to a TWidget* to be used by IDA

        @param ctx: Context. Reference to a module that already imported SIP and QtWidgets modules
        """
        PluginForm._ensure_widget_deps(ctx)
        as_long = ida_idaapi.long_type(ctx.sip.unwrapinstance(w))
        return TWidget__from_ptrval__(as_long)

    @staticmethod
    def TWidgetToPySideWidget(tw, ctx=sys.modules['__main__']):
        """
        Use this method to convert a TWidget* to a QWidget to be used by PySide

        @param ctx: Context. Reference to a module that already imported QtWidgets module
        """
        if tw is None:
            return None
        if type(tw).__name__ == 'SwigPyObject':
            ptr_l = ida_idaapi.long_type(tw)
            import ctypes
            ctypes.pythonapi.PyCapsule_New.restype = ctypes.py_object
            ctypes.pythonapi.PyCapsule_New.argtypes = [ctypes.c_void_p,
                ctypes.c_char_p, ctypes.c_void_p]
            tw = ctypes.pythonapi.PyCapsule_New(ptr_l, PluginForm.
                VALID_CAPSULE_NAME, 0)
        return ctx.QtGui.QWidget.FromCapsule(tw)
    FormToPySideWidget = TWidgetToPySideWidget

    def OnCreate(self, form):
        """
        This event is called when the plugin form is created.
        The programmer should populate the form when this event is triggered.

        @return: None
        """
        pass

    def OnClose(self, form):
        """
        Called when the plugin form is closed

        @return: None
        """
        pass

    def Close(self, options):
        """
        Closes the form.

        @param options: Close options (WCLS_SAVE, WCLS_NO_CONTEXT, ...)

        @return: None
        """
        return _ida_kernwin.plgform_close(self.__clink__, options)

    def GetWidget(self):
        """
        Return the TWidget underlying this view.

        @return: The TWidget underlying this view, or None.
        """
        return _ida_kernwin.plgform_get_widget(self.__clink__)
    WCLS_SAVE = _ida_kernwin.WCLS_SAVE
    """save state in desktop config
"""
    """Save state in desktop config"""
    WCLS_NO_CONTEXT = _ida_kernwin.WCLS_NO_CONTEXT
    """don't change the current context (useful for toolbars)
"""
    """Don't change the current context (useful for toolbars)"""
    WCLS_DONT_SAVE_SIZE = _ida_kernwin.WCLS_DONT_SAVE_SIZE
    """don't save size of the window
"""
    """Don't save size of the window"""
    WCLS_DELETE_LATER = _ida_kernwin.WCLS_DELETE_LATER
    """assign the deletion of the widget to the UI loop ///<
"""
    """This flag should be used when Close() is called from an event handler"""
    WCLS_CLOSE_LATER = WCLS_DELETE_LATER


place_t_as_idaplace_t = place_t.as_idaplace_t
place_t_as_simpleline_place_t = place_t.as_simpleline_place_t
place_t_as_tiplace_t = place_t.as_tiplace_t
